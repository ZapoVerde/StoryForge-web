# Group: src/data
# Files: 7

@@FILE: src/data/config/aiConnectionTemplates.ts =====
// src/data/config/aiConnectionTemplates.ts
import type { AiConnection } from '../../models';
export interface ModelInfo {
  id: string; // The API identifier, e.g., "gpt-4-turbo"
  name: string; // The human-readable name, e.g., "GPT-4 Turbo"
  description?: string; // NEW: A description for the tooltip/dialog
}

export interface AiConnectionTemplate extends Omit<AiConnection, 'id' | 'createdAt' | 'lastUpdated'> {
  supportsModelDiscovery: boolean;
  commonModels: ModelInfo[];
}

// Using a Record for easier lookup by key
export const aiConnectionTemplates: Record<string, AiConnectionTemplate> = {
  openai: {
    displayName: 'OpenAI',
    modelName: 'GPT-4o',
    modelSlug: 'gpt-4o',
    apiUrl: 'https://api.openai.com/v1/',
    apiToken: 'PASTE_YOUR_OPENAI_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
      { id: 'gpt-4o', name: 'GPT-4o', description: 'The latest and most advanced model from OpenAI. Excellent reasoning, multimodal capabilities.' },
      { id: 'gpt-4-turbo', name: 'GPT-4 Turbo', description: 'A powerful and fast version of GPT-4, optimized for performance.' },
      { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo', description: 'A highly capable and cost-effective model, great for general purpose tasks.' },
    ],
  },
  google: {
    displayName: 'Google',
    modelName: 'Gemini 1.5 Flash',
    modelSlug: 'gemini-1.5-flash-latest',
    apiUrl: 'https://generativelanguage.googleapis.com/v1beta/',
    apiToken: 'PASTE_YOUR_GOOGLE_AI_STUDIO_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: false, // Google's API needs a different endpoint for model listing
    commonModels: [
      { id: 'gemini-1.5-pro-latest', name: 'Gemini 1.5 Pro', description: 'Google\'s top-tier multimodal model with a massive context window.' },
      { id: 'gemini-1.5-flash-latest', name: 'Gemini 1.5 Flash', description: 'A lightweight, fast, and cost-efficient version of Gemini 1.5.' },
      { id: 'gemini-1.0-pro', name: 'Gemini 1.0 Pro', description: 'The original balanced model for scaled tasks.' },
    ],
  },
  deepseek: {
    displayName: 'DeepSeek',
    modelName: 'DeepSeek Coder V2',
    modelSlug: 'deepseek-coder-v2',
    apiUrl: 'https://api.deepseek.com/v1/',
    apiToken: 'PASTE_YOUR_DEEPSEEK_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
        { id: 'deepseek-chat', name: 'DeepSeek Chat', description: 'Specialized in general conversation and creative text generation.' },
        { id: 'deepseek-coder', name: 'DeepSeek Coder', description: 'Specialized in code generation and explanation. A very capable model.' },
    ],
  },
  openrouter: {
    displayName: 'OpenRouter',
    modelName: 'OpenRouter (Auto)',
    modelSlug: 'openrouter/auto',
    apiUrl: 'https://openrouter.ai/api/v1/',
    apiToken: 'PASTE_YOUR_OPENROUTER_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
        { id: 'openrouter/auto', name: 'Auto (Best)', description: 'OpenRouter automatically selects the best model for your prompt based on price and performance.' },
        { id: 'google/gemini-flash-1.5', name: 'Google: Gemini Flash 1.5', description: 'Fast and affordable model, good for quick tasks.' },
        { id: 'openai/gpt-4o', name: 'OpenAI: GPT-4o', description: 'Access GPT-4o through OpenRouter\'s API.' },
        { id: 'mistralai/mistral-large', name: 'Mistral Large', description: 'High-quality model from Mistral AI, strong reasoning.' },
    ],
  },
  custom: {
    displayName: 'Custom',
    modelName: 'Custom Model',
    modelSlug: '',
    apiUrl: '',
    apiToken: '',
    functionCallingEnabled: false,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: false,
    commonModels: [],
  },
};
@@END_FILE@@

@@FILE: src/data/config/promptCardDefaults.ts =====
// src/data/config/promptCardDefaults.ts

// In src/data/config/promptCardDefaults.ts
import type { AiSettings, StackInstructions} from '../../models';
import  { StackMode, FilterMode} from '../../models';
import { debugLog, errorLog } from '../../utils/debug';

/**
 * Default AI settings to be used for PromptCards if not specified.
 * Corresponds to AiSettings.kt's default values, now embedded in PromptCard.
 */
export const defaultAiSettingsInCard: AiSettings = {
  selectedConnectionId: "",
  temperature: 0.7,
  topP: 1.0,
  maxTokens: 2048,
  presencePenalty: 0.0,
  frequencyPenalty: 0.0,
  functionCallingEnabled: false,
  streaming: true, 
};

/**
 * Default structured StackInstructions object.
 * This is the parsed object version of the default JSON string from PromptCardDefaults.kt.
 */
export const defaultStackInstructions: StackInstructions = {
  narratorProseEmission: { mode: StackMode.FIRST_N, n: 3, filtering: FilterMode.SCENE_ONLY, enabled: true },
  digestPolicy: { filtering: FilterMode.TAGGED, enabled: true },
  digestEmission: {
    "5": { mode: StackMode.ALWAYS, n: 0 }, // MODIFIED: Added n: 0
    "4": { mode: StackMode.AFTER_N, n: 1 },
    "3": { mode: StackMode.FIRST_N, n: 6 },
    "2": { mode: StackMode.FIRST_N, n: 3 },
    "1": { mode: StackMode.NEVER, n: 0 }, // MODIFIED: Added n: 0
  },
  expressionLogPolicy: { mode: StackMode.ALWAYS, n: 0, filtering: FilterMode.SCENE_ONLY, enabled: true },
  expressionLinesPerCharacter: 3,
  emotionWeighting: true,
  worldStatePolicy: { mode: StackMode.FILTERED, n: 0, filtering: FilterMode.SCENE_ONLY, enabled: true },
  knownEntitiesPolicy: { mode: StackMode.FIRST_N, n: 2, filtering: FilterMode.TAGGED, enabled: true },
  // REMOVED: "outputFormat": "prose_digest_emit",
  tokenPolicy: {
    minTokens: 1000,
    maxTokens: 4096,
    fallbackPlan: [
      "drop_known_entities",
      "drop_low_importance_digest",
      "truncate_expression_logs",
    ],
  },
};

/**
 * Default content for the 'firstTurnOnlyBlock' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_FIRST_TURN_PROMPT_BLOCK: string = `The camera pans down. It's your first time in this place.
Describe the scene and how the world feels from the character's perspective.`;

/**
 * Default content for the 'emitSkeleton' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_EMIT_SKELETON_STRING: string = `
### Narrator Output Structure

**IMPORTANT:** Your response MUST follow this exact structure. Each section MUST be separated by the specified markers on their own lines.

1.  **Narrative Prose:**
    *   Begin with clear, immersive narration in freeform prose.
    *   This is the only section that should contain descriptive text. It MUST NOT contain any markers or JSON blocks.

2.  **Summary Digest Block (\`@digest\`):**
    *   After the prose, you MUST include a single newline, followed by the marker \`@digest\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing an array of 1-5 summary lines.
    *   Each line MUST have an importance score from 1 (minor) to 5 (critical).

3.  **Emit Block (\`@delta\`):**
    *   After the digest block, include a single newline, followed by the marker \`@delta\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing key-value deltas for the world state.

4.  **Scene Change Block (\`@scene\`, Optional):
    *   If the scene has shifted, include a single newline, followed by the marker \`@scene\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block with the new scene object.

---

### **MANDATORY OUTPUT FORMAT EXAMPLE**

This is not optional. Your output must match this structure precisely.

The mist curls like spectral fingers around the ancient oaks. #Lyrielle stands rigid, her silver-threaded cloak shimmering faintly in the moonlight. You feel a sudden chill as #Brom shifts his weight, his leather armor creaking.

@digest
\`\`\`json
[
  { "text": "#Lyrielle appears tense and wary.", "importance": 3 },
  { "text": "The mist in @MoonlitVale thickens, obscuring the path.", "importance": 2 }
]
\`\`\`

@delta
\`\`\`json
{
  "=npcs.#lyrielle.status": "wary",
  "+world.environment.fog_density": 0.1
}
\`\`\`

@scene
\`\`\`json
{
  "location": "@MoonlitVale",
  "present": ["#you", "#lyrielle", "#brom"],
  "weather": "foggy"
}
\`\`\`
---

### Emit & Tagging Rules

*   **Emit Rules:** Paths are \`category.entity.field\`. Use symbolic ops: \`+\`, \`=\`, \`!\`, \`-\`. Paths must be valid.
*   **Tagging Rules:** Use \`#\` for characters, \`@\` for locations, \`$\` for items. Use tags consistently in narration and emits.

`.trim();


@@END_FILE@@

@@FILE: src/data/infrastructure/firebaseClient.ts =====
// src/data/infrastructure/firebaseClient.ts

import { initializeApp, getApps, getApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore'; // Removed initializeFirestore and PersistentLocalCache

// Your Firebase configuration
function getEnvVar(name: string): string {
  const value = import.meta.env[name] as string | undefined;
  if (!value) {
    throw new Error(`Missing required environment variable: ${name}`);
  }
  return value;
}

const firebaseConfig = {
  apiKey: getEnvVar('VITE_FIREBASE_API_KEY'),
  authDomain: getEnvVar('VITE_FIREBASE_AUTH_DOMAIN'),
  projectId: getEnvVar('VITE_FIREBASE_PROJECT_ID'),
  storageBucket: getEnvVar('VITE_FIREBASE_STORAGE_BUCKET'),
  messagingSenderId: getEnvVar('VITE_FIREBASE_MESSAGING_SENDER_ID'),
  appId: getEnvVar('VITE_FIREBASE_APP_ID'),
};

// Initialize Firebase App
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

// Get Firebase services (without offline persistence for MVP)
export const auth = getAuth(app);
export const db = getFirestore(app);
@@END_FILE@@

@@FILE: src/data/repositories/aiConnectionRepository.ts =====
// src/data/repositories/aiConnectionRepository.ts

import {
    collection, doc, setDoc, deleteDoc, query, getDocs,
    serverTimestamp, orderBy, Timestamp
  } from 'firebase/firestore';
  import { db } from '../infrastructure/firebaseClient';
  import { generateUuid } from '../../utils/uuid';
  import type { AiConnection } from '../../models';
  
  // Helper to convert Firestore Timestamp to ISO string
  const convertTimestamps = <T extends { createdAt?: any; lastUpdated?: any }>(data: any): T => {
    const convertedData: any = { ...data };
    if (data.createdAt && data.createdAt instanceof Timestamp) {
      convertedData.createdAt = data.createdAt.toDate().toISOString();
    }
    if (data.lastUpdated && data.lastUpdated instanceof Timestamp) {
      convertedData.lastUpdated = data.lastUpdated.toDate().toISOString();
    }
    return convertedData as T;
  };
  
  export interface IAiConnectionRepository {
    getAiConnections(userId: string): Promise<AiConnection[]>;
    saveAiConnection(userId: string, connection: AiConnection): Promise<void>;
    deleteAiConnection(userId: string, connectionId: string): Promise<void>;
  }
  
  class FirestoreAiConnectionRepository implements IAiConnectionRepository {
    private getAiConnectionsCollectionRef(userId: string) {
      return collection(db, 'users', userId, 'aiConnections');
    }
  
    async getAiConnections(userId: string): Promise<AiConnection[]> {
      const q = query(
        this.getAiConnectionsCollectionRef(userId),
        orderBy('displayName', 'asc')
      );
      const querySnapshot = await getDocs(q);
      const connections: AiConnection[] = [];
      querySnapshot.forEach((docSnap) => {
        connections.push(convertTimestamps<AiConnection>(docSnap.data()));
      });
      return connections;
    }
  
    async saveAiConnection(userId: string, connection: AiConnection): Promise<void> {
      const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connection.id);
      await setDoc(connectionDocRef, {
        ...connection,
        createdAt: connection.createdAt || serverTimestamp(),
        lastUpdated: serverTimestamp(),
      }, { merge: true });
      console.log(`AI Connection ${connection.id} saved for user ${userId}`);
    }
  
    async deleteAiConnection(userId: string, connectionId: string): Promise<void> {
      const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connectionId);
      await deleteDoc(connectionDocRef);
      console.log(`AI Connection ${connectionId} deleted for user ${userId}`);
    }
  }
  
  export const aiConnectionRepository = new FirestoreAiConnectionRepository();
@@END_FILE@@

@@FILE: src/data/repositories/authRepository.ts =====
// src/data/authRepository.ts

import {
  GoogleAuthProvider,
  signInWithPopup,
  signOut,
  onAuthStateChanged,
  type User,
} from 'firebase/auth';
import { auth } from '../infrastructure/firebaseClient'; // Import the auth instance from our firebaseClient

/**
 * Handles user login using Google as the authentication provider.
 * @returns A Promise that resolves with the Firebase User credential if successful, or rejects with an error.
 */
export async function signInWithGoogle(): Promise<User | null> {
  const provider = new GoogleAuthProvider();
  try {
    const result = await signInWithPopup(auth, provider);
    // The signed-in user info.
    const user = result.user;
    console.log("User logged in:", user.uid);
    return user;
  } catch (error: any) {
    // Handle Errors here.
    const errorCode = error.code;
    const errorMessage = error.message;
    // The email of the user's account used.
    const email = error.customData?.email;
    // The AuthCredential type that was used.
    const credential = GoogleAuthProvider.credentialFromError(error);
    console.error("Error signing in with Google:", errorCode, errorMessage, email, credential);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Handles user logout.
 * @returns A Promise that resolves when the user is successfully signed out.
 */
export async function signOutUser(): Promise<void> {
  try {
    await signOut(auth);
    console.log("User signed out.");
  } catch (error) {
    console.error("Error signing out:", error);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Subscribes to authentication state changes.
 * This is crucial for keeping the UI updated about the current user's login status.
 * @param callback A function to call when the auth state changes, receiving the current Firebase User or null.
 * @returns An unsubscribe function that can be called to stop listening for changes.
 */
export function subscribeToAuthChanges(callback: (user: User | null) => void): () => void {
  // onAuthStateChanged returns an unsubscribe function
  const unsubscribe = onAuthStateChanged(auth, (user) => {
    callback(user);
  });
  console.log("Auth state change listener attached.");
  return unsubscribe;
}

// Optional: You could also add a way to get the current user synchronously if needed,
// though `subscribeToAuthChanges` is generally preferred for reactivity.
export function getCurrentUser(): User | null {
  return auth.currentUser;
}
@@END_FILE@@

@@FILE: src/data/repositories/gameRepository.ts =====
// src/data/repositories/gameRepository.ts

import {
  collection, doc, getDoc, setDoc, deleteDoc, query, getDocs,
  serverTimestamp, orderBy, Timestamp, where, writeBatch
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient';
import type { GameSnapshot } from '../../models';

/**
 * Defines the contract for GameSnapshot data persistence operations.
 */
export interface IGameRepository {
  saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void>;
  getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null>;
  getAllGameSnapshots(userId: string): Promise<GameSnapshot[]>;
  deleteGameSnapshot(userId: string, snapshotId: string): Promise<void>;
  getGameTimeline(userId: string, gameId: string): Promise<GameSnapshot[]>;
  deleteFutureTurns(userId: string, gameId: string, fromTurn: number): Promise<void>;
}

/**
 * Concrete implementation of IGameRepository using Firestore.
 */
class FirestoreGameRepository implements IGameRepository {
  private getSnapshotsCollectionRef(userId: string) {
    return collection(db, 'users', userId, 'gameSnapshots');
  }

  // Helper to convert Firestore Timestamp to ISO string
  private convertTimestamps<T extends { createdAt?: any; updatedAt?: any }>(data: any): T {
    const convertedData: any = { ...data };
    if (data.createdAt && data.createdAt instanceof Timestamp) {
      convertedData.createdAt = data.createdAt.toDate().toISOString();
    }
    if (data.updatedAt && data.updatedAt instanceof Timestamp) {
      convertedData.updatedAt = data.updatedAt.toDate().toISOString();
    }
    return convertedData as T;
  }

  async saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshot.id);
    try {
      await setDoc(snapshotDocRef, {
        ...snapshot,
        updatedAt: serverTimestamp()
      }, { merge: true });
    } catch (e) {
      console.error(`FirestoreGameRepository: FAILED to setDoc for GameSnapshot ${snapshot.id}:`, e);
      throw e;
    }
  }

  async getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    const snapshotSnap = await getDoc(snapshotDocRef);
    if (snapshotSnap.exists()) {
      return this.convertTimestamps<GameSnapshot>(snapshotSnap.data()) as GameSnapshot;
    } else {
      return null;
    }
  }

  async getAllGameSnapshots(userId: string): Promise<GameSnapshot[]> {
    const q = query(this.getSnapshotsCollectionRef(userId), orderBy('updatedAt', 'desc'));
    const querySnapshot = await getDocs(q);
    const snapshots: GameSnapshot[] = [];
    querySnapshot.forEach((doc) => {
      snapshots.push(this.convertTimestamps<GameSnapshot>(doc.data()) as GameSnapshot);
    });
    return snapshots;
  }

  async deleteGameSnapshot(userId: string, snapshotId: string): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    await deleteDoc(snapshotDocRef);
  }

  async getGameTimeline(userId: string, gameId: string): Promise<GameSnapshot[]> {
    const q = query(
      this.getSnapshotsCollectionRef(userId),
      where('gameId', '==', gameId),
      orderBy('currentTurn', 'asc')
    );
    const querySnapshot = await getDocs(q);
    const timeline: GameSnapshot[] = [];
    querySnapshot.forEach((doc) => {
      timeline.push(this.convertTimestamps<GameSnapshot>(doc.data()) as GameSnapshot);
    });
    return timeline;
  }

  async deleteFutureTurns(userId: string, gameId: string, fromTurn: number): Promise<void> {
    const q = query(
      this.getSnapshotsCollectionRef(userId),
      where('gameId', '==', gameId),
      where('currentTurn', '>', fromTurn)
    );
    const querySnapshot = await getDocs(q);
    if (querySnapshot.empty) return;
    const batch = writeBatch(db);
    querySnapshot.forEach(doc => batch.delete(doc.ref));
    await batch.commit();
  }
}

export const gameRepository = new FirestoreGameRepository();
@@END_FILE@@

@@FILE: src/data/repositories/promptCardRepository.ts =====
// src/data/repositories/promptCardRepository.ts

import {
  collection,
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  query,
  getDocs,
  serverTimestamp,
  orderBy
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient'; // Import our Firestore instance
import type { PromptCard } from '../../models';
import { toIsoStringIfTimestamp } from '../../utils/formatDate';

/**
 * Defines the contract for PromptCard data persistence operations.
 * This interface can be implemented by different concrete repositories
 * (e.g., FirestorePromptCardRepository, MockPromptCardRepository)
 * to allow for easy swapping of data sources.
 */
export interface IPromptCardRepository {
  /**
   * Saves a new or updates an existing PromptCard.
   * If the card already has an ID, it will update the existing document.
   * If not, it assumes the card object passed already has an ID generated (e.g., by cardManager).
   * @param userId The ID of the user owning the card.
   * @param card The PromptCard object to save.
   * @returns A Promise that resolves when the card is successfully saved.
   */
  savePromptCard(userId: string, card: PromptCard): Promise<void>;

  /**
   * Retrieves a single PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to retrieve.
   * @returns A Promise that resolves with the PromptCard object or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a specific user, ordered by updatedAt descending.
   * @param userId The ID of the user owning the cards.
   * @returns A Promise that resolves with an array of PromptCard objects.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Deletes a PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to delete.
   * @returns A Promise that resolves when the card is successfully deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Imports a collection of PromptCards. This method will likely involve
   * generating new IDs/hashes and setting ownerId upon import.
   * The actual logic for generating IDs/hashes and setting ownerId should be in cardManager.ts,
   * this repository method merely handles the bulk persistence.
   * @param userId The ID of the user importing the cards.
   * @param cards The array of PromptCard objects to import.
   * @returns A Promise that resolves when all cards are imported.
   */
  importPromptCards(userId: string, cards: PromptCard[]): Promise<void>;
}

/**
 * Concrete implementation of IPromptCardRepository using Firestore.
 */
export class FirestorePromptCardRepository implements IPromptCardRepository {

  private getCollectionRef(userId: string) {
    // Path: users/{userId}/promptCards
    return collection(db, 'users', userId, 'promptCards');
  }

  async savePromptCard(userId: string, card: PromptCard): Promise<void> {
    if (!card.id) {
      // This case should ideally be prevented by logic in cardManager or wherever cards are created
      // as PromptCard should always have an ID before reaching the repository.
      throw new Error("PromptCard must have an ID to be saved.");
    }
    const cardDocRef = doc(this.getCollectionRef(userId), card.id);
    await setDoc(cardDocRef, {
      ...card,
      updatedAt: serverTimestamp() // Firestore special value for server timestamp
    }, { merge: true }); // Use merge: true to update existing fields and add new ones without overwriting entire doc
    // Note: createdAt should only be set on initial creation, not on every update.
    // We'll manage createdAt in cardManager.ts before passing to repository.
    console.log(`PromptCard ${card.id} saved for user ${userId}`);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    const cardSnap = await getDoc(cardDocRef);

    if (cardSnap.exists()) {
      // Firestore `data()` method returns `any`. We cast it to PromptCard.
      // Note: serverTimestamp() will be an object like { seconds: ..., nanoseconds: ... }
      // when retrieved, not an ISO string. We might need a conversion layer if UI strictly expects ISO string.
      // However, Firestore handles this transparently for objects if saving back.
      // For display, formatIsoDateForDisplay will handle it correctly if it's Date or Timestamp object.
      const data = cardSnap.data() as PromptCard;

      // Firestore's serverTimestamp() retrieves as a Timestamp object.
      // To ensure our PromptCard interface holds string (ISO 8601), we convert it here.
      // This is a common pattern: store one way, retrieve/convert to match app's type.
      return {
        ...data,
        createdAt: toIsoStringIfTimestamp(data.createdAt),
        updatedAt: toIsoStringIfTimestamp(data.updatedAt),
      };
    } else {
      console.log(`No PromptCard found with ID: ${cardId} for user ${userId}`);
      return null;
    }
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    const q = query(
      this.getCollectionRef(userId),
      orderBy('updatedAt', 'desc') // Order by last updated, newest first
    );
    const querySnapshot = await getDocs(q);
    const cards: PromptCard[] = [];
    querySnapshot.forEach((doc) => {
      // Same conversion for Timestamp objects as in getPromptCard
      const data = doc.data() as PromptCard;
      cards.push({
        ...data,
        createdAt: toIsoStringIfTimestamp(data.createdAt),
        updatedAt: toIsoStringIfTimestamp(data.updatedAt),
      });
    });
    console.log(`Retrieved ${cards.length} prompt cards for user ${userId}`);
    return cards;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    await deleteDoc(cardDocRef);
    console.log(`PromptCard ${cardId} deleted for user ${userId}`);
  }

  async importPromptCards(userId: string, cards: PromptCard[]): Promise<void> {
    // Firestore transactions/batch writes are ideal for bulk operations.
    // For simplicity in MVP, we'll do individual setDoc calls in parallel.
    // A more robust solution might use writeBatch for atomicity.
    const importPromises = cards.map(async (card) => {
      // Assume cardManager has already processed these cards for import (new IDs, hashes, ownerId).
      const cardDocRef = doc(this.getCollectionRef(userId), card.id);
      await setDoc(cardDocRef, {
        ...card,
        // Ensure timestamps are correctly handled for imported cards.
        // If the imported card already has createdAt/updatedAt, use them.
        // Otherwise, serverTimestamp() is an option, but for imports,
        // it's often preferred to preserve original times or set a specific import time.
        // For now, assume the card object already has string ISO timestamps set by cardManager.
      });
    });
    await Promise.all(importPromises);
    console.log(`Successfully imported ${cards.length} prompt cards for user ${userId}`);
  }
}

// Export a singleton instance of the repository for use throughout the application
export const promptCardRepository = new FirestorePromptCardRepository();
@@END_FILE@@
