# Group: src/ui
# Files: 43

@@FILE: src/ui/components/AiSettingsEditor.tsx =====
// src/ui/components/AiSettingsEditor.tsx

import React from 'react';
import {
  Box,
  Typography,
  Slider,
  Switch,
  FormControlLabel,
  Divider,
  TextField,
  MenuItem,
} from '@mui/material';
import type { AiSettings, AiConnection } from '../../models/index';
import { CollapsibleSection } from './CollapsibleSection';

interface AiSettingsEditorProps {
  label: string;
  settings: AiSettings;
  onSettingsChange: (updatedSettings: AiSettings) => void;
  availableConnections: AiConnection[];
}

export const AiSettingsEditor: React.FC<AiSettingsEditorProps> = ({
  label,
  settings,
  onSettingsChange,
  availableConnections,
}) => {
  const handleSliderChange = (
    prop: keyof AiSettings,
    newValue: number | number[]
  ) => {
    onSettingsChange({ ...settings, [prop]: newValue as number });
  };

  const handleSwitchChange = (prop: keyof AiSettings, checked: boolean) => {
    onSettingsChange({ ...settings, [prop]: checked });
  };

  const handleConnectionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onSettingsChange({ ...settings, selectedConnectionId: event.target.value });
  };

  return (
    <CollapsibleSection title={label} initiallyExpanded={false}>
      <TextField
        select
        fullWidth
        label="AI Connection"
        value={settings.selectedConnectionId}
        onChange={handleConnectionChange}
        variant="outlined"
        sx={{ mb: 2 }}
      >
        {availableConnections.map((conn) => (
          <MenuItem key={conn.id} value={conn.id}>
            {conn.modelName} ({conn.id})
          </MenuItem>
        ))}
      </TextField>

      <Typography gutterBottom>
        Temperature: {settings.temperature.toFixed(2)}
      </Typography>
      <Slider
        value={settings.temperature}
        onChange={(_e, val) => handleSliderChange('temperature', val)}
        min={0.0}
        max={1.5}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls randomness. Low = logical, high = creative. RPG-optimal:
        0.7–1.0.
      </Typography>

      <Typography gutterBottom>Top P: {settings.topP.toFixed(2)}</Typography>
      <Slider
        value={settings.topP}
        onChange={(_e, val) => handleSliderChange('topP', val)}
        min={0.0}
        max={1.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls diversity. Lower = focused, higher = expressive. RPG-optimal:
        0.8–1.0.
      </Typography>

      <Typography gutterBottom>Max Tokens: {settings.maxTokens}</Typography>
      <Slider
        value={settings.maxTokens}
        onChange={(_e, val) => handleSliderChange('maxTokens', val)}
        min={256}
        max={8192}
        step={256}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Maximum length of AI reply. Longer = more story depth. RPG-optimal:
        1024–4096.
      </Typography>

      <Typography gutterBottom>
        Presence Penalty: {settings.presencePenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.presencePenalty}
        onChange={(_e, val) => handleSliderChange('presencePenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages introducing new topics repeatedly. RPG-optimal: 0.0–0.5.
      </Typography>

      <Typography gutterBottom>
        Frequency Penalty: {settings.frequencyPenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.frequencyPenalty}
        onChange={(_e, val) => handleSliderChange('frequencyPenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages repeating phrases. Helps avoid spam. RPG-optimal: 0.2–0.8.
      </Typography>

      <Divider sx={{ my: 2 }} />

      <FormControlLabel
        control={
          <Switch
            checked={settings.functionCallingEnabled}
            onChange={(e) =>
              handleSwitchChange('functionCallingEnabled', e.target.checked)
            }
          />
        }
        label="Enable Function Calling"
      />
      <Typography variant="body2" color="text.secondary">
        Allows AI to call structured functions (if you've defined them in the
        prompt).
      </Typography>

      <FormControlLabel
        control={
          <Switch
            checked={settings.streaming} // RENAMED
            onChange={(e) =>
              handleSwitchChange('streaming', e.target.checked) // RENAMED
            }
          />
        }
        label="Enable Streaming Output" // UPDATED LABEL
      />
      <Typography variant="body2" color="text.secondary">
        Displays AI-generated narrative text as it's generated (typing effect).
      </Typography>
    </CollapsibleSection>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/AuthOrchestrator.tsx =====
// src/ui/components/AuthOrchestrator.tsx
import React, { useEffect, useReducer } from 'react';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useNavigate, useLocation, Outlet } from 'react-router-dom';
import { Box, CircularProgress, Typography } from '@mui/material';
import { debugLog } from '../../utils/debug';

// --- Start of State Machine Definition ---

type LoadingState = 'IDLE' | 'CHECKING_AUTH' | 'LOADING_GAME' | 'READY';
type LoadingAction =
  | { type: 'AUTH_CHECK_COMPLETE'; payload: { isAuthenticated: boolean } }
  | { type: 'GAME_LOAD_SUCCESS' }
  | { type: 'GAME_LOAD_FAIL' }
  | { type: 'RESET' };

const reducer = (state: LoadingState, action: LoadingAction): LoadingState => {
  debugLog(`%c[AuthOrchestrator] State Transition: ${state} -> Action: ${action.type}`, 'color: blue;');
  switch (state) {
    case 'IDLE':
      if (action.type === 'AUTH_CHECK_COMPLETE') {
        return action.payload.isAuthenticated ? 'LOADING_GAME' : 'READY';
      }
      return state;
    case 'LOADING_GAME':
      if (action.type === 'GAME_LOAD_SUCCESS' || action.type === 'GAME_LOAD_FAIL') {
        return 'READY';
      }
      if (action.type === 'RESET') {
        return 'IDLE';
      }
      return state;
    case 'READY':
      if (action.type === 'RESET') {
        return 'IDLE';
      }
      return state;
    default:
      return state;
  }
};
// --- End of State Machine Definition ---


const AuthOrchestrator: React.FC = () => {
  const { user, isLoading: isAuthLoading } = useAuthStore();
  const loadLastActiveGame = useGameStateStore(state => state.loadLastActiveGame);
  const navigate = useNavigate();
  const location = useLocation();

  const [state, dispatch] = useReducer(reducer, 'IDLE');

  // Effect 1: React to authentication changes to kick off the state machine.
  useEffect(() => {
    if (!isAuthLoading) {
      dispatch({ type: 'AUTH_CHECK_COMPLETE', payload: { isAuthenticated: !!user } });
    }
  }, [isAuthLoading, user]);

  // Effect 2: Perform side-effects based on the current state of the machine.
  useEffect(() => {
    if (state === 'LOADING_GAME' && user) {
      loadLastActiveGame(user.uid).then((gameLoaded) => {
        dispatch({ type: gameLoaded ? 'GAME_LOAD_SUCCESS' : 'GAME_LOAD_FAIL' });
        // Navigate only if we are at the root, otherwise stay put.
        if (location.pathname === '/') {
          navigate(gameLoaded ? '/game' : '/library', { replace: true });
        }
      }).catch(() => {
        dispatch({ type: 'GAME_LOAD_FAIL' });
        if (location.pathname === '/') {
          navigate('/library', { replace: true });
        }
      });
    }
  }, [state, user, loadLastActiveGame, navigate, location.pathname]);
  
  // Effect 3: Reset the machine if the user logs out.
  useEffect(() => {
    if (!user && state === 'READY') {
      dispatch({ type: 'RESET' });
    }
  }, [user, state]);


  // Render loading indicator until the machine is in the 'READY' state.
  if (state !== 'READY') {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Session...</Typography>
      </Box>
    );
  }

  // Once ready, render the nested routes.
  return <Outlet />;
};

export default AuthOrchestrator;
@@END_FILE@@

@@FILE: src/ui/components/CollapsibleLogEntry.tsx =====
// src/ui/components/CollapsibleLogEntry.tsx

import React from 'react';
import { Box, Typography, Divider } from '@mui/material';
import type { LogEntry } from '../../models/LogEntry';
import { LogViewMode } from '../../utils/types';
import { CollapsibleSection } from './CollapsibleSection';
// This component should be importing DetailedLogTurnView or LogEntryDisplay
// Let's assume you're building out the detailed view as discussed.
// If you're using the simpler LogEntryDisplay, the fix is the same.
import { LogEntryDisplay } from './LogEntryDisplay';

interface CollapsibleLogEntryProps {
  entry: LogEntry;
  selectedLogViewModes: LogViewMode[];
}

// NOTE: This component might be redundant if `DetailedLogTurnView` does everything.
// However, fixing the error is straightforward.
export const CollapsibleLogEntry: React.FC<CollapsibleLogEntryProps> = ({ entry, selectedLogViewModes }) => {
  // ... (logic to check if there's content remains the same)

  return (
    <CollapsibleSection
      title={`Turn ${entry.turnNumber} - ${new Date(entry.timestamp).toLocaleTimeString()}`}
      initiallyExpanded={entry.turnNumber === 0}
    >
      <Box sx={{ p: 1 }}>
        {selectedLogViewModes.length === 0 ? (
          <Typography variant="body2" color="text.secondary">
            No log view modes selected.
          </Typography>
        ) : (
          selectedLogViewModes.map((mode, index) => (
            <React.Fragment key={mode}>
              <CollapsibleSection title={mode} initiallyExpanded={true}>
                {/* --- THE FIX IS HERE --- */}
                {/* Remove the hideTurnInfo prop */}
                <LogEntryDisplay mode={mode} entry={entry} />
              </CollapsibleSection>
              {index < selectedLogViewModes.length - 1 && <Divider sx={{ my: 1 }} />}
            </React.Fragment>
          ))
        )}
      </Box>
    </CollapsibleSection>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/CollapsibleSection.tsx =====
// src/ui/components/CollapsibleSection.tsx

import React from 'react';
import {
  Card,
  CardContent,
  Typography,
  IconButton,
  Collapse,
  Box,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';

interface CollapsibleSectionProps {
  title: string;
  children: React.ReactNode;
  initiallyExpanded?: boolean;
}

export const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  children,
  initiallyExpanded = false,
}) => {
  const [expanded, setExpanded] = React.useState(initiallyExpanded);

  const handleExpandClick = () => {
    setExpanded(!expanded);
  };

  return (
    <Card variant="outlined" sx={{ mb: 2 }}>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1.5,
          cursor: 'pointer',
          '&:hover': {
            backgroundColor: (theme) => theme.palette.action.hover,
          },
        }}
        onClick={handleExpandClick}
      >
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
        </Typography>
        <IconButton
          onClick={handleExpandClick}
          aria-expanded={expanded}
          aria-label="show more"
          size="small"
        >
          {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
      </Box>
      <Collapse in={expanded} timeout="auto" unmountOnExit>
        <CardContent sx={{ pt: 1 }}>{children}</CardContent>
      </Collapse>
    </Card>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/DetailedLogTurnView.tsx =====
// src/ui/components/DetailedLogTurnView.tsx

import React from 'react';
import { Box, Divider } from '@mui/material';
import { LogViewMode } from '../../utils/types';
import type { LogEntry } from '../../models';
import { CollapsibleSection } from './CollapsibleSection';
import { LogEntryDisplay } from './LogEntryDisplay';

interface DetailedLogTurnViewProps {
  entry: LogEntry;
  selectedLogViewModes: LogViewMode[];
}

// This defines the ideal chronological and logical order of log parts.
const RENDER_ORDER: LogViewMode[] = [
    LogViewMode.API_DETAILS, // Metadata first
    LogViewMode.CONTEXT_SNAPSHOT,
    LogViewMode.API_REQUEST_BODY, // Then the request body
    LogViewMode.USER_INPUT,
    LogViewMode.RAW_NARRATOR_OUTPUT,
    LogViewMode.API_RESPONSE_BODY, // Then the response body
    LogViewMode.NARRATOR_OUTPUT,
    LogViewMode.DIGEST_LINES,
    LogViewMode.DELTAS,
    // These are metadata and appear last
    LogViewMode.MODEL_SLUG_USED,
    LogViewMode.AI_SETTINGS,
    LogViewMode.TOKEN_USAGE,
    LogViewMode.ERROR_FLAGS,
  ];

export const DetailedLogTurnView: React.FC<DetailedLogTurnViewProps> = ({ entry, selectedLogViewModes }) => {
  // Filter the master RENDER_ORDER array to only include modes the user has selected.
  const viewsToRender = RENDER_ORDER.filter(mode => selectedLogViewModes.includes(mode));

  if (viewsToRender.length === 0) {
    return null; // Don't render anything for this turn if no relevant views are selected
  }

  return (
    // Each turn is its own collapsible section
    <CollapsibleSection
      title={`Turn ${entry.turnNumber} - ${new Date(entry.timestamp).toLocaleTimeString()}`}
      initiallyExpanded={entry.turnNumber === 0 || !!entry.errorFlags?.length} // Expand first turn or turns with errors
    >
      <Box sx={{ p: 1 }}>
        {viewsToRender.map((mode, index) => (
          <React.Fragment key={mode}>
            {/* Each part of the log within the turn is ALSO a collapsible section */}
            <CollapsibleSection title={mode} initiallyExpanded={true}>
              <LogEntryDisplay mode={mode} entry={entry} />
            </CollapsibleSection>
            {index < viewsToRender.length - 1 && <Divider sx={{ my: 1.5, opacity: 0.5 }} />}
          </React.Fragment>
        ))}
      </Box>
    </CollapsibleSection>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/InfoDialog.tsx =====
// src/ui/components/InfoDialog.tsx

import React, { useState } from 'react';
import { Dialog, DialogTitle, DialogContent, DialogActions, Button, IconButton, Tooltip, Box } from '@mui/material';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';

interface InfoDialogProps {
  title: string;
  content: string | React.ReactNode; // Can be a string or JSX
  iconSize?: 'small' | 'medium' | 'large';
  tooltipText?: string; // Optional text for the initial hover tooltip
}

export const InfoDialog: React.FC<InfoDialogProps> = ({ title, content, iconSize = 'small', tooltipText = "Click for more information" }) => {
  const [open, setOpen] = useState(false);

  const handleClickOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <>
      <Tooltip title={tooltipText}>
        <IconButton size={iconSize} onClick={handleClickOpen} sx={{ ml: 0.5, p: 0 }}>
          <InfoOutlinedIcon fontSize="small" />
        </IconButton>
      </Tooltip>
      <Dialog
        open={open}
        onClose={handleClose}
        aria-labelledby="info-dialog-title"
        fullWidth
        maxWidth="sm"
      >
        <DialogTitle id="info-dialog-title">{title}</DialogTitle>
        <DialogContent dividers>
          {/* Use Box with pre-wrap to respect line breaks in string content */}
          {typeof content === 'string' ? <Box sx={{ whiteSpace: 'pre-wrap' }}>{content}</Box> : content}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Close</Button>
        </DialogActions>
      </Dialog>
    </>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/LogEntryDisplay.tsx =====
// src/ui/components/LogEntryDisplay.tsx

import React from 'react';
import { Typography, Alert, Paper, Box } from '@mui/material'; // Add Paper and Box
import type { LogEntry } from '../../models';
import { LogViewMode } from '../../utils/types';

interface LogEntryDisplayProps {
  mode: LogViewMode;
  entry: LogEntry;
}

export const LogEntryDisplay: React.FC<LogEntryDisplayProps> = ({ mode, entry }) => {
  const renderContent = () => {
    switch (mode) {
      case LogViewMode.USER_INPUT:
        return entry.userInput || <Alert severity="info" sx={{mt:1}}>No user input for this turn (e.g., initial game state).</Alert>;

      case LogViewMode.NARRATOR_OUTPUT:
        return entry.prose || <Alert severity="info" sx={{mt:1}}>No prose was generated for this turn.</Alert>;
        
      case LogViewMode.RAW_NARRATOR_OUTPUT: // Add a case for the raw output if needed
        return entry.narratorOutput || <Alert severity="info" sx={{mt:1}}>No raw output was logged.</Alert>;

      case LogViewMode.DIGEST_LINES:
        if (!entry.digestLines || entry.digestLines.length === 0) return <Alert severity="info" sx={{mt:1}}>No digest lines.</Alert>;
        return entry.digestLines.map((d, i) => `(Importance ${d.importance}) ${d.text}`).join('\n');

      case LogViewMode.DELTAS:
        if (!entry.deltas || Object.keys(entry.deltas).length === 0) return <Alert severity="info" sx={{mt:1}}>No deltas.</Alert>;
        return JSON.stringify(entry.deltas, null, 2);

      case LogViewMode.CONTEXT_SNAPSHOT:
        return entry.contextSnapshot || <Alert severity="info" sx={{mt:1}}>No context snapshot was logged.</Alert>;

      case LogViewMode.TOKEN_USAGE:
        if (!entry.tokenUsage) return <Alert severity="info" sx={{mt:1}}>No token usage info.</Alert>;
        return `Input: ${entry.tokenUsage.inputTokens}, Output: ${entry.tokenUsage.outputTokens}, Total: ${entry.tokenUsage.totalTokens}`;

      case LogViewMode.AI_SETTINGS:
        if (!entry.aiSettings) return <Alert severity="info" sx={{mt:1}}>No AI settings logged.</Alert>;
        return JSON.stringify(entry.aiSettings, null, 2);

      case LogViewMode.API_DETAILS:
        const details = [
          `URL: ${entry.apiUrl || 'N/A'}`,
          `Latency: ${entry.latencyMs !== null ? `${entry.latencyMs}ms` : 'N/A'}`,
        ];
        return details.join('\n');

      // ADDED: New case for the request body.
      case LogViewMode.API_REQUEST_BODY:
        if (!entry.apiRequestBody) return <Alert severity="info" sx={{mt:1}}>No request body was logged.</Alert>;
        return (
            <Paper variant="outlined" sx={{ p: 1, mt: 1, backgroundColor: (theme) => theme.palette.action.hover }}>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all', fontSize: '0.8rem' }}>
                {entry.apiRequestBody}
              </Typography>
            </Paper>
        );

      // ADDED: New case for the response body.
      case LogViewMode.API_RESPONSE_BODY:
        if (!entry.apiResponseBody) return <Alert severity="info" sx={{mt:1}}>No response body was logged.</Alert>;
        return (
            <Paper variant="outlined" sx={{ p: 1, mt: 1, backgroundColor: (theme) => theme.palette.action.hover }}>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all', fontSize: '0.8rem' }}>
                {entry.apiResponseBody}
              </Typography>
            </Paper>
        );

      case LogViewMode.ERROR_FLAGS:
        if (!entry.errorFlags || entry.errorFlags.length === 0) return <Alert severity="success" sx={{mt:1}}>No errors flagged.</Alert>;
        return <Alert severity="error" sx={{mt:1}}>{entry.errorFlags.join(', ')}</Alert>;

      case LogViewMode.RAW_NARRATOR_OUTPUT:
        return entry.narratorOutput || <Alert severity="info" sx={{mt:1}}>No raw output was logged.</Alert>;
  
      case LogViewMode.MODEL_SLUG_USED: // ADD THIS CASE
        return entry.modelSlugUsed || <Alert severity="info" sx={{mt:1}}>Model slug was not logged.</Alert>;  

      default:
        return `Unknown log view mode: ${mode}`;
    }
  };

  // The outer component can be simplified as the inner content now handles its own formatting
  // We can create a list of modes that need special paper/box wrapping
  const needsWrapper = [LogViewMode.API_REQUEST_BODY, LogViewMode.API_RESPONSE_BODY, LogViewMode.ERROR_FLAGS];
  if (needsWrapper.includes(mode)) {
    return <Box>{renderContent()}</Box>;
  }

  return (
    <Typography variant="body2" component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word', mt: 0.5, fontFamily: 'monospace', fontSize: '0.9rem' }}>
      {renderContent()}
    </Typography>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/LogView.tsx =====
// src/ui/components/LogView.tsx

import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
import type { Message } from '../../models';

interface LogViewProps {
  conversationHistory: Message[];
  currentStreamingNarration: string;
  isProcessingTurn: boolean;
  fullLatestNarration: string;
  enableStreaming: boolean;
}

export const LogView: React.FC<LogViewProps> = ({
  conversationHistory,
  currentStreamingNarration,
  isProcessingTurn,
  fullLatestNarration,
  enableStreaming
}) => {
  const isInitialDisplay = conversationHistory.length === 0;

  const lastMessageInHistoryIsLatest =
    conversationHistory.length > 0 &&
    conversationHistory[conversationHistory.length - 1].role === 'assistant' &&
    conversationHistory[conversationHistory.length - 1].content === fullLatestNarration;

  const messagesToRenderFromHistory =
    (enableStreaming && isProcessingTurn) ||
    (enableStreaming && !lastMessageInHistoryIsLatest && fullLatestNarration.length > 0 && currentStreamingNarration !== fullLatestNarration)
      ? conversationHistory.slice(0, -1)
      : conversationHistory;

  return (
    <Box sx={{ flexGrow: 1, overflowY: 'auto' }}>
      {isInitialDisplay ? (
        // Show initial prose block if there's no prior conversation
        <Paper elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
          <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
            AI Narrator:
          </Typography>
          <Typography variant="body1">
            {fullLatestNarration}
          </Typography>
        </Paper>
      ) : (
        messagesToRenderFromHistory.map((message, index) => (
          <Paper key={index} elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
            {message.role === 'user' ? (
              <>
                <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.primary.dark }}>
                  You:
                </Typography>
                <Typography variant="body1" sx={{ mb: 1 }}>
                  {message.content}
                </Typography>
              </>
            ) : (
              <>
                <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
                  AI Narrator:
                </Typography>
                <Typography variant="body1">
                  {message.content}
                </Typography>
              </>
            )}
          </Paper>
        ))
      )}

{!isInitialDisplay && fullLatestNarration && !lastMessageInHistoryIsLatest && (
        <Paper elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
          <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
            AI Narrator:
          </Typography>
          <Typography variant="body1">
            {isProcessingTurn || (enableStreaming && currentStreamingNarration !== fullLatestNarration)
              ? currentStreamingNarration
              : fullLatestNarration}
          </Typography>
        </Paper>
      )}
    </Box>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/MainLayout.tsx =====
// src/ui/components/MainLayout.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Drawer, List, ListItem, ListItemButton, ListItemIcon, ListItemText,
  CssBaseline, Box, Typography, Divider, IconButton
} from '@mui/material';
import LogoutIcon from '@mui/icons-material/Logout';
import MenuIcon from '@mui/icons-material/Menu';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { getNavItems } from '../../config/navigation';
import { LayoutProvider } from '../../contexts/LayoutContext';

const drawerWidth = 240;

const MainLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user, signOut } = useAuthStore();
  const { currentSnapshot } = useGameStateStore();
  const navigate = useNavigate();
  const [mobileOpen, setMobileOpen] = useState(false);

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleSignOut = async () => {
    await signOut();
    navigate('/login');
  };

  const navItems = getNavItems(currentSnapshot);

  const drawerContent = (
    <Box onClick={handleDrawerToggle} sx={{ textAlign: 'center' }}>
      <Typography variant="h6" sx={{ my: 2 }}>StoryForge</Typography>
      <Divider />
      <List>
        {navItems.filter(item => user ? true : !item.requiresAuth).map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton onClick={() => navigate(item.path)} disabled={item.disabled}>
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
        {user ? (
          <ListItem disablePadding>
            <ListItemButton onClick={handleSignOut}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItemButton>
          </ListItem>
        ) : (
          <ListItem disablePadding>
            <ListItemButton onClick={() => navigate('/login')}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Login" />
            </ListItemButton>
          </ListItem>
        )}
      </List>
    </Box>
  );

  return (
    <LayoutProvider>
      <Box sx={{ display: 'flex', height: '100vh' }}>
        <CssBaseline />
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{ keepMounted: true }}
          sx={{ '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth } }}
        >
          {drawerContent}
        </Drawer>

        <Box component="main" sx={{ flexGrow: 1, height: '100%', display: 'flex', flexDirection: 'column' }}>
          {user && (
            <IconButton
              color="inherit"
              aria-label="open drawer"
              onClick={handleDrawerToggle}
              edge="start"
              sx={{
                position: 'fixed',
                top: 16,
                right: 16,
                zIndex: (theme) => theme.zIndex.drawer + 1,
                backgroundColor: (theme) => theme.palette.background.paper,
                boxShadow: 2,
                '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
              }}
            >
              <MenuIcon />
            </IconButton>
          )}
          {children}
        </Box>
      </Box>
    </LayoutProvider>
  );
};

export default MainLayout;
@@END_FILE@@

@@FILE: src/ui/components/PinnedAttributeChip.tsx =====
// src/ui/components/PinnedAttributeChip.tsx

import React from 'react';
import { Chip, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';

interface PinnedAttributeChipProps {
  fullKey: string;
  label: string;
  value: any;
  onUnpin: (key: string) => void;
}

export const PinnedAttributeChip: React.FC<PinnedAttributeChipProps> = React.memo(
  ({ fullKey, label, value, onUnpin }) => {
    const longPressProps = useLongPress((e) => {
      e.stopPropagation();
      onUnpin(fullKey);
    });

    return (
      <Tooltip title={`Long-press to unpin '${label}'`} key={fullKey}>
        <Chip
          label={`${label}: ${JSON.stringify(value)}`}
          size="small"
          deleteIcon={<PushPinIcon />}
          sx={{
            backgroundColor: (theme) => theme.palette.chipBackground.main, // CHIP_BG_LIGHT/DARK
            color: (theme) => theme.palette.text.primary,
            fontSize: '0.8rem',
            height: '22px',
            '& .MuiChip-label': {
              px: 1,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
            },
            '& .MuiChip-deleteIcon': {
              opacity: 0.2,
            },
            '&:hover .MuiChip-deleteIcon': {
              opacity: 1,
            },
          }}
          {...longPressProps}
        />
      </Tooltip>
    );
  }
);

@@END_FILE@@

@@FILE: src/ui/components/PinnedEntityGroup.tsx =====
// src/ui/components/PinnedEntityGroup.tsx

import React from 'react';
import { Paper, Typography, Stack, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';
import { PinnedAttributeChip } from './PinnedAttributeChip';

interface Attribute {
  label: string;
  value: any;
  fullKey: string;
}

interface PinnedEntityGroupProps {
  entityPath: string;
  attributes: Attribute[];
  onUnpinEntity: (path: string) => void;
  onUnpinVariable: (key: string) => void;
}

export const PinnedEntityGroup: React.FC<PinnedEntityGroupProps> = ({
  entityPath,
  attributes,
  onUnpinEntity,
  onUnpinVariable,
}) => {
  const longPressEntityProps = useLongPress(() => {
    onUnpinEntity(entityPath);
  });

  const entityDisplayName = entityPath.includes('.')
    ? entityPath.split('.').pop()?.replace(/^[#@$]/, '')
    : entityPath;

  return (
    <Paper
      elevation={3}
      sx={{
        p: 1,
        minWidth: 150,
        backgroundColor: (theme) =>
          theme.palette.mode === 'light'
            ? theme.palette.pinnedEntity.main // Uses PINNED_ENTITY_LIGHT
            : theme.palette.pinnedEntity.main, // Uses PINNED_ENTITY_DARK
        backdropFilter: 'blur(4px)',
        color: (theme) => theme.palette.text.primary,
        flexShrink: 0,
        cursor: 'pointer',
        borderRadius: 3,
        boxShadow: (theme) => theme.shadows[4],
        transition: 'transform 0.15s ease, box-shadow 0.15s ease',
        '&:hover': {
          transform: 'translateY(-2px)',
          boxShadow: (theme) => theme.shadows[6],
        },
      }}
      {...longPressEntityProps}
    >

      <Typography variant="subtitle2" sx={{ fontWeight: 'bold' }}>
        {entityDisplayName}
        <Tooltip title="Long-press to unpin all for this group">
          <PushPinIcon fontSize="small" sx={{ verticalAlign: 'middle', ml: 0.5 }} />
        </Tooltip>
      </Typography>
      <Stack direction="column" spacing={0.5} sx={{ mt: 1 }}>
        {attributes.map((attr) => (
          <PinnedAttributeChip
            key={attr.fullKey}
            fullKey={attr.fullKey}
            label={attr.label}
            value={attr.value}
            onUnpin={onUnpinVariable}
          />
        ))}
      </Stack>
    </Paper>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PinnedItemsView.tsx =====
import React, { useEffect, useCallback } from 'react';
import { Box, Typography, Paper, Stack } from '@mui/material';
import {
  useGameStateStore,
  selectCurrentGameState,
  selectWorldStatePinnedKeys
} from '../../state/useGameStateStore';
import { flattenJsonObject } from '../../utils/jsonUtils';
import { PinnedEntityGroup } from './PinnedEntityGroup';

export const PinnedItemsView: React.FC = React.memo(() => {
  const gameState = useGameStateStore(selectCurrentGameState);
  const worldStatePinnedKeys = useGameStateStore(selectWorldStatePinnedKeys);
  const toggleWorldStatePin = useGameStateStore(state => state.toggleWorldStatePin);

  const worldState = gameState?.worldState || {};

  const flattenedWorld = React.useMemo(() => {
    return flattenJsonObject(worldState);
  }, [worldState]);

  const pinnedItems = React.useMemo(() => {
    const items = worldStatePinnedKeys
      .map((key: string) => ({
        key,
        value: flattenedWorld[key],
      }))
      .filter(item => item.value !== undefined);

    return items;
  }, [worldStatePinnedKeys, flattenedWorld]);

  const groupedPinnedItems = React.useMemo(() => {
    const grouped: { [entityPath: string]: { label: string; value: any; fullKey: string }[] } = {};
    pinnedItems.forEach(item => {
      const parts = item.key.split('.');
      if (parts.length >= 2) {
        const secondPart = parts[1];
        const isTaggedEntity = secondPart.startsWith('#') || secondPart.startsWith('@') || secondPart.startsWith('$');
        let entityPath: string;
        let label: string;

        if (parts.length >= 3 && isTaggedEntity) {
          entityPath = parts.slice(0, 2).join('.');
          label = parts.slice(2).join('.');
        } else {
          entityPath = parts[0];
          label = parts.slice(1).join('.');
        }

        if (label === '') {
          label = parts[parts.length - 1];
        }

        grouped[entityPath] = grouped[entityPath] || [];
        grouped[entityPath].push({ label, value: item.value, fullKey: item.key });
      }
    });

    Object.keys(grouped).forEach(entityPath => {
      grouped[entityPath].sort((a, b) => a.label.localeCompare(b.label));
    });

    return grouped;
  }, [pinnedItems]);

  const handleUnpinEntity = useCallback((entityPath: string) => {
    toggleWorldStatePin(entityPath, 'entity');
  }, [toggleWorldStatePin]);

  const handleUnpinVariable = useCallback((key: string) => {
    toggleWorldStatePin(key, 'variable');
  }, [toggleWorldStatePin]);

  useEffect(() => {
    console.log("[PinnedItemsView] Re-rendered");
    console.log("Pinned keys:", worldStatePinnedKeys);
    console.log("Total grouped items:", Object.keys(groupedPinnedItems).length);
  }, [worldStatePinnedKeys, pinnedItems, groupedPinnedItems]);

  if (pinnedItems.length === 0) {
    return (
      <Paper
        elevation={0}
        sx={{ p: 1.5, mt: 1, backgroundColor: (theme) => theme.palette.background.default }}
      >
        <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
          No items pinned. Right-click or long-press items in the World State screen to pin them here.
        </Typography>
      </Paper>
    );
  }

  return (
    <Stack
      direction="row"
      spacing={2}
      sx={{
        py: 1,
        overflowX: 'auto',
        backgroundColor: 'transparent',
      }}
    >
      {Object.entries(groupedPinnedItems).map(([entityPath, attributes]) => (
        <PinnedEntityGroup
          key={entityPath}
          entityPath={entityPath}
          attributes={attributes}
          onUnpinEntity={handleUnpinEntity}
          onUnpinVariable={handleUnpinVariable}
        />
      ))}
    </Stack>
  );
});

@@END_FILE@@

@@FILE: src/ui/components/PromptCard.tsx =====
// src/ui/components/PromptCardCard.tsx
import React from 'react';
import {
  Card, CardContent, CardActions, Typography, IconButton, Tooltip,
} from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import type { PromptCard } from '../../models';

interface PromptCardCardProps {
  card: PromptCard;
  onEdit: () => void;
  onDelete: () => void;
}

export const PromptCardCard: React.FC<PromptCardCardProps> = ({ card, onEdit, onDelete }) => {
  return (
    <Card variant="outlined" sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <CardContent sx={{ flexGrow: 1 }}>
        <Typography variant="h6" gutterBottom>{card.title || 'Untitled Card'}</Typography>
        <Typography variant="body2" color="text.secondary">
          {card.prompt.slice(0, 100)}{card.prompt.length > 100 ? '…' : ''}
        </Typography>
      </CardContent>
      <CardActions>
        <Tooltip title="Edit Card">
          <IconButton onClick={onEdit}><EditIcon /></IconButton>
        </Tooltip>
        <Tooltip title="Delete Card">
          <IconButton onClick={onDelete}><DeleteIcon /></IconButton>
        </Tooltip>
      </CardActions>
    </Card>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PromptCardEditorDialog.tsx =====
// src/ui/components/PromptCardEditorDialog.tsx

import React, { useState, useEffect } from 'react';
import {
  Dialog, DialogTitle, DialogContent, DialogActions,
  Button, Box, TextField
} from '@mui/material';
import type { PromptCard } from '../../models';
import {
  DEFAULT_EMIT_SKELETON_STRING,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  defaultAiSettingsInCard,
  defaultStackInstructions
} from '../../data/config/promptCardDefaults'; // ✅ Use existing constants instead

import { EmitSkeletonSection } from './PromptCardEditorSections/EmitSkeletonSection.tsx';
import { PromptSection } from './PromptCardEditorSections/PromptSection.tsx';
import { WorldStateInitSection } from './PromptCardEditorSections/WorldStateInitSection.tsx';
import { GameRulesSection } from './PromptCardEditorSections/GameRulesSection.tsx';
import { AiSettingsSection } from './PromptCardEditorSections/AiSettingsSection.tsx';

interface PromptCardEditorDialogProps {
  open: boolean;
  initialCard: PromptCard | null;
  onClose: () => void;
  onSave: (card: PromptCard) => void;
}

// ✅ Local helper: mock default PromptCard (not persisted or valid for storage yet)
const createBlankPromptCard = (): PromptCard => ({
  id: 'temporary-id',
  rootId: 'temporary-id',
  parentId: null,
  ownerId: 'preview',
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  title: 'Untitled Card',
  prompt: '',
  description: null,
  firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  stackInstructions: defaultStackInstructions,
  emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
  worldStateInit: '',
  gameRules: '',
  aiSettings: { ...defaultAiSettingsInCard },
  helperAiSettings: { ...defaultAiSettingsInCard },
  isHelperAiEnabled: false,
  tags: [],
  isExample: false,
  functionDefs: '',
  isPublic: false,
  historyBrowsingEnabled: true,
  contentHash: '',
});

export const PromptCardEditorDialog: React.FC<PromptCardEditorDialogProps> = ({
  open,
  initialCard,
  onClose,
  onSave,
}) => {
  const [card, setCard] = useState<PromptCard>(initialCard || createBlankPromptCard());

  useEffect(() => {
    if (initialCard) {
      setCard(initialCard);
    } else {
      setCard(createBlankPromptCard());
    }
  }, [initialCard]);

  const handleChange = <K extends keyof PromptCard>(key: K, value: PromptCard[K]) => {
    setCard(prev => ({ ...prev, [key]: value }));
  };

  const handleSave = () => {
    onSave(card);
  };

  return (
    <Dialog open={open} onClose={onClose} fullScreen scroll="paper">
      <DialogTitle>{initialCard ? 'Edit Prompt Card' : 'New Prompt Card'}</DialogTitle>
      <DialogContent dividers>
        <Box sx={{ mb: 2 }}>
          <TextField
            fullWidth
            label="Card Title"
            value={card.title}
            onChange={(e) => handleChange('title', e.target.value)}
          />
        </Box>

        <PromptSection prompt={card.prompt} onChange={(v) => handleChange('prompt', v)} />

        <EmitSkeletonSection emitSkeleton={card.emitSkeleton} onChange={(v) => handleChange('emitSkeleton', v)} />

        <WorldStateInitSection worldState={card.worldStateInit} onChange={(v) => handleChange('worldStateInit', v)} />

        <GameRulesSection gameRules={card.gameRules} onChange={(v) => handleChange('gameRules', v)} />

        <AiSettingsSection settings={card.aiSettings} onChange={(v) => handleChange('aiSettings', v)} />
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Cancel</Button>
        <Button onClick={handleSave} variant="contained">Save</Button>
      </DialogActions>
    </Dialog>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PromptCardEditorPanel.tsx =====
// src/ui/components/PromptCardEditorPanel.tsx
import React from 'react';
import { Box, Typography, Button, CircularProgress } from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import type { PromptCard, AiConnection } from '../../models';
import PromptCardEditor from '../screens/PromptCardEditor'; // Note: This should eventually move to components

interface PromptCardEditorPanelProps {
  localEditedCard: PromptCard | null;
  isCardDirty: boolean;
  availableConnections: AiConnection[];
  onCardChange: (updatedCard: PromptCard) => void;
  onRevert: () => void;
  onSave: () => void;
  onSaveAs: () => void;
  onStartGame: () => void;
}

export const PromptCardEditorPanel: React.FC<PromptCardEditorPanelProps> = ({
  localEditedCard,
  isCardDirty,
  availableConnections,
  onCardChange,
  onRevert,
  onSave,
  onSaveAs,
  onStartGame,
}) => {
  if (!localEditedCard) {
    return (
      <Box sx={{ textAlign: 'center', p: 4, mt: 4 }}>
        <Typography variant="h6" color="text.secondary">
          Select a card or create a new one to begin editing.
        </Typography>
      </Box>
    );
  }

  return (
    <>
      <Box
        sx={{
          p: 2,
          borderBottom: '1px solid',
          borderColor: 'divider',
          position: 'sticky',
          top: 0,
          backgroundColor: 'background.paper',
          zIndex: 1,
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          flexWrap: 'wrap',
          gap: 1,
        }}
      >
        <Typography variant="h6">{localEditedCard.title}</Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          {isCardDirty && (
            <>
              <Button variant="outlined" onClick={onRevert}>
                Revert
              </Button>
              <Button variant="contained" onClick={onSave}>
                Save Changes
              </Button>
            </>
          )}
          <Button variant="outlined" onClick={onSaveAs}>
            Save As...
          </Button>
          <Button
            variant="contained"
            color="primary"
            onClick={onStartGame}
            startIcon={<PlayArrowIcon />}
            disabled={isCardDirty}
          >
            Start Game
          </Button>
        </Box>
      </Box>
      <PromptCardEditor
        card={localEditedCard}
        onCardChange={onCardChange}
        availableConnections={availableConnections}
      />
    </>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/PromptCardEditorSections/AiSettingsSection.tsx =====
// src/ui/components/PromptCardEditorSections/AiSettingsSection.tsx
import React from 'react';
import { Box, Typography, Slider, TextField } from '@mui/material';
import type { AiSettings } from '../../../models';
import { useSettingsStore } from '../../../state/useSettingsStore';

interface AiSettingsSectionProps {
  settings: AiSettings;
  onChange: (newSettings: AiSettings) => void;
}

export const AiSettingsSection: React.FC<AiSettingsSectionProps> = ({ settings, onChange }) => {
  const update = <K extends keyof AiSettings>(key: K, value: AiSettings[K]) => {
    onChange({ ...settings, [key]: value });
  };

  const availableConnections = useSettingsStore((state) => state.aiConnections);
  const selectedConnection = availableConnections.find(
    (conn) => conn.id === settings.selectedConnectionId
  );

  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>AI Settings</Typography>

      <Box sx={{ mt: 2 }}>
        <Typography gutterBottom>Model Name</Typography>
        <TextField
          fullWidth
          value={selectedConnection?.modelName || "Unknown"}
          disabled // 👈 Make this readonly
        />
      </Box>


      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Temperature: {settings.temperature}</Typography>
        <Slider
          value={settings.temperature}
          min={0}
          max={1.5}
          step={0.05}
          onChange={(_, val) => update('temperature', val as number)}
        />
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Top P: {settings.topP}</Typography>
        <Slider
          value={settings.topP}
          min={0}
          max={1}
          step={0.05}
          onChange={(_, val) => update('topP', val as number)}
        />
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Max Tokens</Typography>
        <TextField
          type="number"
          fullWidth
          value={settings.maxTokens}
          onChange={(e) => update('maxTokens', parseInt(e.target.value) || 0)}
        />
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Presence Penalty: {settings.presencePenalty}</Typography>
        <Slider
          value={settings.presencePenalty}
          min={-2}
          max={2}
          step={0.1}
          onChange={(_, val) => update('presencePenalty', val as number)}
        />
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Frequency Penalty: {settings.frequencyPenalty}</Typography>
        <Slider
          value={settings.frequencyPenalty}
          min={-2}
          max={2}
          step={0.1}
          onChange={(_, val) => update('frequencyPenalty', val as number)}
        />
      </Box>
    </Box>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PromptCardEditorSections/EmitSkeletonSection.tsx =====
// src/ui/components/PromptCardEditorSections/EmitSkeletonSection.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';

interface EmitSkeletonSectionProps {
  emitSkeleton: string;
  onChange: (value: string) => void;
}

export const EmitSkeletonSection: React.FC<EmitSkeletonSectionProps> = ({ emitSkeleton, onChange }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>Emit Skeleton</Typography>
      <TextField
        label="Emit Skeleton JSON"
        multiline
        fullWidth
        minRows={6}
        value={emitSkeleton}
        onChange={(e) => onChange(e.target.value)}
      />
    </Box>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PromptCardEditorSections/GameRulesSection.tsx =====
// src/ui/components/PromptCardEditorSections/GameRulesSection.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';

interface GameRulesSectionProps {
  gameRules: string;
  onChange: (value: string) => void;
}

export const GameRulesSection: React.FC<GameRulesSectionProps> = ({ gameRules, onChange }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>Game Rules</Typography>
      <TextField
        label="Rules Text"
        multiline
        fullWidth
        minRows={6}
        value={gameRules}
        onChange={(e) => onChange(e.target.value)}
      />
    </Box>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PromptCardEditorSections/PromptSection.tsx =====
// src/ui/components/PromptCardEditorSections/PromptSection.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';

interface PromptSectionProps {
  prompt: string;
  onChange: (value: string) => void;
}

export const PromptSection: React.FC<PromptSectionProps> = ({ prompt, onChange }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>Core Prompt</Typography>
      <TextField
        label="Prompt Text"
        multiline
        fullWidth
        minRows={6}
        value={prompt}
        onChange={(e) => onChange(e.target.value)}
      />
    </Box>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PromptCardEditorSections/WorldStateInitSection.tsx =====
// src/ui/components/PromptCardEditorSections/WorldStateInitSection.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';

interface WorldStateInitSectionProps {
  worldState: string;
  onChange: (value: string) => void;
}

export const WorldStateInitSection: React.FC<WorldStateInitSectionProps> = ({ worldState, onChange }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>Initial World State</Typography>
      <TextField
        label="World State JSON"
        multiline
        fullWidth
        minRows={8}
        value={worldState}
        onChange={(e) => onChange(e.target.value)}
      />
    </Box>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PromptCardList.tsx =====
import React from 'react';
import {
  List,
  ListItem,
  ListItemText,
  ListItemButton,
  Typography,
  Divider,
  IconButton,
  Box,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import type { PromptCard } from '../../models';

interface PromptCardListProps {
  cards: PromptCard[];
  activeCardId: string | null;
  onSelectCard: (card: PromptCard) => void;
  onDeleteCard: (cardId: string) => void;
  onDuplicateCard: (cardId: string) => void;
  onExportCard: (cardId: string) => void;
}

export const PromptCardList: React.FC<PromptCardListProps> = ({
  cards,
  activeCardId,
  onSelectCard,
  onDeleteCard,
  onDuplicateCard,
  onExportCard,
}) => {
  return (
    <>
      <Typography variant="h6" sx={{ p: 2, pb: 1 }}>
        Your Cards
      </Typography>
      <Divider />
      <List>
        {cards.length === 0 ? (
          <ListItem>
            <ListItemText
              primary="No cards yet. Create one!"
              sx={{ textAlign: 'center' }}
            />
          </ListItem>
        ) : (
          cards.map((card) => (
            <ListItem
              key={card.id}
              disablePadding
              secondaryAction={
                <Box>
                  <IconButton
                    edge="end"
                    aria-label="duplicate"
                    onClick={() => onDuplicateCard(card.id)}
                  >
                    <ContentCopyIcon />
                  </IconButton>
                  <IconButton
                    edge="end"
                    aria-label="export"
                    onClick={() => onExportCard(card.id)}
                  >
                    <FileDownloadIcon />
                  </IconButton>
                  <IconButton
                    edge="end"
                    aria-label="delete"
                    onClick={() => onDeleteCard(card.id)}
                  >
                    <DeleteIcon />
                  </IconButton>
                </Box>
              }
            >
              <ListItemButton
                selected={activeCardId === card.id}
                onClick={() => onSelectCard(card)}
              >
                <ListItemText primary={card.title || 'Untitled Card'} />
              </ListItemButton>
            </ListItem>
          ))
        )}
      </List>
    </>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/PromptCardListPanel.tsx =====
// src/ui/components/PromptCardListPanel.tsx
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import FileUploadIcon from '@mui/icons-material/FileUpload';
import type { PromptCard } from '../../models';
import { PromptCardList } from './PromptCardList';

interface PromptCardListPanelProps {
  cards: PromptCard[];
  activeCardId: string | null;
  onSelectCard: (card: PromptCard) => void;
  onDeleteCard: (cardId: string) => void;
  onDuplicateCard: (cardId: string) => void;
  onExportCard: (cardId: string) => void;
  onNewCard: () => void;
  onImport: (event: React.ChangeEvent<HTMLInputElement>) => void;
}

export const PromptCardListPanel: React.FC<PromptCardListPanelProps> = ({
  cards,
  activeCardId,
  onSelectCard,
  onDeleteCard,
  onDuplicateCard,
  onExportCard,
  onNewCard,
  onImport,
}) => {
  return (
    <>
      <Box sx={{ p: 2, borderBottom: '1px solid', borderColor: 'divider' }}>
        <Typography variant="h6" component="h2">
          Card Library
        </Typography>
        <Box sx={{ display: 'flex', gap: 1, mt: 2, flexWrap: 'wrap' }}>
          <Button
            variant="contained"
            onClick={onNewCard}
            startIcon={<AddIcon />}
            size="small"
          >
            New Card
          </Button>
          <Button
            variant="outlined"
            component="label"
            startIcon={<FileUploadIcon />}
            size="small"
          >
            Import
            <input type="file" hidden accept=".json" onChange={onImport} multiple />
          </Button>
        </Box>
      </Box>
      <PromptCardList
        cards={cards}
        activeCardId={activeCardId}
        onSelectCard={onSelectCard}
        onDeleteCard={onDeleteCard}
        onDuplicateCard={onDuplicateCard}
        onExportCard={onExportCard}
      />
    </>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/ProtectedRoute.tsx =====
// src/ui/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../../state/useAuthStore';
import { Box, CircularProgress, Typography } from '@mui/material';

interface ProtectedRouteProps {
  children: JSX.Element;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { user, isLoading } = useAuthStore();
  const location = useLocation();

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Verifying Authentication...</Typography>
      </Box>
    );
  }

  if (!user) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to. This allows us to send them along to that page after they login.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default ProtectedRoute;
@@END_FILE@@

@@FILE: src/ui/components/SourceDumpPanel.tsx =====
// src/ui/components/SourceDumpPanel.tsx
import React, { useEffect, useState } from 'react';
import { debugLog, errorLog } from '../../utils/debug';

// --- Type Definitions ---
interface File {
  name: string;
  content: string;
}

// A TreeNode represents a folder. It has a list of its own files (`__files`)
// and its properties are other folders (child TreeNodes).
interface TreeNode {
  __files: File[];
  [key: string]: TreeNode | File[]; // This is the key change to fix the error.
}

// --- Helper Components ---

function CopyButton({ text }: { text: string }) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch (err) {
      errorLog('Copy failed', err);
    }
  };

  return (
    <button
      onClick={handleCopy}
      style={{
        marginLeft: '6px',
        fontSize: '0.8rem',
        cursor: 'pointer',
        background: 'none',
        border: '1px solid #ccc',
        borderRadius: '4px',
        padding: '2px 5px',
      }}
    >
      {copied ? '✅' : '📋'}
    </button>
  );
}

function FolderView({ name, node, level = 0 }: { name: string; node: TreeNode | null; level?: number }) {
  const [open, setOpen] = useState(true);

  if (!node) {
    return null;
  }

  const folderIndent = { paddingLeft: `${level * 1.2}rem` };
  const folderText = node.__files ? node.__files.map(f => f.content).join('\n') : '';

  return (
    <div style={{ ...folderIndent }}>
      <div style={{ cursor: 'pointer', userSelect: 'none', fontWeight: 'bold' }} onClick={() => setOpen(!open)}>
        {open ? '📂' : '📁'} {name}
        {folderText && <CopyButton text={folderText} />}
      </div>
      {open && (
        <>
          {node.__files && node.__files.map((file: File) => (
            <div key={file.name} style={{ paddingLeft: '1.5rem' }}>
              📄 {file.name}
              <CopyButton text={file.content} />
            </div>
          ))}
          {Object.entries(node)
            .filter(([key]) => key !== '__files')
            .map(([childName, childNode]) => (
              // The `childNode` is now correctly typed as `TreeNode`
              <FolderView key={childName} name={childName} node={childNode as TreeNode} level={level + 1} />
            ))}
        </>
      )}
    </div>
  );
}

// --- Main Component ---

export default function SourceDumpPanel() {
  const [dumpText, setDumpText] = useState('');
  const [tree, setTree] = useState<TreeNode | null>(null);

  useEffect(() => {
    debugLog('[SourceDumpPanel] fetching /source-dump.txt');
    let mounted = true;
    (async () => {
      try {
        const res = await fetch(`/source-dump.txt?_=${Date.now()}`, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        if (!mounted) return;
        setDumpText(text);
        setTree(parseDumpToTree(text));
      } catch (e) {
        errorLog('[SourceDump] fetch failed', e);
      }
    })();
    return () => { mounted = false; };
  }, []);

  if (!dumpText) return <div>Loading...</div>;

  return (
    <div style={{ padding: '1rem', fontFamily: 'monospace' }}>
      <h2>
        📋 Copy Entire Repo
        <CopyButton text={dumpText} />
      </h2>
      {tree && <FolderView name="src" node={(tree.src as TreeNode) || tree} />}
      <hr style={{ margin: '2rem 0' }} />
      <h3>Full Dump:</h3>
      <pre style={{ whiteSpace: 'pre-wrap', fontSize: '0.85rem', maxHeight: '400px', overflow: 'auto' }}>{dumpText}</pre>
    </div>
  );
}

// --- Parsing Logic ---

function parseDumpToTree(dump: string): TreeNode {
    const root: any = { __files: [] };
    let currentFile: File | null = null;

    const ensureFolder = (parts: string[]): TreeNode => {
        let node = root;
        for (const part of parts) {
            if (!part) continue;
            if (!node[part]) {
                node[part] = { __files: [] };
            }
            node = node[part];
        }
        return node;
    };

    const lines = dump.split('\n');

    // Detect format quickly (@@ markers)
    const isAtMarkers = dump.includes('@@FILE:') || dump.includes('@@FOLDER:');
    if (isAtMarkers) {
        for (const rawLine of lines) {
            const line = rawLine.trimEnd();
            if (line.startsWith('@@FOLDER:')) {
                const folderPath = line.replace('@@FOLDER:', '').trim();
                const parts = folderPath.split('/').filter(Boolean);
                const start = parts[0] === 'src' ? 1 : 0;
                ensureFolder(parts.slice(start));
            } else if (line.startsWith('@@FILE:')) {
                const filePath = line.replace('@@FILE:', '').trim();
                const parts = filePath.split('/').filter(Boolean);
                const start = parts[0] === 'src' ? 1 : 0;
                const fileParts = parts.slice(start);
                const fileName = fileParts.pop()!;
                const folderNode = ensureFolder(fileParts);
                currentFile = { name: fileName, content: '' };
                folderNode.__files.push(currentFile);
            } else {
                if (currentFile) currentFile.content += rawLine + '\n';
            }
        }
        return root;
    }

    // Fallback to BEGIN/END format
    const BEGIN_SIG = '===== BEGIN FILE: ';
    const END_SIG = '===== END FILE';
    let filePath: string | null = null;

    for (const rawLine of lines) {
        if (filePath === null) {
            if (rawLine.startsWith(BEGIN_SIG)) {
                const p = rawLine.slice(BEGIN_SIG.length).replace(/ =====$/, '').trim();
                const parts = p.split('/').filter(Boolean);
                const start = parts[0] === 'src' ? 1 : 0;
                const fileParts = parts.slice(start);
                const fileName = fileParts.pop()!;
                const folderNode = ensureFolder(fileParts);
                currentFile = { name: fileName, content: '' };
                folderNode.__files.push(currentFile);
                filePath = p;
            }
        } else {
            if (rawLine === END_SIG) {
                // When a file ends, reset its content to ensure the next line doesn't get appended
                if (currentFile) {
                    currentFile.content = currentFile.content.trimEnd();
                }
                filePath = null;
                currentFile = null;
            } else if (currentFile) {
                currentFile.content += rawLine + '\n';
            }
        }
    }
    return root;
}
@@END_FILE@@

@@FILE: src/ui/components/stackInstructions/DigestPolicyEditor.tsx =====
// src/ui/components/stackInstructions/DigestPolicyEditor.tsx
import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  RadioGroup,
  FormControlLabel,
  Radio,
  Grid,
  Switch,
} from '@mui/material';
import type {
  DigestFilterPolicy,
  EmissionRule
} from '../../../models';

import  {
  StackMode,
  FilterMode,
} from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface DigestPolicyEditorProps {
  digestPolicy: DigestFilterPolicy;
  digestEmission: Record<number, EmissionRule>;
  onPolicyChange: (updatedPolicy: DigestFilterPolicy) => void;
  onEmissionChange: (updatedEmission: Record<number, EmissionRule>) => void;
}

export const DigestPolicyEditor: React.FC<DigestPolicyEditorProps> = ({
  digestPolicy,
  digestEmission,
  onPolicyChange,
  onEmissionChange,
}) => {
  const handleEmissionRuleChange = (score: number, field: keyof EmissionRule, value: any) => {
    const currentRule = digestEmission[score] || { mode: StackMode.NEVER, n: 0 };
    onEmissionChange({
      ...digestEmission,
      [score]: { ...currentRule, [field]: value },
    });
  };

  return (
    <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          Digest Lines Emission & Policy
        </Typography>
        <FormControlLabel
          control={
            <Switch
              checked={digestPolicy.enabled ?? false}
              onChange={(e) => onPolicyChange({ ...digestPolicy, enabled: e.target.checked })}
            />
          }
          label="Enable"
          labelPlacement="start"
        />
      </Box>
      <Box sx={{ opacity: digestPolicy.enabled ? 1 : 0.5, pointerEvents: digestPolicy.enabled ? 'auto' : 'none' }}>
        <Typography gutterBottom>
          Global Digest Filtering Policy
          <InfoDialog
            title="Global Digest Filtering Policy"
            content={`Applies a filter to ALL digest lines before their individual emission rules are checked.\n\n- NONE: No global filtering.\n- SCENE_ONLY: Only consider digests relevant to the current scene.\n- TAGGED: Only consider digests that have any tags.`}
          />
        </Typography>
        <FormControl component="fieldset" fullWidth margin="normal">
          <RadioGroup
            row
            value={digestPolicy.filtering}
            onChange={(e) => onPolicyChange({ ...digestPolicy, filtering: e.target.value as FilterMode })}
          >
            {Object.values(FilterMode).map((mode) => (
              <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
            ))}
          </RadioGroup>
        </FormControl>
        <Grid container spacing={2} sx={{ mt: 2 }}>
          {[5, 4, 3, 2, 1].map((score) => (
            // 1. Grid item is now ONLY responsible for layout.
            <Grid item xs={12} sm={6} md={4} key={score}>
              {/* 2. A nested Box handles ALL styling (border, padding). This resolves the error. */}
              <Box sx={{ border: '1px solid', borderColor: 'divider', p: 1.5, borderRadius: 1 }}>
                <Typography variant="subtitle2">
                  Importance {score} Digests
                  <InfoDialog
                    title={`Digest Importance Score ${score} Rule`}
                    content={`Determines how digest lines with an importance score of ${score} are included.`}
                  />
                </Typography>
                <FormControl component="fieldset" fullWidth size="small">
                  <RadioGroup
                    row
                    value={digestEmission[score]?.mode || StackMode.NEVER}
                    onChange={(e) => handleEmissionRuleChange(score, 'mode', e.target.value as StackMode)}
                  >
                    {Object.values(StackMode).filter(m => m !== StackMode.FILTERED).map((mode) => (
                      <FormControlLabel key={mode} value={mode} control={<Radio size="small" />} label={mode} sx={{ mb: -1 }}/>
                    ))}
                  </RadioGroup>
                  {(digestEmission[score]?.mode === StackMode.FIRST_N ||
                    digestEmission[score]?.mode === StackMode.AFTER_N) && (
                      <TextField
                        label="N"
                        type="number"
                        value={digestEmission[score]?.n || 0}
                        onChange={(e) => handleEmissionRuleChange(score, 'n', parseInt(e.target.value))}
                        size="small"
                        sx={{ mt: 1, width: '100px' }}
                        inputProps={{ min: 0 }}
                      />
                    )}
                </FormControl>
              </Box>
            </Grid>
          ))}
        </Grid>        
      </Box>
    </Box>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/stackInstructions/PolicyEditor.tsx =====
// src/ui/components/stackInstructions/PolicyEditor.tsx
import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  RadioGroup,
  FormControlLabel,
  Radio,
  InputLabel,
  Select,
  MenuItem,
  Switch,
} from '@mui/material';
import type { ProsePolicy} from '../../../models';
import {StackMode, FilterMode } from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface PolicyEditorProps {
  title: string;
  policy: ProsePolicy;
  onPolicyChange: (updatedPolicy: ProsePolicy) => void;
  infoContent: {
    main: string;
    mode: string;
    filtering: string;
  };
}

export const PolicyEditor: React.FC<PolicyEditorProps> = ({
  title,
  policy,
  onPolicyChange,
  infoContent,
}) => {
  const handleFieldChange = (field: keyof ProsePolicy, value: any) => {
    onPolicyChange({ ...policy, [field]: value });
  };

  return (
    <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
          <InfoDialog title={title} content={infoContent.main} />
        </Typography>
        <FormControlLabel
          control={
            <Switch
              checked={policy.enabled ?? false}
              onChange={(e) => handleFieldChange('enabled', e.target.checked)}
            />
          }
          label="Enable"
          labelPlacement="start"
        />
      </Box>
      <Box sx={{ opacity: policy.enabled ? 1 : 0.5, pointerEvents: policy.enabled ? 'auto' : 'none' }}>
        <Typography gutterBottom>
          Mode
          <InfoDialog title={`${title} Mode`} content={infoContent.mode} />
        </Typography>
        <FormControl component="fieldset" fullWidth margin="normal">
          <RadioGroup
            row
            value={policy.mode}
            onChange={(e) => handleFieldChange('mode', e.target.value as StackMode)}
          >
            {Object.values(StackMode).filter(m => m !== StackMode.FILTERED).map((mode) => (
              <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
            ))}
          </RadioGroup>
          {(policy.mode === StackMode.FIRST_N || policy.mode === StackMode.AFTER_N) && (
            <TextField
              label="N (Turns)"
              type="number"
              value={policy.n}
              onChange={(e) => handleFieldChange('n', parseInt(e.target.value))}
              sx={{ mt: 1, width: '150px' }}
              inputProps={{ min: 0 }}
            />
          )}
        </FormControl>

        <Typography gutterBottom sx={{ mt: 2 }}>
          Filtering
          <InfoDialog title={`${title} Filtering`} content={infoContent.filtering} />
        </Typography>
        <FormControl fullWidth>
          <InputLabel id={`${title}-filtering-label`}>Filtering</InputLabel>
          <Select
            labelId={`${title}-filtering-label`}
            value={policy.filtering}
            label="Filtering"
            onChange={(e) => handleFieldChange('filtering', e.target.value as FilterMode)}
          >
            {Object.values(FilterMode).map((mode) => (
              <MenuItem key={mode} value={mode}>{mode}</MenuItem>
            ))}
          </Select>
        </FormControl>
      </Box>
    </Box>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/stackInstructions/TokenPolicyEditor.tsx =====
// src/ui/components/stackInstructions/TokenPolicyEditor.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';
import type { TokenPolicy } from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface TokenPolicyEditorProps {
  tokenPolicy: TokenPolicy;
  onPolicyChange: (updatedPolicy: TokenPolicy) => void;
}

export const TokenPolicyEditor: React.FC<TokenPolicyEditorProps> = ({
  tokenPolicy,
  onPolicyChange,
}) => {
  const handleFieldChange = (field: keyof TokenPolicy, value: any) => {
    onPolicyChange({ ...tokenPolicy, [field]: value });
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Token Policy
      </Typography>
      <TextField
        fullWidth
        label="Min Tokens"
        type="number"
        value={tokenPolicy.minTokens}
        onChange={(e) => handleFieldChange('minTokens', parseInt(e.target.value))}
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
        InputProps={{
          endAdornment: <InfoDialog title="Min Tokens" content="The AI will attempt to generate a response of at least this many tokens." />
        }}
      />
      <TextField
        fullWidth
        label="Max Tokens"
        type="number"
        value={tokenPolicy.maxTokens}
        onChange={(e) => handleFieldChange('maxTokens', parseInt(e.target.value))}
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
        InputProps={{
          endAdornment: <InfoDialog title="Max Tokens" content="The absolute maximum number of tokens the AI can generate." />
        }}
      />
      <TextField
        fullWidth
        label="Fallback Plan"
        value={tokenPolicy.fallbackPlan.join(', ')}
        onChange={(e) => handleFieldChange('fallbackPlan', e.target.value.split(',').map((s) => s.trim()))}
        sx={{ mb: 2 }}
        InputProps={{
          endAdornment: <InfoDialog title="Fallback Plan" content={`A prioritized, comma-separated list of strategies the system will use to reduce the *input prompt's* token count if it exceeds the AI model's context window.\n\nCommon Strategies:\ndrop_known_entities, drop_low_importance_digest, truncate_expression_logs, drop_narrator_prose, truncate_conversation_history`} />
        }}
      />
    </Box>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/StackInstructionsEditor.tsx =====
// src/ui/components/StackInstructionsEditor.tsx
import React from 'react';
import { Box, Typography, Divider, Checkbox, FormControlLabel, TextField } from '@mui/material';
import { CollapsibleSection } from './CollapsibleSection';
import { InfoDialog } from './InfoDialog';
import type { StackInstructions, ProsePolicy, DigestFilterPolicy, TokenPolicy, EmissionRule } from '../../models';

// Import the new, smaller components
import { PolicyEditor } from './stackInstructions/PolicyEditor';
import { DigestPolicyEditor } from './stackInstructions/DigestPolicyEditor';
import { TokenPolicyEditor } from './stackInstructions/TokenPolicyEditor';

interface StackInstructionsEditorProps {
  stackInstructions: StackInstructions;
  onStackInstructionsChange: (updatedInstructions: StackInstructions) => void;
}

const StackInstructionsEditor: React.FC<StackInstructionsEditorProps> = ({
  stackInstructions,
  onStackInstructionsChange,
}) => {
  // Generic handler to update a top-level policy object in the main state
  const handlePolicyChange = (
    policyKey: keyof StackInstructions,
    value: ProsePolicy | DigestFilterPolicy | TokenPolicy | Record<number, EmissionRule> | boolean | number
  ) => {
    onStackInstructionsChange({
      ...stackInstructions,
      [policyKey]: value,
    });
  };

  return (
    <CollapsibleSection title="🧠 Stack Instructions" initiallyExpanded={false}>
      <Box sx={{ mb: 3 }}>
        <Typography variant="body2" color="text.secondary">
          These settings control how previous game information (the 'context stack') is assembled
          and presented to the AI for each new turn.
          <InfoDialog
            title="Understanding the Context Stack"
            content={`The AI's 'memory' for each turn is built from a 'context stack'. The order and content of this stack significantly impact AI responses. Each section below can be individually enabled/disabled.`}
          />
        </Typography>
      </Box>

      {/* -- Use the new PolicyEditor for repeating patterns -- */}
      <PolicyEditor
        title="Narrator Prose Emission"
        policy={stackInstructions.narratorProseEmission}
        onPolicyChange={(p) => handlePolicyChange('narratorProseEmission', p)}
        infoContent={{
          main: "Controls how past narrator output (the main story text) is included in the AI's context.",
          mode: "- ALWAYS: Include all past narrator prose.\n- FIRST_N: Include prose only from the first 'N' turns.\n- AFTER_N: Include prose only from turns after 'N'.\n- NEVER: Do not include any past narrator prose.",
          filtering: "- NONE: Include all prose based on the selected mode.\n- SCENE_ONLY: Only include prose relevant to the current scene.\n- TAGGED: Only include prose that contains any recognized tags."
        }}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Use the new DigestPolicyEditor -- */}
      <DigestPolicyEditor
        digestPolicy={stackInstructions.digestPolicy}
        digestEmission={stackInstructions.digestEmission}
        onPolicyChange={(p) => handlePolicyChange('digestPolicy', p)}
        onEmissionChange={(e) => handlePolicyChange('digestEmission', e)}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Expression Log is another ProsePolicy, so reuse PolicyEditor -- */}
      <PolicyEditor
        title="Expression Log Policy"
        policy={stackInstructions.expressionLogPolicy}
        onPolicyChange={(p) => handlePolicyChange('expressionLogPolicy', p)}
        infoContent={{
          main: "Controls how character 'expression' (portions of past narrator prose related to character actions/emotions) is included.",
          mode: "Controls when expression logs are included (Always, First N turns, etc.).",
          filtering: "Filters which expression logs are included based on tags."
        }}
      />
      {/* Specific fields for Expression Log that aren't in the generic policy */}
      <Box sx={{ ml: 2, mt: -2, mb: 2 }}>
        <TextField
          label="Expression Lines Per Character"
          type="number"
          value={stackInstructions.expressionLinesPerCharacter}
          onChange={(e) => handlePolicyChange('expressionLinesPerCharacter', parseInt(e.target.value))}
          sx={{ my: 2, width: '250px' }}
          inputProps={{ min: 0 }}
          InputProps={{
            endAdornment: <InfoDialog title="Expression Lines Per Character" content="The maximum number of lines of narrative prose to extract and summarize for character expressions." />
          }}
        />
        <FormControlLabel
          control={
            <Checkbox
              checked={stackInstructions.emotionWeighting}
              onChange={(e) => handlePolicyChange('emotionWeighting', e.target.checked)}
            />
          }
          label="Emotion Weighting"
        />
      </Box>

      <Divider sx={{ my: 3 }} />

      <PolicyEditor
        title="World State Policy"
        policy={stackInstructions.worldStatePolicy}
        onPolicyChange={(p) => handlePolicyChange('worldStatePolicy', p)}
        infoContent={{
          main: "Controls how the current world state JSON is included in the AI's context.",
          mode: "Controls when the world state is included.",
          filtering: "Filters which parts of the world state are included (e.g., scene-only)."
        }}
      />

      <Divider sx={{ my: 3 }} />

      <PolicyEditor
        title="Known Entities Policy"
        policy={stackInstructions.knownEntitiesPolicy}
        onPolicyChange={(p) => handlePolicyChange('knownEntitiesPolicy', p)}
        infoContent={{
          main: "Controls how a list of 'known entities' (tagged items, characters, locations) is included. This list reminds the AI of important things without sending the full world state.",
          mode: "Controls when the known entities list is included.",
          filtering: "Filters which known entities are listed."
        }}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Use the new TokenPolicyEditor -- */}
      <TokenPolicyEditor
        tokenPolicy={stackInstructions.tokenPolicy}
        onPolicyChange={(p) => handlePolicyChange('tokenPolicy', p)}
      />
    </CollapsibleSection>
  );
};

export { StackInstructionsEditor };
@@END_FILE@@

@@FILE: src/ui/components/TurnNavigator.tsx =====
// src/ui/components/TurnNavigator.tsx
import React from 'react';
import { Box, IconButton, Typography, Tooltip } from '@mui/material';
import ArrowBackIosNewIcon from '@mui/icons-material/ArrowBackIosNew';
import ArrowForwardIosIcon from '@mui/icons-material/ArrowForwardIos';

interface TurnNavigatorProps {
  currentTurn: number;
  maxTurn: number;
  onNavigate: (turn: number) => void;
  isLoading: boolean;
}

export const TurnNavigator: React.FC<TurnNavigatorProps> = ({
  currentTurn,
  maxTurn,
  onNavigate,
  isLoading,
}) => {
  const canGoBack = currentTurn > 0;
  const canGoForward = currentTurn < maxTurn;

  return (
    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', p: 1, gap: 2, backgroundColor: 'action.selected', borderRadius: 2 }}>
      <Tooltip title="Previous Turn">
        <span>
          <IconButton onClick={() => onNavigate(currentTurn - 1)} disabled={!canGoBack || isLoading}>
            <ArrowBackIosNewIcon />
          </IconButton>
        </span>
      </Tooltip>
      <Typography variant="body1" sx={{ fontWeight: 'bold' }}>
        Turn {currentTurn} / {maxTurn}
      </Typography>
      <Tooltip title="Next Turn">
        <span>
          <IconButton onClick={() => onNavigate(currentTurn + 1)} disabled={!canGoForward || isLoading}>
            <ArrowForwardIosIcon />
          </IconButton>
        </span>
      </Tooltip>
    </Box>
  );
};
@@END_FILE@@

@@FILE: src/ui/components/WorldStateCategory.tsx =====
import React from 'react';
import {
  Box,
  Typography,
  IconButton,
  Collapse,
  Checkbox,
  List,
  Divider,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import { WorldStateEntity } from './WorldStateEntity';
import { WorldStateItemRow } from './WorldStateItemRow';

interface WorldStateCategoryProps {
  categoryName: string;
  entities: Record<string, Record<string, any>>;
  isExpanded: boolean;
  areAllChildrenPinned: boolean;
  isAnyChildPinned: boolean;
  expandedEntities: Set<string>;
  worldStatePinnedKeys: string[];
  onToggleExpand: () => void;
  onTogglePin: () => void;
  onStartRename: () => void;
  onDelete: () => void;
  // Entity-level handlers
  onToggleEntityExpand: (entityKey: string) => void;
  onToggleEntityPin: (entityPath: string) => void;
  onStartRenameEntity: (category: string, entity: string) => void;
  onDeleteEntity: (category: string, entity: string) => void;
  // Variable-level handlers
  onDeleteKey: (key: string) => Promise<void>;
  onEditKey: (key: string, value: any) => Promise<void>;
  onToggleVariablePin: (key: string) => void;
}

export const WorldStateCategory: React.FC<WorldStateCategoryProps> = ({
  categoryName,
  entities,
  isExpanded,
  areAllChildrenPinned,
  isAnyChildPinned,
  expandedEntities,
  worldStatePinnedKeys,
  onToggleExpand,
  onTogglePin,
  onStartRename,
  onDelete,
  onToggleEntityExpand,
  onToggleEntityPin,
  onStartRenameEntity,
  onDeleteEntity,
  onDeleteKey,
  onEditKey,
  onToggleVariablePin,
}) => {
  return (
    <Box
      sx={{
        mb: 2,
        border: '1px solid',
        borderColor: 'divider',
        borderRadius: 1,
      }}
    >
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1.5,
          cursor: 'pointer',
          backgroundColor: 'action.hover',
        }}
        onClick={onToggleExpand}
      >
        <IconButton size="small" sx={{ mr: 1 }}>
          {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {categoryName}
        </Typography>
        <IconButton
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            onStartRename();
          }}
        >
          <EditIcon fontSize="small" />
        </IconButton>
        <Checkbox
          checked={areAllChildrenPinned}
          indeterminate={isAnyChildPinned && !areAllChildrenPinned}
          onClick={(e) => {
            e.stopPropagation();
            onTogglePin();
          }}
        />
        <IconButton
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            onDelete();
          }}
        >
          <DeleteIcon fontSize="small" color="error" />
        </IconButton>
      </Box>
      <Collapse in={isExpanded}>
        <Divider />
        <List component="div" disablePadding sx={{ pl: 2, pr: 1, pt: 1 }}>
          {Object.entries(entities).map(([entityKey, variables]) => {
            const entityPath = `${categoryName}.${entityKey}`;

            if (entityKey === '@@_direct') {
              return Object.entries(variables).map(([varName, value]) => (
                <WorldStateItemRow
                  key={`${categoryName}.${varName}`}
                  itemKey={`${categoryName}.${varName}`}
                  value={value}
                  onDelete={onDeleteKey}
                  onEdit={onEditKey}
                  isPinned={worldStatePinnedKeys.includes(`${categoryName}.${varName}`)}
                  onTogglePin={onToggleVariablePin}
                />
              ));
            }

            return (
              <WorldStateEntity
                key={entityPath}
                categoryName={categoryName}
                entityKey={entityKey}
                entityPath={entityPath}
                variables={variables}
                isExpanded={expandedEntities.has(entityPath)}
                worldStatePinnedKeys={worldStatePinnedKeys}
                onToggleExpand={() => onToggleEntityExpand(entityPath)}
                onTogglePin={() => onToggleEntityPin(entityPath)}
                onStartRename={() => onStartRenameEntity(categoryName, entityKey)}
                onDelete={() => onDeleteEntity(categoryName, entityKey)}
                onDeleteKey={onDeleteKey}
                onEditKey={onEditKey}
                onToggleVariablePin={onToggleVariablePin}
              />
            );
          })}
        </List>
      </Collapse>
    </Box>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/WorldStateEntity.tsx =====
import React from 'react';
import {
  Box,
  Typography,
  IconButton,
  Collapse,
  Checkbox,
  Divider,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import { WorldStateItemRow } from './WorldStateItemRow';
import { flattenJsonObject } from '../../utils/jsonUtils';

interface WorldStateEntityProps {
  categoryName: string;
  entityKey: string;
  entityPath: string;
  variables: Record<string, any>;
  isExpanded: boolean;
  worldStatePinnedKeys: string[];
  onToggleExpand: () => void;
  onTogglePin: () => void;
  onStartRename: () => void;
  onDelete: () => void;
  onDeleteKey: (key: string) => Promise<void>;
  onEditKey: (key: string, value: any) => Promise<void>;
  onToggleVariablePin: (key: string) => void;
}

export const WorldStateEntity: React.FC<WorldStateEntityProps> = ({
  entityPath,
  variables,
  isExpanded,
  worldStatePinnedKeys,
  onToggleExpand,
  onTogglePin,
  onStartRename,
  onDelete,
  onDeleteKey,
  onEditKey,
  onToggleVariablePin,
}) => {
  const childVariableKeys = React.useMemo(
    () => Object.keys(flattenJsonObject(variables, entityPath)),
    [variables, entityPath]
  );

  const areAllChildrenPinned =
    childVariableKeys.length > 0 &&
    childVariableKeys.every((key) => worldStatePinnedKeys.includes(key));

  const isAnyChildPinned =
    childVariableKeys.length > 0 &&
    childVariableKeys.some((key) => worldStatePinnedKeys.includes(key));

  const entityDisplayName = entityPath.split('.').pop() || entityPath;

  return (
    <Box
      sx={{
        mb: 1,
        border: '1px dashed',
        borderColor: 'divider',
        borderRadius: 1,
        mt: 1,
      }}
    >
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1,
          cursor: 'pointer',
        }}
        onClick={onToggleExpand}
      >
        <IconButton size="small" sx={{ mr: 1 }}>
          {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
        <Typography variant="subtitle1" sx={{ flexGrow: 1 }}>
          {entityDisplayName}
        </Typography>
        <IconButton
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            onStartRename();
          }}
        >
          <EditIcon fontSize="small" />
        </IconButton>
        <Checkbox
          checked={areAllChildrenPinned}
          indeterminate={isAnyChildPinned && !areAllChildrenPinned}
          onClick={(e) => {
            e.stopPropagation();
            onTogglePin();
          }}
        />
        <IconButton
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            onDelete();
          }}
        >
          <DeleteIcon fontSize="small" color="error" />
        </IconButton>
      </Box>
      <Collapse in={isExpanded}>
        <Divider />
        <Box sx={{ p: 1.5 }}>
          {Object.entries(variables).map(([varName, value]) => (
            <WorldStateItemRow
              key={varName}
              itemKey={`${entityPath}.${varName}`}
              value={value}
              onDelete={onDeleteKey}
              onEdit={onEditKey}
              isPinned={worldStatePinnedKeys.includes(`${entityPath}.${varName}`)}
              onTogglePin={() => onToggleVariablePin(`${entityPath}.${varName}`)}
            />
          ))}
        </Box>
      </Collapse>
    </Box>
  );
};

@@END_FILE@@

@@FILE: src/ui/components/WorldStateItemRow.tsx =====
// src/ui/components/WorldStateItemRow.tsx

import React, { useState } from 'react';
import {
  Box,
  Typography,
  IconButton,
  TextField,
  InputAdornment,
  Checkbox,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import PushPinIcon from '@mui/icons-material/PushPin';
import PushPinOutlinedIcon from '@mui/icons-material/PushPinOutlined';
import { parseJsonPrimitive } from '../../utils/jsonUtils';

interface WorldStateItemRowProps {
  itemKey: string; // Full key, e.g., "npcs.goblin_1.hp"
  value: any; // The raw value, JsonElement equivalent
  onDelete: (key: string) => Promise<void>; // Make it async as store actions might be async
  onEdit: (key: string, value: any) => Promise<void>; // Make it async
  isPinned: boolean;
  onTogglePin: (key: string) => void; // This will call the store's toggleWorldStatePin with 'variable' type
}

export const WorldStateItemRow: React.FC<WorldStateItemRowProps> = ({
  itemKey,
  value,
  onDelete,
  onEdit,
  isPinned,
  onTogglePin,
}) => {
  const [editMode, setEditMode] = useState(false);
  const [editText, setEditText] = useState(JSON.stringify(value)); // Use JSON.stringify for complex values

  // Extract the last part of the key for display name
  const displayName = itemKey.substring(itemKey.lastIndexOf('.') + 1);

  const handleEditConfirm = async () => {
    try {
      const parsedValue = parseJsonPrimitive(editText);
      await onEdit(itemKey, parsedValue); // Await the async edit operation
      setEditMode(false);
    } catch (e) {
      console.error("Failed to parse input for world state edit:", e);
      // TODO: Provide user feedback (e.g., Snackbar) for parsing errors
    }
  };

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        mb: 1,
        p: 1,
        borderRadius: 1,
        backgroundColor: (theme) => (editMode ? theme.palette.action.hover : 'transparent'),
      }}
    >
      <Typography variant="body2" sx={{ fontWeight: 'bold', flexShrink: 0 }}>
        {displayName}:
      </Typography>
      <Box sx={{ flexGrow: 1 }}>
        {editMode ? (
          <TextField
            fullWidth
            size="small"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onBlur={handleEditConfirm}
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleEditConfirm();
              }
            }}
            InputProps={{
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton size="small" onClick={handleEditConfirm}>
                    <EditIcon fontSize="small" />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        ) : (
          <Typography
            variant="body2"
            sx={{
              cursor: 'pointer',
              border: '1px solid',
              borderColor: (theme) => theme.palette.divider,
              borderRadius: 1,
              p: 0.8,
              '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
            }}
            onClick={() => setEditMode(true)}
          >
            {JSON.stringify(value)}
          </Typography>
        )}
      </Box>
      <Checkbox
        icon={<PushPinOutlinedIcon fontSize="small" />}
        checkedIcon={<PushPinIcon fontSize="small" />}
        checked={isPinned}
        onChange={() => onTogglePin(itemKey)} // Pass the full itemKey
        size="small"
        sx={{ p: 0.5 }}
      />
      <IconButton size="small" onClick={() => onDelete(itemKey)} sx={{ p: 0.5 }}>
        <DeleteIcon fontSize="small" color="error" />
      </IconButton>
    </Box>
  );
};
@@END_FILE@@

@@FILE: src/ui/screens/CardLibraryScreen.tsx =====
// src/ui/screens/PromptCardLibraryScreen.tsx
// RENAMED from GameLibraryScreen.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  TextField,
  InputAdornment,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import type { PromptCard } from '../../models';
import Snackbar from '@mui/material/Snackbar';
import { useNavigate } from 'react-router-dom';


interface PromptCardLibraryScreenProps { // RENAMED interface
  onNavToggle: () => void;
  // onNavigateToEditor: (cardId?: string) => void; // To navigate to editor with a specific card
}

const PromptCardLibraryScreen: React.FC<PromptCardLibraryScreenProps> = ({ onNavToggle }) => { // RENAMED component
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const {
    promptCards,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    deletePromptCard,
  } = usePromptCardStore();
  const { initializeGame } = useGameStateStore();

  const [searchTerm, setSearchTerm] = useState('');
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info'>('info');


  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
    }
  }, [user?.uid, fetchPromptCards]);

  const filteredCards = promptCards.filter(card =>
    card.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  const handleEditCard = (card: PromptCard) => {
    setActivePromptCard(card);
    // Navigate to PromptCardManager/Editor screen
    navigate('/cards'); // Navigate to the PromptCardManager
    setSnackbarMessage(`Editing "${card.title}"`);
    setSnackbarSeverity('info');
    console.log(`Navigating to editor for card: ${card.id}`);
  };

  const handleDeleteCard = async (cardId: string) => {
    if (!user?.uid) return;
    try {
      await deletePromptCard(user.uid, cardId);
      setSnackbarMessage('Card deleted successfully!');
      setSnackbarSeverity('success');
    } catch (e) {
      setSnackbarMessage(`Failed to delete card: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };

  const handleStartGame = async (card: PromptCard) => {
    if (!user?.uid) {
      setSnackbarMessage('Must be logged in to start a game.');
      setSnackbarSeverity('error');
      return;
    }
    try {
      // First, set the active card, then initialize game
      setActivePromptCard(card);
      await initializeGame(user.uid, card.id);
      setSnackbarMessage(`Game "${card.title}" initialized! Navigating to game...`);
      setSnackbarSeverity('success');
      navigate('/game'); // Navigate to the GameScreen
      console.log(`Game "${card.title}" started! Navigating to GameScreen.`);
    } catch (e) {
      setSnackbarMessage(`Failed to start game: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };


  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Card Library...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Prompt Card Library
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {error && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {error}
        </Alert>
      )}

      <Box sx={{ p: 2 }}>
        <TextField
          fullWidth
          label="Search Cards"
          variant="outlined"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon />
              </InputAdornment>
            ),
          }}
          sx={{ mb: 2 }}
        />
      </Box>

      <Paper elevation={1} sx={{ flexGrow: 1, m: 2, overflowY: 'auto' }}>
        {filteredCards.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              {searchTerm ? "No cards match your search." : "No cards available. Go to Prompt Cards Manager to create one!"}
            </Typography>
            <Button variant="contained" startIcon={<AddIcon />} sx={{ mt: 2 }} onClick={() => navigate('/cards')}>
              Go to Prompt Card Manager
            </Button>
          </Box>
        ) : (
          <List>
            {filteredCards.map((card) => (
              <React.Fragment key={card.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="start-game" onClick={() => handleStartGame(card)}>
                        <PlayArrowIcon color="primary" />
                      </IconButton>
                      <IconButton edge="end" aria-label="edit-card" onClick={() => handleEditCard(card)}>
                        <EditIcon />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete-card" onClick={() => handleDeleteCard(card.id)}>
                        <DeleteIcon color="error" />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={card.title}
                    secondary={card.description || 'No description'}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>
      <Snackbar
        open={!!snackbarMessage}
        autoHideDuration={6000}
        onClose={() => setSnackbarMessage(null)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={() => setSnackbarMessage(null)} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardLibraryScreen;
@@END_FILE@@

@@FILE: src/ui/screens/GameLibraryScreen.tsx =====
import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  IconButton,
  Snackbar,
} from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import DeleteIcon from '@mui/icons-material/Delete';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { gameRepository } from '../../data/repositories/gameRepository';
import { useNavigate } from 'react-router-dom';
import type { GameSnapshot } from '../../models';
import { formatIsoDateForDisplay } from '../../utils/formatDate';

const GameLibraryScreen: React.FC = () => {
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const { loadGame, gameLoading } = useGameStateStore();

  const [savedGames, setSavedGames] = useState<GameSnapshot[]>([]);
  const [loadingSavedGames, setLoadingSavedGames] = useState(true);
  const [savedGamesError, setSavedGamesError] = useState<string | null>(null);
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info' | 'warning'>('info');
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  const fetchSavedGames = async (userId: string) => {
    setLoadingSavedGames(true);
    setSavedGamesError(null);
    try {
      const games = await gameRepository.getAllGameSnapshots(userId);
      setSavedGames(games);
    } catch (e: any) {
      setSavedGamesError(e.message || 'Failed to fetch saved games.');
    } finally {
      setLoadingSavedGames(false);
    }
  };

  useEffect(() => {
    if (user?.uid) {
      fetchSavedGames(user.uid);
    }
  }, [user?.uid]);

  const showSnackbar = (
    message: string,
    severity: 'success' | 'error' | 'info' | 'warning' = 'info'
  ) => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };

  const handleSnackbarClose = (event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') return;
    setSnackbarOpen(false);
  };

  const handleLoadGame = async (snapshotId: string) => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to load a game.', 'error');
      return;
    }
    try {
      await loadGame(user.uid, snapshotId);
      showSnackbar('Game loaded successfully! Navigating to game...', 'success');
      navigate('/game');
    } catch (e) {
      showSnackbar(
        `Failed to load game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  const handleDeleteGame = async (snapshotId: string) => {
    if (!user?.uid) return;
    try {
      await gameRepository.deleteGameSnapshot(user.uid, snapshotId);
      fetchSavedGames(user.uid);
      showSnackbar('Game deleted successfully!', 'success');
    } catch (e) {
      showSnackbar(
        `Failed to delete game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  if (loadingSavedGames || gameLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>
          Loading Games...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">
          Game Library (Saved Games)
        </Typography>
      </Box>

      {savedGamesError && (
        <Alert
          severity="error"
          sx={{
            m: 2,
            backgroundColor: (theme) => theme.palette.background.paper,
            color: (theme) => theme.palette.text.primary,
          }}
        >
          Error: {savedGamesError}
        </Alert>
      )}

      <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
        <Button
          variant="contained"
          color="primary"
          sx={{ mt: 2 }}
          onClick={() => navigate('/cards')}
        >
          Start New Game (Select Prompt Card)
        </Button>
      </Box>

      <Paper
        elevation={1}
        sx={{
          flexGrow: 1,
          m: 2,
          overflowY: 'auto',
          backgroundColor: (theme) => theme.palette.background.paper,
        }}
      >
        {savedGames.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              No saved games found. Start a new one!
            </Typography>
          </Box>
        ) : (
          <List>
            {savedGames.map((game) => (
              <React.Fragment key={game.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="load-game" onClick={() => handleLoadGame(game.id)}>
                        <PlayArrowIcon sx={{ color: (theme) => theme.palette.primary.main }} />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete-game" onClick={() => handleDeleteGame(game.id)}>
                        <DeleteIcon sx={{ color: (theme) => theme.palette.error.main }} />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={game.title}
                    secondary={`Turn: ${game.currentTurn} | Last Saved: ${formatIsoDateForDisplay(game.updatedAt)}`}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>

      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default GameLibraryScreen;

@@END_FILE@@

@@FILE: src/ui/screens/GameScreen.tsx =====
// src/ui/screens/GameScreen.tsx

import React, { useState, useEffect, useRef, useCallback } from 'react';
import {
  Box, Paper, Typography, TextField, IconButton, Stack, Divider,
  CircularProgress, Button, Fab,
  Dialog, DialogActions, DialogContent, DialogTitle,
  Snackbar, Alert
} from '@mui/material';

import type {AlertColor} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import CasinoIcon from '@mui/icons-material/Casino';
import { TurnNavigator } from '../components/TurnNavigator';
import { useGameStateStore, selectConversationHistory } from '../../state/useGameStateStore';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { PinnedItemsView } from '../components/PinnedItemsView';
import { DiceRoller } from '../../utils/diceRoller';
import { useLongPress } from '../../utils/hooks/useLongPress';

export const GameScreen: React.FC = () => {
  const {
    gameLoading,
    isProcessingTurn,
    processTurn,
    currentSnapshot,    
    maxTurn,            
    navigateToTurn,   
  } = useGameStateStore();

  const conversationHistory = useGameStateStore(selectConversationHistory);
  const activePromptCard = usePromptCardStore((state) => state.activePromptCard);

  const [userInput, setUserInput] = useState('');
  const logEndRef = useRef<HTMLDivElement>(null);

  const [isRollDialogOpen, setIsRollDialogOpen] = useState(false);
  const [rollFormula, setRollFormula] = useState('1d20');
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' as AlertColor });

  const showSnackbar = (message: string, severity: AlertColor = 'info') => {
    setSnackbar({ open: true, message, severity });
  };
  const closeSnackbar = () => setSnackbar(prev => ({ ...prev, open: false }));

  const handleQuickRoll = useCallback(async () => {
    if (isProcessingTurn) return;
    try {
      const result = DiceRoller.roll(rollFormula);
      const summary = DiceRoller.format(result);
      const actionString = `(The player quickly rolls ${rollFormula}. Result: ${summary})`;
      await processTurn(actionString);
      showSnackbar(`Rolled ${rollFormula}: ${summary}`, 'success');
    } catch (e) {
      showSnackbar("Invalid dice formula. Long-press the dice icon to fix it.", 'error');
    }
  }, [rollFormula, isProcessingTurn, processTurn]);

  const handleOpenRollDialog = () => setIsRollDialogOpen(true);
  const handleCloseRollDialog = () => setIsRollDialogOpen(false);
  
  const handleRollFromDialog = useCallback(async () => {
    await handleQuickRoll();
    handleCloseRollDialog();
  }, [handleQuickRoll]);
  
  const longPressProps = useLongPress(
    handleOpenRollDialog,
    handleQuickRoll,
    { delay: 400 }
  );

  useEffect(() => {
    logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [conversationHistory]);

  const handleSubmit = useCallback(async () => {
    if (!userInput.trim() || isProcessingTurn) return;
    await processTurn(userInput);
    setUserInput('');
  }, [userInput, isProcessingTurn, processTurn]);

  const handleKeyPress = useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  }, [handleSubmit]);

  if (gameLoading || !activePromptCard) {
    return (
      <Box sx={{ p: 3, display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Game...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ position: 'relative', display: 'flex', flexDirection: 'column', height: '100%', p: 2 }}>
      <PinnedItemsView />
      <Divider sx={{ my: 1 }} />
      {/* ADD TURN NAVIGATOR HERE */}
      {activePromptCard?.historyBrowsingEnabled && currentSnapshot && maxTurn !== null && (
        <TurnNavigator
          currentTurn={currentSnapshot.currentTurn}
          maxTurn={maxTurn}
          onNavigate={navigateToTurn}
          isLoading={isProcessingTurn || gameLoading}
        />
      )}
      <Box sx={{ flex: 1, overflowY: 'auto', px: 1, pb: 8 }}>
        {conversationHistory.map((msg, index) => (
          <Paper key={index} elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
            <Typography variant="body2" sx={{ fontWeight: 'bold', color: msg.role === 'user' ? 'primary.main' : 'secondary.main' }}>
              {msg.role === 'user' ? 'You' : 'Narrator'}
            </Typography>
            <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
              {msg.content}
            </Typography>
          </Paper>
        ))}
        {isProcessingTurn && (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
            <CircularProgress size={30} />
          </Box>
        )}
        <div ref={logEndRef} />
      </Box>

      <Fab
        color="secondary"
        aria-label="roll dice"
        {...longPressProps}
        sx={{
          position: 'absolute',
          bottom: 120, 
          right: 32,
        }}
      >
        <CasinoIcon />
      </Fab>

      <Dialog open={isRollDialogOpen} onClose={handleCloseRollDialog}>
        <DialogTitle>Set Dice Formula</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Dice Formula"
            type="text"
            fullWidth
            variant="standard"
            value={rollFormula}
            onChange={(e) => setRollFormula(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleRollFromDialog()}
            placeholder="e.g., 2d6+3"
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseRollDialog}>Cancel</Button>
          <Button onClick={handleRollFromDialog} variant="contained">Roll</Button>
        </DialogActions>
      </Dialog>
      
      <Snackbar open={snackbar.open} autoHideDuration={4000} onClose={closeSnackbar}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>

      <Paper elevation={3} sx={{ p: 1, mt: 1 }}>
        <Stack direction="row" spacing={1} alignItems="center">
          <TextField
            fullWidth
            placeholder="What do you do next?"
            multiline
            minRows={1}
            maxRows={5}
            value={userInput}
            onChange={(e) => setUserInput(e.target.value)}
            onKeyPress={handleKeyPress}
            disabled={isProcessingTurn}
          />
          <IconButton onClick={handleSubmit} color="primary" disabled={isProcessingTurn || !userInput.trim()}>
            <SendIcon />
          </IconButton>
        </Stack>
      </Paper>
    </Box>
  );
};
@@END_FILE@@

@@FILE: src/ui/screens/LoginScreen.tsx =====
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom'; // Add this
import { useAuthStore } from '../../state/useAuthStore';

const styles: { [key: string]: React.CSSProperties } = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: '100vh',
    backgroundColor: '#f0f2f5',
    fontFamily: 'Arial, sans-serif',
    padding: '20px',
  },
  button: {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#4285F4',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    marginTop: '20px',
    transition: 'background-color 0.3s ease',
  },
  errorText: {
    color: 'red',
    marginTop: '10px',
  },
};


const LoginScreen: React.FC = () => {
  const { user, isLoading, error, signIn, signOut } = useAuthStore();
  const navigate = useNavigate(); // Add this

  // ✅ Redirect out of login screen if user is authenticated
  useEffect(() => {
    if (user) {
      navigate('/library', { replace: true });
    }
  }, [user, navigate]);

  if (isLoading) {
    return (
      <div style={styles.container}>
        <h2>Loading Authentication Status...</h2>
      </div>
    );
  }

  if (user) {
    return (
      <div style={styles.container}>
        <h2>Welcome, {user.displayName || user.email}!</h2>
        <p>Your User ID: {user.uid}</p>
        <button onClick={signOut} style={styles.button}>
          Sign Out
        </button>
      </div>
    );
  } else {
    return (
      <div style={styles.container}>
        <h2>Please Log In to StoryForge</h2>
        {error && <p style={styles.errorText}>Error: {error}</p>}
        <button onClick={signIn} style={styles.button}>
          Sign in with Google
        </button>
      </div>
    );
  }
};
export default LoginScreen;
@@END_FILE@@

@@FILE: src/ui/screens/LogViewerScreen.tsx =====
// src/ui/screens/LogViewerScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  Box, Typography, Paper, Alert, Fab, Popover,
  List, ListItem, ListItemIcon, ListItemText, Checkbox
} from '@mui/material';
import TuneIcon from '@mui/icons-material/Tune'; // A more fitting icon for "views/filters"
import { useLogStore } from '../../state/useLogStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { LogViewMode } from '../../utils/types';
import { DetailedLogTurnView } from '../components/DetailedLogTurnView';

export const LogViewerScreen: React.FC = () => {
  const { logEntries, selectedLogViewModes, setLogEntries, setSelectedLogViewModes } = useLogStore();
  const currentSnapshot = useGameStateStore(state => state.currentSnapshot);

  // The critical synchronization effect
  useEffect(() => {
    setLogEntries(currentSnapshot?.logs || []);
  }, [currentSnapshot, setLogEntries]);

  // State for the Popover menu
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const isMenuOpen = Boolean(anchorEl);

  const handleMenuClick = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleCheckboxChange = (mode: LogViewMode) => {
    const newSelection = selectedLogViewModes.includes(mode)
      ? selectedLogViewModes.filter((m) => m !== mode)
      : [...selectedLogViewModes, mode];
    setSelectedLogViewModes(newSelection);
  };

  return (
    // Use position relative to anchor the floating button
    <Box sx={{ position: 'relative', height: '100%', p: 2 }}>
      <Typography variant="h5" component="h1" sx={{ mb: 2, textAlign: 'center' }}>
        Game Log
      </Typography>

      <Paper elevation={2} sx={{ height: 'calc(100% - 60px)', overflowY: 'auto' }}>
        {logEntries.length === 0 ? (
          <Box sx={{ p: 4, textAlign: 'center' }}>
            <Typography color="text.secondary">No log entries to display.</Typography>
          </Box>
        ) : (
          logEntries.map((entry) => (
            <Box key={entry.turnNumber} sx={{ p: 1 }}>
              <DetailedLogTurnView
                entry={entry}
                selectedLogViewModes={selectedLogViewModes}
              />
            </Box>
          ))
        )}
      </Paper>

      {/* Floating Action Button (FAB) for the menu */}
      <Fab
        color="primary"
        aria-label="log views"
        onClick={handleMenuClick}
        sx={{ position: 'absolute', bottom: 32, right: 32 }}
      >
        <TuneIcon />
      </Fab>

      {/* Popover Menu - Non-blocking */}
      <Popover
        open={isMenuOpen}
        anchorEl={anchorEl}
        onClose={handleMenuClose}
        anchorOrigin={{ vertical: 'top', horizontal: 'left' }}
        transformOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Paper sx={{ width: 320 }}>
          <List dense>
          {logEntries.map((entry) => (
            <Box key={entry.turnNumber} sx={{ p: 1 }}>
              <DetailedLogTurnView // <-- This is the main component to use
                entry={entry}
                selectedLogViewModes={selectedLogViewModes}
              />
            </Box>
          ))}
          </List>
        </Paper>
      </Popover>
    </Box>
  );
};
@@END_FILE@@

@@FILE: src/ui/screens/PromptCardEditor.tsx =====
// src/ui/screens/PromptCardEditor.tsx
import React from 'react';
import { Box, Divider, FormControlLabel, Switch, TextField } from '@mui/material';
import type { PromptCard, AiConnection } from '../../models';

// Import the more complex, reusable editor components
import { AiSettingsEditor } from '../components/AiSettingsEditor';
import { StackInstructionsEditor } from '../components/StackInstructionsEditor';
import { CollapsibleSection } from '../components/CollapsibleSection';
import { InfoDialog } from '../components/InfoDialog';

// Import constants for placeholders
import {
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../../data/config/promptCardDefaults';

interface PromptCardEditorProps {
  card: PromptCard;
  onCardChange: (updatedCard: PromptCard) => void;
  availableConnections: AiConnection[];
}

const PromptCardEditor: React.FC<PromptCardEditorProps> = ({
  card,
  onCardChange,
  availableConnections,
}) => {
  // A single handler to update the parent component's state
  const handleFieldChange = (updates: Partial<PromptCard>) => {
    onCardChange({ ...card, ...updates });
  };

  return (
    <Box sx={{ p: 2, pb: 4 }}>
      {/* --- Title & Description Section (Merged) --- */}
      <CollapsibleSection title="Title & Description" initiallyExpanded={true}>
        <TextField
          fullWidth
          label="Title"
          value={card.title}
          onChange={(e) => handleFieldChange({ title: e.target.value })}
          sx={{ mb: 2 }}
        />
        <TextField
          fullWidth
          label="Description"
          multiline
          minRows={2}
          value={card.description || ''}
          onChange={(e) => handleFieldChange({ description: e.target.value || null })}
          placeholder="Optional: A short description for this card (not sent to AI)."
        />
      </CollapsibleSection>

      {/* --- Core Prompt Section (Merged) --- */}
      <CollapsibleSection title="AI Prompt" initiallyExpanded={true}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label="Core Scenario / Persona Prompt"
          value={card.prompt}
          onChange={(e) => handleFieldChange({ prompt: e.target.value })}
        />
      </CollapsibleSection>

      {/* --- First Turn Section (Merged) --- */}
      <CollapsibleSection title="First Turn Scene Setup" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={4}
          label="Intro scene shown only on turn 1"
          value={card.firstTurnOnlyBlock}
          onChange={(e) => handleFieldChange({ firstTurnOnlyBlock: e.target.value })}
          placeholder={DEFAULT_FIRST_TURN_PROMPT_BLOCK}
        />
      </CollapsibleSection>

      {/* --- Emit Skeleton Section (Merged) --- */}
      <CollapsibleSection title="Emit & Tagging Skeleton" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={6}
          label="AI Output Structure & Rules"
          value={card.emitSkeleton}
          onChange={(e) => handleFieldChange({ emitSkeleton: e.target.value })}
          placeholder={DEFAULT_EMIT_SKELETON_STRING}
        />
      </CollapsibleSection>

      {/* --- World State Init Section (Merged) --- */}
      <CollapsibleSection title="World State Initialization" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label="Initial World State (JSON)"
          value={card.worldStateInit}
          onChange={(e) => handleFieldChange({ worldStateInit: e.target.value })}
          placeholder="{}"
        />
      </CollapsibleSection>

      {/* --- Game Rules Section (Merged) --- */}
      <CollapsibleSection title="Game Rules Skeleton" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label="Game Rules"
          value={card.gameRules}
          onChange={(e) => handleFieldChange({ gameRules: e.target.value })}
          placeholder="Rules for the AI to follow during gameplay."
        />
      </CollapsibleSection>

      {/* --- AI Settings Section (Uses Reusable Component) --- */}
      <AiSettingsEditor
        label="Primary AI Settings"
        settings={card.aiSettings}
        onSettingsChange={(aiSettings) => handleFieldChange({ aiSettings })}
        availableConnections={availableConnections}
      />

      {/* --- Helper AI Settings Section (Uses Reusable Component) --- */}
      <CollapsibleSection title="Helper AI Settings" initiallyExpanded={false}>
        <FormControlLabel
          control={
            <Switch
              checked={card.isHelperAiEnabled}
              onChange={(e) => handleFieldChange({ isHelperAiEnabled: e.target.checked })}
            />
          }
          label={<>Enable Helper AI <InfoDialog title="Enable Helper AI" content="Toggle to enable a secondary AI call for specific tasks."/></>}
          sx={{ mb: 2 }}
        />
        <Divider sx={{ mb: 2 }} />
        <Box sx={{ opacity: card.isHelperAiEnabled ? 1 : 0.5, pointerEvents: card.isHelperAiEnabled ? 'auto' : 'none' }}>
          <AiSettingsEditor
            label="" // No label for the nested editor
            settings={card.helperAiSettings}
            onSettingsChange={(helperAiSettings) => handleFieldChange({ helperAiSettings })}
            availableConnections={availableConnections}
          />
        </Box>
      </CollapsibleSection>
      
      {/* --- Function Definitions Section (Merged) --- */}
      <CollapsibleSection title="Function Definitions" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={6}
          label="Function Definitions (JSON)"
          value={card.functionDefs}
          onChange={(e) => handleFieldChange({ functionDefs: e.target.value })}
          placeholder="e.g., { 'name': 'action', 'parameters': { ... } }"
        />
      </CollapsibleSection>

      {/* --- Stack Instructions Section (Uses Reusable Component) --- */}
      <StackInstructionsEditor
        stackInstructions={card.stackInstructions}
        onStackInstructionsChange={(stackInstructions) => handleFieldChange({ stackInstructions })}
      />

      {/* --- Metadata Section (Merged) --- */}
       <Box sx={{ mt: 3, display: 'flex', flexDirection: 'column', gap: 1 }}>
        <FormControlLabel
          control={
            <Switch
              checked={card.isPublic}
              onChange={(e) => handleFieldChange({ isPublic: e.target.checked })}
            />
          }
          label="Make Public (visible to others)"
        />
        <FormControlLabel
          control={
            <Switch
              checked={card.isExample}
              onChange={(e) => handleFieldChange({ isExample: e.target.checked })}
            />
          }
          label="Is Example Card (for showcase)"
        />
      </Box>
    </Box>
  );
};

export default PromptCardEditor;
@@END_FILE@@

@@FILE: src/ui/screens/PromptCardManager.tsx =====
// src/ui/screens/PromptCardManager.tsx
import React from 'react';
import {
  Box, Typography, Paper, CircularProgress, Alert, Dialog,
  DialogTitle, DialogContent, DialogActions, Button, TextField, Snackbar,
} from '@mui/material';
import { useAuthStore } from '../../state/useAuthStore';
import { usePromptCardManagerLogic } from '../../utils/hooks/usePromptCardManagerLogic';
import { PromptCardListPanel } from '../components/PromptCardListPanel';
import { PromptCardEditorPanel } from '../components/PromptCardEditorPanel';

const PromptCardManager: React.FC = () => {
  const { user } = useAuthStore();
  const {
    isLoading, error, promptCards, activePromptCard, localEditedCard, isCardDirty,
    aiConnections, saveDialog, snackbar,
    handleCardSelect, handleLocalCardChange, handleSaveCard, handleRevert,
    handleNewCard, handleDeleteCard, handleDuplicateCard, handleImport,
    handleExport, handleStartGame, setSaveDialog, setSaveAsNewTitle, closeSnackbar,
  } = usePromptCardManagerLogic(user);

  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Cards...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%', p: 2 }}>
      <Typography variant="h5" component="h1" sx={{ mb: 2 }}>
        Prompt Cards Manager
      </Typography>

      {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

      <Box sx={{ display: 'flex', flex: 1, overflow: 'hidden', gap: 2 }}>
        <Paper elevation={1} sx={{ flex: 1, minWidth: 300, maxWidth: 450, overflowY: 'auto', display: 'flex', flexDirection: 'column' }}>
          <PromptCardListPanel
            cards={promptCards}
            activeCardId={activePromptCard?.id || null}
            onSelectCard={handleCardSelect}
            onDeleteCard={handleDeleteCard}
            onDuplicateCard={handleDuplicateCard}
            onExportCard={handleExport}
            onNewCard={handleNewCard}
            onImport={handleImport}
          />
        </Paper>

        <Paper elevation={1} sx={{ flex: 2, minWidth: 400, overflowY: 'auto' }}>
          <PromptCardEditorPanel
            localEditedCard={localEditedCard}
            isCardDirty={isCardDirty}
            availableConnections={aiConnections}
            onCardChange={handleLocalCardChange}
            onRevert={handleRevert}
            onSave={() => handleSaveCard(false)}
            onSaveAs={() => setSaveDialog(true)}
            onStartGame={handleStartGame}
          />
        </Paper>
      </Box>

      <Dialog open={saveDialog.open} onClose={() => setSaveDialog(false)}>
        <DialogTitle>Save As New Card</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="New Title"
            type="text"
            fullWidth
            variant="outlined"
            value={saveDialog.title}
            onChange={(e) => setSaveAsNewTitle(e.target.value)}
            placeholder={`${localEditedCard?.title} (Copy)`}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setSaveDialog(false)}>Cancel</Button>
          <Button onClick={() => handleSaveCard(true)}>Save</Button>
        </DialogActions>
      </Dialog>

      <Snackbar open={snackbar.open} autoHideDuration={4000} onClose={closeSnackbar} anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardManager;
@@END_FILE@@

@@FILE: src/ui/screens/SettingsScreen.tsx =====
// src/ui/screens/SettingsScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, Paper, Divider, CircularProgress, Alert, TextField, Switch, FormControlLabel,
  Snackbar, Dialog, DialogTitle, DialogContent, DialogActions, ListItemButton,
  Stack, Select, MenuItem, InputLabel, FormControl, Card, CardActionArea, Grid,
  ListSubheader, InputAdornment, ListItemText, Tooltip, List, ListItem, IconButton
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import SearchIcon from '@mui/icons-material/Search';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
import WifiTetheringIcon from '@mui/icons-material/WifiTethering';
import { useSettingsLogic } from '../../utils/hooks/useSettingsLogic';
import { CollapsibleSection } from '../components/CollapsibleSection';

const SettingsScreen: React.FC = () => {
  const {
    aiConnections, selectedConnectionId, isLoadingConnections, connectionsError,
    useDummyNarrator, themeMode, setUseDummyNarrator, setThemeMode,
    isDialogOpen, dialogStep, editingConnection, isFetchingModels, testStatus, snackbar, templates,
    setModelSearchTerm, filteredModels,
    handleOpenDialog, handleCloseDialog, handleLoadTemplate, handleUpdateEditingConnection, 
    handleFetchModels, handleSaveAndTest, handleDelete, closeSnackbar, setSelectedConnectionId, handleTest,
    modelInfo, openModelInfo, handleOpenModelInfo, handleCloseModelInfo,
  } = useSettingsLogic();

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">Settings</Typography>
      </Box>

      {connectionsError && <Alert severity="error" sx={{ m: 2 }}>Error: {connectionsError}</Alert>}
      
      {isLoadingConnections && aiConnections.length === 0 && <CircularProgress sx={{ m: 2 }} />}

      <Paper sx={{ mt: 2, p: 2 }}>
        <Typography variant="h6" gutterBottom>Global Settings</Typography>
        <FormControlLabel control={<Switch checked={useDummyNarrator} onChange={(e) => setUseDummyNarrator(e.target.checked)} />} label="Use Dummy Narrator (for offline testing)" />
        <Divider sx={{ my: 1 }} />
        <FormControlLabel control={<Switch checked={themeMode === 'dark'} onChange={(e) => setThemeMode(e.target.checked ? 'dark' : 'light')} />} label="Dark Mode" />
      </Paper>
      
      <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>AI Connections</Typography>
      <Paper elevation={1} sx={{ flexGrow: 1, overflowY: 'auto' }}>
        <List>
            {aiConnections.map((conn) => (
              <React.Fragment key={conn.id}>
                <ListItem
                  disablePadding
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="edit" onClick={() => handleOpenDialog(conn)}><EditIcon fontSize="small" /></IconButton>
                      <IconButton edge="end" aria-label="delete" onClick={() => handleDelete(conn.id)}><DeleteIcon fontSize="small" color="error" /></IconButton>
                    </Box>
                  }
                >
                  <ListItemButton selected={selectedConnectionId === conn.id} onClick={() => setSelectedConnectionId(conn.id)}>
                    <ListItemText primary={conn.displayName} secondary={`${conn.modelName} (${conn.apiUrl.substring(0, 30)}...)`} />
                  </ListItemButton>
                </ListItem>
                <Divider />
              </React.Fragment>
            ))}
          </List>
      </Paper>
      <Button variant="contained" startIcon={<AddIcon />} onClick={() => handleOpenDialog()} sx={{ mt: 2 }}>
        Add New Connection
      </Button>

      <Dialog open={isDialogOpen} onClose={handleCloseDialog} fullWidth maxWidth="md" transitionDuration={{ enter: 200, exit: 0 }}>
        <DialogTitle>
          {dialogStep === 'select' ? 'Add a New Connection' : (editingConnection?.displayName || 'Connection Details')}
        </DialogTitle>
        <DialogContent>
          {dialogStep === 'select' && (
            <Stack spacing={2} sx={{ mt: 1 }}>
              <Typography>Start with a template for a popular provider.</Typography>
              <Grid container spacing={2}>
                {Object.entries(templates).filter(([key]) => key !== 'custom').map(([key, template]) => (
                  <Grid item xs={12} sm={6} key={key}>
                    <Card variant="outlined">
                      <CardActionArea onClick={() => handleLoadTemplate(key)} sx={{ p: 2, textAlign: 'center' }}>
                        <Typography variant="h6">{template.displayName}</Typography>
                      </CardActionArea>
                    </Card>
                  </Grid>
                ))}
              </Grid>
              <Divider>OR</Divider>
              <Button variant="outlined" onClick={() => handleLoadTemplate('custom')}>Start with a Blank Custom Connection</Button>
            </Stack>
          )}

          {dialogStep === 'details' && editingConnection && (
            // ... (The rest of the dialog content is correct)
            <Stack spacing={2.5} sx={{ mt: 1 }}>
              <TextField label="Connection Name" value={editingConnection.displayName} onChange={(e) => handleUpdateEditingConnection({ displayName: e.target.value })} autoFocus fullWidth />
              <TextField label="API Token (Key)" value={editingConnection.apiToken} onChange={(e) => handleUpdateEditingConnection({ apiToken: e.target.value })} fullWidth type="password" />

              <FormControl fullWidth>
                <InputLabel id="model-select-label">Model</InputLabel>
                <Select
                  labelId="model-select-label"
                  value={editingConnection.modelSlug}
                  label="Model"
                  onChange={(e) => {
                    const selectedModel = filteredModels.find(m => m.id === e.target.value);
                    handleUpdateEditingConnection({ modelSlug: e.target.value, modelName: selectedModel?.name || e.target.value });
                  }}
                  MenuProps={{ autoFocus: false }}
                >
                  <ListSubheader>
                    <TextField size="small" autoFocus placeholder="Type to filter models..." fullWidth
                      InputProps={{startAdornment: (<InputAdornment position="start"><SearchIcon /></InputAdornment>)}}
                      onChange={(e) => setModelSearchTerm(e.target.value)} onKeyDown={(e) => e.stopPropagation()} />
                  </ListSubheader>
                  {filteredModels.map(model => (
                    <MenuItem key={model.id} value={model.id}>
                      <Tooltip title={model.description || 'No description available.'} placement="right" enterDelay={500}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' }}>
                          <ListItemText primary={model.name} secondary={model.id} />
                          <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleOpenModelInfo(model); }} sx={{ display: { xs: 'flex', md: 'none' } }}>
                            <InfoOutlinedIcon fontSize="small" />
                          </IconButton>
                        </Box>
                      </Tooltip>
                    </MenuItem>
                  ))}
                  {filteredModels.length === 0 && <MenuItem disabled>No models match your search.</MenuItem>}
                </Select>
              </FormControl>
              
              {templates[editingConnection.displayName.toLowerCase()]?.supportsModelDiscovery && (
                <Button onClick={handleFetchModels} disabled={isFetchingModels} variant="outlined">
                  {isFetchingModels ? <CircularProgress size={24} /> : `Fetch All ${editingConnection.displayName} Models`}
                </Button>
              )}
              
              <CollapsibleSection title="Advanced Options" initiallyExpanded={false}>
                 <Stack spacing={2.5} sx={{mt: 2}}>
                    <TextField label="API URL" value={editingConnection.apiUrl} onChange={(e) => handleUpdateEditingConnection({ apiUrl: e.target.value })} fullWidth />
                    <TextField label="User Agent" value={editingConnection.userAgent || ''} onChange={(e) => handleUpdateEditingConnection({ userAgent: e.target.value })} fullWidth />
                    <FormControlLabel control={<Switch checked={editingConnection.functionCallingEnabled} onChange={(e) => handleUpdateEditingConnection({ functionCallingEnabled: e.target.checked })} />}
                        label="Function Calling Enabled" />
                 </Stack>
              </CollapsibleSection>
              
              {testStatus && <Alert severity={testStatus.type} sx={{ mt: 1 }}>{testStatus.text}</Alert>}
            </Stack>
          )}
        </DialogContent>
        <DialogActions sx={{ p: '16px 24px' }}>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          {dialogStep === 'details' && (
            <Stack direction="row" spacing={1}>
              <Button onClick={handleTest} startIcon={<WifiTetheringIcon />}>Test</Button>
              <Button onClick={handleSaveAndTest} variant="contained">Save Connection</Button>
            </Stack>
          )}
        </DialogActions>
      </Dialog>
      
      <Dialog open={openModelInfo} onClose={handleCloseModelInfo}>
        <DialogTitle>{modelInfo?.name}</DialogTitle>
        <DialogContent>
            <Typography variant="body1">{modelInfo?.description || "No description available."}</Typography>
            <Typography variant="caption" color="text.secondary" sx={{mt: 2, display: 'block'}}>ID: {modelInfo?.id}</Typography>
        </DialogContent>
        <DialogActions>
            <Button onClick={handleCloseModelInfo}>Close</Button>
        </DialogActions>
      </Dialog>
      
      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={closeSnackbar}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>{snackbar.message}</Alert>
      </Snackbar>
    </Box>
  );
};

export default SettingsScreen;
@@END_FILE@@

@@FILE: src/ui/screens/SourceDump.tsx =====
import React, { useEffect, useState } from 'react';
import { debugLog, errorLog } from '../../utils/debug';

// Small reusable copy button
function CopyButton({ text }: { text: string }) {
  const [copied, setCopied] = useState(false);
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch (err) {
      errorLog('Copy failed', err);
    }
  };
  return (
    <button
      onClick={handleCopy}
      style={{
        marginLeft: '6px',
        fontSize: '0.8rem',
        cursor: 'pointer',
        background: 'none',
        border: '1px solid #ccc',
        borderRadius: '4px',
        padding: '2px 5px',
      }}
    >
      {copied ? '✅' : '📋'}
    </button>
  );
}

function FolderView({
  name,
  node,
  level = 0,
}: {
  name: string;
  node: any;
  level?: number;
}) {
  const [open, setOpen] = useState(true);

  const isFolder = typeof node === 'object';
  if (!isFolder) return null;

  const folderIndent = { paddingLeft: `${level * 1.2}rem` };

  // Gather folder text for copy
  const folderText = node.__files
    ? node.__files.map((f: any) => f.content).join('\n')
    : '';

  return (
    <div style={{ ...folderIndent }}>
      <div
        style={{
          cursor: 'pointer',
          userSelect: 'none',
          fontWeight: 'bold',
        }}
        onClick={() => setOpen(!open)}
      >
        {open ? '📂' : '📁'} {name}
        {folderText && <CopyButton text={folderText} />}
      </div>

      {open && (
        <>
          {node.__files &&
            node.__files.map((file: any) => (
              <div key={file.name} style={{ paddingLeft: '1.5rem' }}>
                📄 {file.name}
                <CopyButton text={file.content} />
              </div>
            ))}
          {Object.entries(node)
            .filter(([k]) => k !== '__files')
            .map(([childName, childNode]) => (
              <FolderView
                key={childName}
                name={childName}
                node={childNode}
                level={level + 1}
              />
            ))}
        </>
      )}
    </div>
  );
}

export default function SourceDump() {
  const [dumpText, setDumpText] = useState('');
  const [tree, setTree] = useState<any>(null);

  useEffect(() => {
    fetch(`/source-dump.txt?_=${Date.now()}`)
      .then((res) => res.text())
      .then((text) => {
        setDumpText(text);
        setTree(parseDumpToTree(text));
      });
  }, []);

  if (!dumpText) return <div>Loading...</div>;

  return (
    <div style={{ padding: '1rem', fontFamily: 'monospace' }}>
      <h2>
        📋 Copy Entire Repo
        <CopyButton text={dumpText} />
      </h2>

      {tree && <FolderView name="src" node={tree.src || tree} />}

      <hr style={{ margin: '2rem 0' }} />
      <h3>Full Dump:</h3>
      <pre
        style={{
          whiteSpace: 'pre-wrap',
          fontSize: '0.85rem',
          maxHeight: '400px',
          overflow: 'auto',
        }}
      >
        {dumpText}
      </pre>
    </div>
  );
}

function parseDumpToTree(dump: string) {
  const lines = dump.split('\n');
  const root: any = { __files: [] };;
  let currentFolder: string[] = [];
  let currentFile: { name: string; content: string } | null = null;

  const ensureFolder = (pathParts: string[]) => {
    let node = root;
    for (const part of pathParts) {
      if (!node[part]) node[part] = { __files: [] };
      node = node[part];
    }
    return node;
  };

  for (let line of lines) {
    if (line.startsWith('@@FOLDER:')) {
      const folderPath = line.replace('@@FOLDER: ', '').trim();
      currentFolder = folderPath.split('/').slice(1); // remove 'src'
      ensureFolder(currentFolder);
    } else if (line.startsWith('@@FILE:')) {
      const filePath = line.replace('@@FILE: ', '').trim();
      const parts = filePath.split('/');
      const fileName = parts.pop()!;
      currentFolder = parts.slice(1);
      const folderNode = ensureFolder(currentFolder);
      currentFile = { name: fileName, content: '' };
      folderNode.__files.push(currentFile);
    } else {
      if (currentFile) currentFile.content += line + '\n';
    }
  }

  return root;
}

@@END_FILE@@

@@FILE: src/ui/screens/SourceDumpScreen.tsx =====
// src/ui/screens/SourceDumpScreen.tsx
import React from 'react';
import { Box } from '@mui/material';
import { SourceDumpPanel } from '../components/SourceDumpPanel';

const SourceDumpScreen: React.FC = () => {
return (
<Box p={1}>
<SourceDumpPanel />
</Box>
);
};

export default SourceDumpScreen;
@@END_FILE@@

@@FILE: src/ui/screens/WorldStateScreen.tsx =====
// src/ui/screens/WorldStateScreen.tsx
import React, { useState, useMemo, useCallback } from 'react';
import {
  Box, Typography, Button, Paper, 
  Alert, Dialog, DialogTitle, DialogContent,
  DialogActions, TextField,
} from '@mui/material';
import {
  useGameStateStore,
  selectWorldStatePinnedKeys,
  selectCurrentGameState,
} from '../../state/useGameStateStore';
import { flattenJsonObject, getNestedValue } from '../../utils/jsonUtils';
import { WorldStateCategory } from '../components/WorldStateCategory';

const WorldStateScreen: React.FC = () => {
  // --- Start of Co-located Logic (from the old useWorldStateViewLogic hook) ---

  const gameState = useGameStateStore(selectCurrentGameState);
  const worldStatePinnedKeys = useGameStateStore(selectWorldStatePinnedKeys);
  const {
    toggleWorldStatePin, renameWorldCategory, renameWorldEntity,
    deleteWorldCategory, deleteWorldEntity, editWorldKeyValue, deleteWorldKey,
  } = useGameStateStore();

  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());
  const [expandedEntities, setExpandedEntities] = useState<Set<string>>(new Set());
  const [editingCategory, setEditingCategory] = useState<string | null>(null);
  const [newCategoryName, setNewCategoryName] = useState('');
  const [editingEntity, setEditingEntity] = useState<[string, string] | null>(null);
  const [newEntityName, setNewEntityName] = useState('');

  const worldState = gameState?.worldState || {};

  const flattenedWorld = useMemo(() => flattenJsonObject(worldState), [worldState]);

  const groupedByCategory = useMemo(() => {
    const grouped: Record<string, Record<string, Record<string, any>>> = {};
    Object.keys(flattenedWorld).forEach(fullKey => {
      const value = flattenedWorld[fullKey];
      const parts = fullKey.split(".");
      if (parts.length < 1) return;

      const category = parts[0];
      const entity = (parts.length > 1 && /^[#@$]/.test(parts[1])) ? parts[1] : '@@_direct';
      const variable = (entity === '@@_direct') ? parts.slice(1).join('.') : parts.slice(2).join('.');
      if (!variable && entity !== '@@_direct') return; // Skip if entity has no variables

      grouped[category] = grouped[category] || {};
      grouped[category][entity] = grouped[category][entity] || {};
      grouped[category][entity][variable] = value;
    });
    // Clean up empty direct keys
    Object.keys(grouped).forEach(category => {
      if (grouped[category]['@@_direct'] && Object.keys(grouped[category]['@@_direct']).length === 0) {
        delete grouped[category]['@@_direct'];
      }
    });
    return grouped;
  }, [flattenedWorld]);

  const getAllChildVariableKeys = useCallback((basePath: string): string[] => {
    const nestedData = getNestedValue(worldState, basePath.split('.'));
    if (typeof nestedData !== 'object' || nestedData === null) return [];
    return Object.keys(flattenJsonObject(nestedData, basePath));
  }, [worldState]);

  const isAnyChildPinned = useCallback((parentPath: string) => {
    return getAllChildVariableKeys(parentPath).some(key => worldStatePinnedKeys.includes(key));
  }, [getAllChildVariableKeys, worldStatePinnedKeys]);

  const areAllChildrenPinned = useCallback((parentPath: string) => {
    const childKeys = getAllChildVariableKeys(parentPath);
    return childKeys.length > 0 && childKeys.every(key => worldStatePinnedKeys.includes(key));
  }, [getAllChildVariableKeys, worldStatePinnedKeys]);

  const handleToggleCategoryExpand = useCallback((category: string) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev);
      newSet.has(category) ? newSet.delete(category) : newSet.add(category);
      return newSet;
    });
  }, []);

  const handleToggleEntityExpand = useCallback((entityPath: string) => {
    setExpandedEntities(prev => {
      const newSet = new Set(prev);
      newSet.has(entityPath) ? newSet.delete(entityPath) : newSet.add(entityPath);
      return newSet;
    });
  }, []);
  
  const handleToggleCategoryPin = useCallback((category: string) => toggleWorldStatePin(category, 'category'), [toggleWorldStatePin]);
  const handleToggleEntityPin = useCallback((entityPath: string) => toggleWorldStatePin(entityPath, 'entity'), [toggleWorldStatePin]);
  const handleToggleVariablePin = useCallback((key: string) => toggleWorldStatePin(key, 'variable'), [toggleWorldStatePin]);

  const handleStartRenameCategory = useCallback((category: string) => { setEditingCategory(category); setNewCategoryName(category); }, []);
  const handleStartRenameEntity = useCallback((category: string, entity: string) => { setEditingEntity([category, entity]); setNewEntityName(entity); }, []);

  const cancelEdit = useCallback(() => { setEditingCategory(null); setEditingEntity(null); }, []);

  const handleConfirmRenameCategory = useCallback(async () => {
    if (editingCategory && newCategoryName.trim() && newCategoryName !== editingCategory) {
      await renameWorldCategory(editingCategory, newCategoryName.trim());
    }
    cancelEdit();
  }, [editingCategory, newCategoryName, renameWorldCategory, cancelEdit]);

  const handleConfirmRenameEntity = useCallback(async () => {
    if (editingEntity && newEntityName.trim() && newEntityName !== editingEntity[1]) {
      await renameWorldEntity(editingEntity[0], editingEntity[1], newEntityName.trim());
    }
    cancelEdit();
  }, [editingEntity, newEntityName, renameWorldEntity, cancelEdit]);

  // --- End of Co-located Logic ---

  const { gameError } = useGameStateStore();

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">World State</Typography>
      </Box>

      {gameError && (<Alert severity="error" sx={{ m: 2 }}>{gameError}</Alert>)}

      {Object.keys(groupedByCategory).length === 0 ? (
        <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
          <Typography variant="body1" color="text.secondary">No world state data available.</Typography>
        </Box>
      ) : (
        <Paper elevation={1} sx={{ flexGrow: 1, m: 2, p: 2, overflowY: 'auto' }}>
          {Object.entries(groupedByCategory).map(([categoryName, entities]) => (
            <WorldStateCategory
              key={categoryName}
              categoryName={categoryName}
              entities={entities}
              isExpanded={expandedCategories.has(categoryName)}
              areAllChildrenPinned={areAllChildrenPinned(categoryName)}
              isAnyChildPinned={isAnyChildPinned(categoryName)}
              expandedEntities={expandedEntities}
              worldStatePinnedKeys={worldStatePinnedKeys}
              onToggleExpand={() => handleToggleCategoryExpand(categoryName)}
              onTogglePin={() => handleToggleCategoryPin(categoryName)}
              onStartRename={() => handleStartRenameCategory(categoryName)}
              onDelete={() => deleteWorldCategory(categoryName)}
              onToggleEntityExpand={handleToggleEntityExpand}
              onToggleEntityPin={handleToggleEntityPin}
              onStartRenameEntity={handleStartRenameEntity}
              onDeleteEntity={deleteWorldEntity}
              onDeleteKey={deleteWorldKey}
              onEditKey={editWorldKeyValue}
              onToggleVariablePin={handleToggleVariablePin}
            />
          ))}
        </Paper>
      )}

      {/* Dialogs for renaming */}
      <Dialog open={!!editingCategory} onClose={cancelEdit}>
        <DialogTitle>Rename Category</DialogTitle>
        <DialogContent>
          <TextField autoFocus margin="dense" label="New Category Name" fullWidth variant="outlined" value={newCategoryName} onChange={(e) => setNewCategoryName(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && handleConfirmRenameCategory()} />
        </DialogContent>
        <DialogActions>
          <Button onClick={cancelEdit}>Cancel</Button>
          <Button onClick={handleConfirmRenameCategory}>Rename</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={!!editingEntity} onClose={cancelEdit}>
        <DialogTitle>Rename Entity</DialogTitle>
        <DialogContent>
          <TextField autoFocus margin="dense" label="New Entity Name" fullWidth variant="outlined" value={newEntityName} onChange={(e) => setNewEntityName(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && handleConfirmRenameEntity()} />
        </DialogContent>
        <DialogActions>
          <Button onClick={cancelEdit}>Cancel</Button>
          <Button onClick={handleConfirmRenameEntity}>Rename</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default WorldStateScreen;
@@END_FILE@@
