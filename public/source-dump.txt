@@FILE: src/App.css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

@@END_FILE@@
@@FILE: src/App.tsx
// src/App.tsx
import React, { useEffect, useRef } from 'react';
import { BrowserRouter as Router } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import { useSettingsStore } from './state/useSettingsStore';
import { getAppTheme } from './theme';
import MainLayout from './ui/components/MainLayout';
import { AppRoutes } from './AppRoutes';
import { useAuthStore } from './state/useAuthStore';
import { useGameStateStore } from './state/useGameStateStore';
import { usePromptCardStore } from './state/usePromptCardStore';
import { useLogStore } from './state/useLogStore';
import { debugLog } from './utils/debug';

const App: React.FC = () => {
  // DEBUG: Log App component renders
  debugLog('%c[App.tsx] App component rendering', 'color: purple; font-weight: bold;');


  const { themeMode } = useSettingsStore();
  const theme = React.useMemo(() => getAppTheme(themeMode), [themeMode]);

  const { user } = useAuthStore();
  const wasUserLoggedIn = useRef(!!user);

  useEffect(() => {
    // DEBUG: Log App component useEffect execution
    debugLog('[App.tsx] App component useEffect fired. User:', user ? user.uid : 'null');

    const isLoggingOut = wasUserLoggedIn.current && !user;

    if (isLoggingOut) {
      debugLog("[App.tsx] User is logging out. Resetting all data stores.");
      useGameStateStore.getState().reset();
      usePromptCardStore.getState().reset();
      useSettingsStore.getState().reset();
      useLogStore.getState().reset();
    }
    
    // Update the ref for the next render
    wasUserLoggedIn.current = !!user;
  }, [user]);

  return (
    <ThemeProvider theme={theme}>
      <Router>
        <MainLayout>
          <AppRoutes />
        </MainLayout>
      </Router>
    </ThemeProvider>
  );
};

export default App;
@@END_FILE@@
@@FILE: src/AppRoutes.tsx
// src/AppRoutes.tsx
import React, { Suspense, lazy } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import ProtectedRoute from './ui/components/ProtectedRoute';
import AuthOrchestrator from './ui/components/AuthOrchestrator';
import LoginScreen from './ui/screens/LoginScreen';
import GameLibraryScreen from './ui/screens/GameLibraryScreen';
import PromptCardManager from './ui/screens/PromptCardManager';
import { GameScreen } from './ui/screens/GameScreen';
import WorldStateScreen from './ui/screens/WorldStateScreen';
import { LogViewerScreen } from './ui/screens/LogViewerScreen';
import SettingsScreen from './ui/screens/SettingsScreen';
import type { JSX } from 'react';

// Lazy-loaded screens
const SourceDumpScreen = lazy(() => import('./ui/screens/SourceDumpScreen'));

// Used by GameActiveRoute
import { useGameStateStore } from './state/useGameStateStore';

// Guard for routes that need an active game.
const GameActiveRoute: React.FC<{ children: JSX.Element }> = ({ children }) => {
  const { currentSnapshot } = useGameStateStore();
  if (!currentSnapshot) {
    return <Navigate to="/library" replace />;
  }
  return children;
};

export const AppRoutes = () => {
  return (
    <Routes>
      {/* Public Routes */}
      <Route path="/login" element={<LoginScreen />} />
      <Route
        path="/sourcedump"
        element={
          <Suspense fallback={<div style={{ padding: 8 }}>Loading source dump…</div>}>
            <SourceDumpScreen />
          </Suspense>
        }
      />

      {/* Auth-gated layout */}
      <Route
        element={
          <ProtectedRoute>
            <AuthOrchestrator />
          </ProtectedRoute>
        }
      >
        {/* Renders inside AuthOrchestrator's <Outlet /> */}
        <Route path="/library" element={<GameLibraryScreen />} />
        <Route path="/cards" element={<PromptCardManager />} />
        <Route path="/settings" element={<SettingsScreen />} />

        {/* Active-game routes */}
        <Route
          path="/game"
          element={
            <GameActiveRoute>
              <GameScreen />
            </GameActiveRoute>
          }
        />
        <Route
          path="/world-state"
          element={
            <GameActiveRoute>
              <WorldStateScreen />
            </GameActiveRoute>
          }
        />
        <Route
          path="/logs"
          element={
            <GameActiveRoute>
              <LogViewerScreen />
            </GameActiveRoute>
          }
        />

        {/* Default authenticated route */}
        <Route path="/" element={<Navigate to="/library" replace />} />
      </Route>

      {/* Catch-all to login */}
      <Route path="*" element={<Navigate to="/login" replace />} />
    </Routes>
  );
};

@@END_FILE@@
@@FILE: src/assets/react.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
@@END_FILE@@
@@FILE: src/config/navigation.tsx
// src/config/navigation.ts
import LibraryBooksIcon from '@mui/icons-material/LibraryBooks';
import StyleIcon from '@mui/icons-material/Style';
import SettingsIcon from '@mui/icons-material/Settings';
import TravelExploreIcon from '@mui/icons-material/TravelExplore';
import HistoryIcon from '@mui/icons-material/History';
import DataObjectIcon from '@mui/icons-material/DataObject';
import CodeIcon from '@mui/icons-material/Code';
import type {  GameSnapshot } from '../models';
/**
 * Generates the navigation items array.
 * @param currentSnapshot - The current game snapshot, used to determine if game-specific links should be enabled.
 * @returns An array of navigation item objects.
 */
export const getNavItems = (currentSnapshot: GameSnapshot | null) => [
  { text: 'Game Library', icon: <LibraryBooksIcon />, path: '/library', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Prompt Cards', icon: <StyleIcon />, path: '/cards', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Settings', icon: <SettingsIcon />, path: '/settings', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Current Game', icon: <TravelExploreIcon />, path: '/game', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'World State', icon: <DataObjectIcon />, path: '/world-state', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'Log Viewer', icon: <HistoryIcon />, path: '/logs', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'Source Dump', icon: <CodeIcon />, path: '/sourcedump', requiresAuth: false, requiresGame: false, disabled: false },
];
@@END_FILE@@
@@FILE: src/contexts/GameSessionContext.tsx
// src/contexts/GameSessionContext.tsx

import React, { createContext, useContext } from 'react';
import type { IGameSession } from '../logic/gameSession';

// Define the context to hold the IGameSession instance
const GameSessionContext = createContext<IGameSession | undefined>(undefined);

// Provider component to wrap the application and provide the gameSession
export const GameSessionProvider: React.FC<{ children: React.ReactNode; gameSession: IGameSession }> = ({ children, gameSession }) => {
  return (
    <GameSessionContext.Provider value={gameSession}>
      {children}
    </GameSessionContext.Provider>
  );
};

// Custom hook to easily consume the gameSession from the context by React components
export const useGameSession = () => {
  const context = useContext(GameSessionContext);
  if (context === undefined) {
    throw new Error('useGameSession must be used within a GameSessionProvider');
  }
  return context;
};
@@END_FILE@@
@@FILE: src/contexts/LayoutContext.tsx
// src/contexts/LayoutContext.tsx
import React, { createContext, useContext, useState } from 'react';

interface LayoutContextType {
  toggleDrawer: () => void;
}

const LayoutContext = createContext<LayoutContextType | undefined>(undefined);

export const useLayout = () => {
  const context = useContext(LayoutContext);
  if (!context) {
    throw new Error('useLayout must be used within a LayoutProvider');
  }
  return context;
};

export const LayoutProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mobileOpen, setMobileOpen] = useState(false);
  const toggleDrawer = () => setMobileOpen(!mobileOpen);

  const value = { toggleDrawer, mobileOpen }; // Provide mobileOpen as well if needed by MainLayout

  // The actual provider component will be part of MainLayout to have access to state
  // This file just defines the context and hook. The implementation will be in MainLayout.
  // This is a common pattern to avoid circular dependencies.
  // For this refactor, we will define the Provider logic directly within MainLayout.
  return (
    <LayoutContext.Provider value={{ toggleDrawer }}>
      {children}
    </LayoutContext.Provider>
  );
};
@@END_FILE@@
@@FILE: src/data/config/aiConnectionTemplates.ts
// src/data/config/aiConnectionTemplates.ts
import type { AiConnection } from '../../models';
export interface ModelInfo {
  id: string; // The API identifier, e.g., "gpt-4-turbo"
  name: string; // The human-readable name, e.g., "GPT-4 Turbo"
  description?: string; // NEW: A description for the tooltip/dialog
}

export interface AiConnectionTemplate extends Omit<AiConnection, 'id' | 'createdAt' | 'lastUpdated'> {
  supportsModelDiscovery: boolean;
  commonModels: ModelInfo[];
}

// Using a Record for easier lookup by key
export const aiConnectionTemplates: Record<string, AiConnectionTemplate> = {
  openai: {
    displayName: 'OpenAI',
    modelName: 'GPT-4o',
    modelSlug: 'gpt-4o',
    apiUrl: 'https://api.openai.com/v1/',
    apiToken: 'PASTE_YOUR_OPENAI_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
      { id: 'gpt-4o', name: 'GPT-4o', description: 'The latest and most advanced model from OpenAI. Excellent reasoning, multimodal capabilities.' },
      { id: 'gpt-4-turbo', name: 'GPT-4 Turbo', description: 'A powerful and fast version of GPT-4, optimized for performance.' },
      { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo', description: 'A highly capable and cost-effective model, great for general purpose tasks.' },
    ],
  },
  google: {
    displayName: 'Google',
    modelName: 'Gemini 1.5 Flash',
    modelSlug: 'gemini-1.5-flash-latest',
    apiUrl: 'https://generativelanguage.googleapis.com/v1beta/',
    apiToken: 'PASTE_YOUR_GOOGLE_AI_STUDIO_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: false, // Google's API needs a different endpoint for model listing
    commonModels: [
      { id: 'gemini-1.5-pro-latest', name: 'Gemini 1.5 Pro', description: 'Google\'s top-tier multimodal model with a massive context window.' },
      { id: 'gemini-1.5-flash-latest', name: 'Gemini 1.5 Flash', description: 'A lightweight, fast, and cost-efficient version of Gemini 1.5.' },
      { id: 'gemini-1.0-pro', name: 'Gemini 1.0 Pro', description: 'The original balanced model for scaled tasks.' },
    ],
  },
  deepseek: {
    displayName: 'DeepSeek',
    modelName: 'DeepSeek Coder V2',
    modelSlug: 'deepseek-coder-v2',
    apiUrl: 'https://api.deepseek.com/v1/',
    apiToken: 'PASTE_YOUR_DEEPSEEK_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
        { id: 'deepseek-chat', name: 'DeepSeek Chat', description: 'Specialized in general conversation and creative text generation.' },
        { id: 'deepseek-coder', name: 'DeepSeek Coder', description: 'Specialized in code generation and explanation. A very capable model.' },
    ],
  },
  openrouter: {
    displayName: 'OpenRouter',
    modelName: 'OpenRouter (Auto)',
    modelSlug: 'openrouter/auto',
    apiUrl: 'https://openrouter.ai/api/v1/',
    apiToken: 'PASTE_YOUR_OPENROUTER_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
        { id: 'openrouter/auto', name: 'Auto (Best)', description: 'OpenRouter automatically selects the best model for your prompt based on price and performance.' },
        { id: 'google/gemini-flash-1.5', name: 'Google: Gemini Flash 1.5', description: 'Fast and affordable model, good for quick tasks.' },
        { id: 'openai/gpt-4o', name: 'OpenAI: GPT-4o', description: 'Access GPT-4o through OpenRouter\'s API.' },
        { id: 'mistralai/mistral-large', name: 'Mistral Large', description: 'High-quality model from Mistral AI, strong reasoning.' },
    ],
  },
  custom: {
    displayName: 'Custom',
    modelName: 'Custom Model',
    modelSlug: '',
    apiUrl: '',
    apiToken: '',
    functionCallingEnabled: false,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: false,
    commonModels: [],
  },
};
@@END_FILE@@
@@FILE: src/data/config/promptCardDefaults.ts
// src/data/config/promptCardDefaults.ts

// In src/data/config/promptCardDefaults.ts
import type { AiSettings, StackInstructions} from '../../models';
import  { StackMode, FilterMode} from '../../models';
import { debugLog, errorLog } from '../../utils/debug';

/**
 * Default AI settings to be used for PromptCards if not specified.
 * Corresponds to AiSettings.kt's default values, now embedded in PromptCard.
 */
export const defaultAiSettingsInCard: AiSettings = {
  selectedConnectionId: "",
  temperature: 0.7,
  topP: 1.0,
  maxTokens: 2048,
  presencePenalty: 0.0,
  frequencyPenalty: 0.0,
  functionCallingEnabled: false,
  streaming: true, 
};

/**
 * Default structured StackInstructions object.
 * This is the parsed object version of the default JSON string from PromptCardDefaults.kt.
 */
export const defaultStackInstructions: StackInstructions = {
  narratorProseEmission: { mode: StackMode.FIRST_N, n: 3, filtering: FilterMode.SCENE_ONLY, enabled: true },
  digestPolicy: { filtering: FilterMode.TAGGED, enabled: true },
  digestEmission: {
    "5": { mode: StackMode.ALWAYS, n: 0 }, // MODIFIED: Added n: 0
    "4": { mode: StackMode.AFTER_N, n: 1 },
    "3": { mode: StackMode.FIRST_N, n: 6 },
    "2": { mode: StackMode.FIRST_N, n: 3 },
    "1": { mode: StackMode.NEVER, n: 0 }, // MODIFIED: Added n: 0
  },
  expressionLogPolicy: { mode: StackMode.ALWAYS, n: 0, filtering: FilterMode.SCENE_ONLY, enabled: true },
  expressionLinesPerCharacter: 3,
  emotionWeighting: true,
  worldStatePolicy: { mode: StackMode.FILTERED, n: 0, filtering: FilterMode.SCENE_ONLY, enabled: true },
  knownEntitiesPolicy: { mode: StackMode.FIRST_N, n: 2, filtering: FilterMode.TAGGED, enabled: true },
  // REMOVED: "outputFormat": "prose_digest_emit",
  tokenPolicy: {
    minTokens: 1000,
    maxTokens: 4096,
    fallbackPlan: [
      "drop_known_entities",
      "drop_low_importance_digest",
      "truncate_expression_logs",
    ],
  },
};

/**
 * Default content for the 'firstTurnOnlyBlock' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_FIRST_TURN_PROMPT_BLOCK: string = `The camera pans down. It's your first time in this place.
Describe the scene and how the world feels from the character's perspective.`;

/**
 * Default content for the 'emitSkeleton' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_EMIT_SKELETON_STRING: string = `
### Narrator Output Structure

**IMPORTANT:** Your response MUST follow this exact structure. Each section MUST be separated by the specified markers on their own lines.

1.  **Narrative Prose:**
    *   Begin with clear, immersive narration in freeform prose.
    *   This is the only section that should contain descriptive text. It MUST NOT contain any markers or JSON blocks.

2.  **Summary Digest Block (\`@digest\`):**
    *   After the prose, you MUST include a single newline, followed by the marker \`@digest\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing an array of 1-5 summary lines.
    *   Each line MUST have an importance score from 1 (minor) to 5 (critical).

3.  **Emit Block (\`@delta\`):**
    *   After the digest block, include a single newline, followed by the marker \`@delta\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing key-value deltas for the world state.

4.  **Scene Change Block (\`@scene\`, Optional):
    *   If the scene has shifted, include a single newline, followed by the marker \`@scene\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block with the new scene object.

---

### **MANDATORY OUTPUT FORMAT EXAMPLE**

This is not optional. Your output must match this structure precisely.

The mist curls like spectral fingers around the ancient oaks. #Lyrielle stands rigid, her silver-threaded cloak shimmering faintly in the moonlight. You feel a sudden chill as #Brom shifts his weight, his leather armor creaking.

@digest
\`\`\`json
[
  { "text": "#Lyrielle appears tense and wary.", "importance": 3 },
  { "text": "The mist in @MoonlitVale thickens, obscuring the path.", "importance": 2 }
]
\`\`\`

@delta
\`\`\`json
{
  "=npcs.#lyrielle.status": "wary",
  "+world.environment.fog_density": 0.1
}
\`\`\`

@scene
\`\`\`json
{
  "location": "@MoonlitVale",
  "present": ["#you", "#lyrielle", "#brom"],
  "weather": "foggy"
}
\`\`\`
---

### Emit & Tagging Rules

*   **Emit Rules:** Paths are \`category.entity.field\`. Use symbolic ops: \`+\`, \`=\`, \`!\`, \`-\`. Paths must be valid.
*   **Tagging Rules:** Use \`#\` for characters, \`@\` for locations, \`$\` for items. Use tags consistently in narration and emits.

`.trim();


@@END_FILE@@
@@FILE: src/data/infrastructure/firebaseClient.ts
// src/data/infrastructure/firebaseClient.ts

import { initializeApp, getApps, getApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore'; // Removed initializeFirestore and PersistentLocalCache

// Your Firebase configuration
function getEnvVar(name: string): string {
  const value = import.meta.env[name] as string | undefined;
  if (!value) {
    throw new Error(`Missing required environment variable: ${name}`);
  }
  return value;
}

const firebaseConfig = {
  apiKey: getEnvVar('VITE_FIREBASE_API_KEY'),
  authDomain: getEnvVar('VITE_FIREBASE_AUTH_DOMAIN'),
  projectId: getEnvVar('VITE_FIREBASE_PROJECT_ID'),
  storageBucket: getEnvVar('VITE_FIREBASE_STORAGE_BUCKET'),
  messagingSenderId: getEnvVar('VITE_FIREBASE_MESSAGING_SENDER_ID'),
  appId: getEnvVar('VITE_FIREBASE_APP_ID'),
};

// Initialize Firebase App
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

// Get Firebase services (without offline persistence for MVP)
export const auth = getAuth(app);
export const db = getFirestore(app);
@@END_FILE@@
@@FILE: src/data/repositories/aiConnectionRepository.ts
// src/data/repositories/aiConnectionRepository.ts

import {
    collection, doc, setDoc, deleteDoc, query, getDocs,
    serverTimestamp, orderBy, Timestamp
  } from 'firebase/firestore';
  import { db } from '../infrastructure/firebaseClient';
  import { generateUuid } from '../../utils/uuid';
  import type { AiConnection } from '../../models';
  
  // Helper to convert Firestore Timestamp to ISO string
  const convertTimestamps = <T extends { createdAt?: any; lastUpdated?: any }>(data: any): T => {
    const convertedData: any = { ...data };
    if (data.createdAt && data.createdAt instanceof Timestamp) {
      convertedData.createdAt = data.createdAt.toDate().toISOString();
    }
    if (data.lastUpdated && data.lastUpdated instanceof Timestamp) {
      convertedData.lastUpdated = data.lastUpdated.toDate().toISOString();
    }
    return convertedData as T;
  };
  
  export interface IAiConnectionRepository {
    getAiConnections(userId: string): Promise<AiConnection[]>;
    saveAiConnection(userId: string, connection: AiConnection): Promise<void>;
    deleteAiConnection(userId: string, connectionId: string): Promise<void>;
  }
  
  class FirestoreAiConnectionRepository implements IAiConnectionRepository {
    private getAiConnectionsCollectionRef(userId: string) {
      return collection(db, 'users', userId, 'aiConnections');
    }
  
    async getAiConnections(userId: string): Promise<AiConnection[]> {
      const q = query(
        this.getAiConnectionsCollectionRef(userId),
        orderBy('displayName', 'asc')
      );
      const querySnapshot = await getDocs(q);
      const connections: AiConnection[] = [];
      querySnapshot.forEach((docSnap) => {
        connections.push(convertTimestamps<AiConnection>(docSnap.data()));
      });
      return connections;
    }
  
    async saveAiConnection(userId: string, connection: AiConnection): Promise<void> {
      const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connection.id);
      await setDoc(connectionDocRef, {
        ...connection,
        createdAt: connection.createdAt || serverTimestamp(),
        lastUpdated: serverTimestamp(),
      }, { merge: true });
      console.log(`AI Connection ${connection.id} saved for user ${userId}`);
    }
  
    async deleteAiConnection(userId: string, connectionId: string): Promise<void> {
      const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connectionId);
      await deleteDoc(connectionDocRef);
      console.log(`AI Connection ${connectionId} deleted for user ${userId}`);
    }
  }
  
  export const aiConnectionRepository = new FirestoreAiConnectionRepository();
@@END_FILE@@
@@FILE: src/data/repositories/authRepository.ts
// src/data/authRepository.ts

import {
  GoogleAuthProvider,
  signInWithPopup,
  signOut,
  onAuthStateChanged,
  type User,
} from 'firebase/auth';
import { auth } from '../infrastructure/firebaseClient'; // Import the auth instance from our firebaseClient

/**
 * Handles user login using Google as the authentication provider.
 * @returns A Promise that resolves with the Firebase User credential if successful, or rejects with an error.
 */
export async function signInWithGoogle(): Promise<User | null> {
  const provider = new GoogleAuthProvider();
  try {
    const result = await signInWithPopup(auth, provider);
    // The signed-in user info.
    const user = result.user;
    console.log("User logged in:", user.uid);
    return user;
  } catch (error: any) {
    // Handle Errors here.
    const errorCode = error.code;
    const errorMessage = error.message;
    // The email of the user's account used.
    const email = error.customData?.email;
    // The AuthCredential type that was used.
    const credential = GoogleAuthProvider.credentialFromError(error);
    console.error("Error signing in with Google:", errorCode, errorMessage, email, credential);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Handles user logout.
 * @returns A Promise that resolves when the user is successfully signed out.
 */
export async function signOutUser(): Promise<void> {
  try {
    await signOut(auth);
    console.log("User signed out.");
  } catch (error) {
    console.error("Error signing out:", error);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Subscribes to authentication state changes.
 * This is crucial for keeping the UI updated about the current user's login status.
 * @param callback A function to call when the auth state changes, receiving the current Firebase User or null.
 * @returns An unsubscribe function that can be called to stop listening for changes.
 */
export function subscribeToAuthChanges(callback: (user: User | null) => void): () => void {
  // onAuthStateChanged returns an unsubscribe function
  const unsubscribe = onAuthStateChanged(auth, (user) => {
    callback(user);
  });
  console.log("Auth state change listener attached.");
  return unsubscribe;
}

// Optional: You could also add a way to get the current user synchronously if needed,
// though `subscribeToAuthChanges` is generally preferred for reactivity.
export function getCurrentUser(): User | null {
  return auth.currentUser;
}
@@END_FILE@@
@@FILE: src/data/repositories/gameRepository.ts
// src/data/repositories/gameRepository.ts

import {
  collection, doc, getDoc, setDoc, deleteDoc, query, getDocs,
  serverTimestamp, orderBy, Timestamp, where, writeBatch
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient';
import type { GameSnapshot } from '../../models';

/**
 * Defines the contract for GameSnapshot data persistence operations.
 */
export interface IGameRepository {
  saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void>;
  getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null>;
  getAllGameSnapshots(userId: string): Promise<GameSnapshot[]>;
  deleteGameSnapshot(userId: string, snapshotId: string): Promise<void>;
  getGameTimeline(userId: string, gameId: string): Promise<GameSnapshot[]>;
  deleteFutureTurns(userId: string, gameId: string, fromTurn: number): Promise<void>;
}

/**
 * Concrete implementation of IGameRepository using Firestore.
 */
class FirestoreGameRepository implements IGameRepository {
  private getSnapshotsCollectionRef(userId: string) {
    return collection(db, 'users', userId, 'gameSnapshots');
  }

  // Helper to convert Firestore Timestamp to ISO string
  private convertTimestamps<T extends { createdAt?: any; updatedAt?: any }>(data: any): T {
    const convertedData: any = { ...data };
    if (data.createdAt && data.createdAt instanceof Timestamp) {
      convertedData.createdAt = data.createdAt.toDate().toISOString();
    }
    if (data.updatedAt && data.updatedAt instanceof Timestamp) {
      convertedData.updatedAt = data.updatedAt.toDate().toISOString();
    }
    return convertedData as T;
  }

  async saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshot.id);
    try {
      await setDoc(snapshotDocRef, {
        ...snapshot,
        updatedAt: serverTimestamp()
      }, { merge: true });
    } catch (e) {
      console.error(`FirestoreGameRepository: FAILED to setDoc for GameSnapshot ${snapshot.id}:`, e);
      throw e;
    }
  }

  async getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    const snapshotSnap = await getDoc(snapshotDocRef);
    if (snapshotSnap.exists()) {
      return this.convertTimestamps<GameSnapshot>(snapshotSnap.data()) as GameSnapshot;
    } else {
      return null;
    }
  }

  async getAllGameSnapshots(userId: string): Promise<GameSnapshot[]> {
    const q = query(this.getSnapshotsCollectionRef(userId), orderBy('updatedAt', 'desc'));
    const querySnapshot = await getDocs(q);
    const snapshots: GameSnapshot[] = [];
    querySnapshot.forEach((doc) => {
      snapshots.push(this.convertTimestamps<GameSnapshot>(doc.data()) as GameSnapshot);
    });
    return snapshots;
  }

  async deleteGameSnapshot(userId: string, snapshotId: string): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    await deleteDoc(snapshotDocRef);
  }

  async getGameTimeline(userId: string, gameId: string): Promise<GameSnapshot[]> {
    const q = query(
      this.getSnapshotsCollectionRef(userId),
      where('gameId', '==', gameId),
      orderBy('currentTurn', 'asc')
    );
    const querySnapshot = await getDocs(q);
    const timeline: GameSnapshot[] = [];
    querySnapshot.forEach((doc) => {
      timeline.push(this.convertTimestamps<GameSnapshot>(doc.data()) as GameSnapshot);
    });
    return timeline;
  }

  async deleteFutureTurns(userId: string, gameId: string, fromTurn: number): Promise<void> {
    const q = query(
      this.getSnapshotsCollectionRef(userId),
      where('gameId', '==', gameId),
      where('currentTurn', '>', fromTurn)
    );
    const querySnapshot = await getDocs(q);
    if (querySnapshot.empty) return;
    const batch = writeBatch(db);
    querySnapshot.forEach(doc => batch.delete(doc.ref));
    await batch.commit();
  }
}

export const gameRepository = new FirestoreGameRepository();
@@END_FILE@@
@@FILE: src/data/repositories/promptCardRepository.ts
// src/data/repositories/promptCardRepository.ts

import {
  collection,
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  query,
  getDocs,
  serverTimestamp,
  orderBy
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient'; // Import our Firestore instance
import type { PromptCard } from '../../models';
import { toIsoStringIfTimestamp } from '../../utils/formatDate';

/**
 * Defines the contract for PromptCard data persistence operations.
 * This interface can be implemented by different concrete repositories
 * (e.g., FirestorePromptCardRepository, MockPromptCardRepository)
 * to allow for easy swapping of data sources.
 */
export interface IPromptCardRepository {
  /**
   * Saves a new or updates an existing PromptCard.
   * If the card already has an ID, it will update the existing document.
   * If not, it assumes the card object passed already has an ID generated (e.g., by cardManager).
   * @param userId The ID of the user owning the card.
   * @param card The PromptCard object to save.
   * @returns A Promise that resolves when the card is successfully saved.
   */
  savePromptCard(userId: string, card: PromptCard): Promise<void>;

  /**
   * Retrieves a single PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to retrieve.
   * @returns A Promise that resolves with the PromptCard object or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a specific user, ordered by updatedAt descending.
   * @param userId The ID of the user owning the cards.
   * @returns A Promise that resolves with an array of PromptCard objects.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Deletes a PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to delete.
   * @returns A Promise that resolves when the card is successfully deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Imports a collection of PromptCards. This method will likely involve
   * generating new IDs/hashes and setting ownerId upon import.
   * The actual logic for generating IDs/hashes and setting ownerId should be in cardManager.ts,
   * this repository method merely handles the bulk persistence.
   * @param userId The ID of the user importing the cards.
   * @param cards The array of PromptCard objects to import.
   * @returns A Promise that resolves when all cards are imported.
   */
  importPromptCards(userId: string, cards: PromptCard[]): Promise<void>;
}

/**
 * Concrete implementation of IPromptCardRepository using Firestore.
 */
export class FirestorePromptCardRepository implements IPromptCardRepository {

  private getCollectionRef(userId: string) {
    // Path: users/{userId}/promptCards
    return collection(db, 'users', userId, 'promptCards');
  }

  async savePromptCard(userId: string, card: PromptCard): Promise<void> {
    if (!card.id) {
      // This case should ideally be prevented by logic in cardManager or wherever cards are created
      // as PromptCard should always have an ID before reaching the repository.
      throw new Error("PromptCard must have an ID to be saved.");
    }
    const cardDocRef = doc(this.getCollectionRef(userId), card.id);
    await setDoc(cardDocRef, {
      ...card,
      updatedAt: serverTimestamp() // Firestore special value for server timestamp
    }, { merge: true }); // Use merge: true to update existing fields and add new ones without overwriting entire doc
    // Note: createdAt should only be set on initial creation, not on every update.
    // We'll manage createdAt in cardManager.ts before passing to repository.
    console.log(`PromptCard ${card.id} saved for user ${userId}`);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    const cardSnap = await getDoc(cardDocRef);

    if (cardSnap.exists()) {
      // Firestore `data()` method returns `any`. We cast it to PromptCard.
      // Note: serverTimestamp() will be an object like { seconds: ..., nanoseconds: ... }
      // when retrieved, not an ISO string. We might need a conversion layer if UI strictly expects ISO string.
      // However, Firestore handles this transparently for objects if saving back.
      // For display, formatIsoDateForDisplay will handle it correctly if it's Date or Timestamp object.
      const data = cardSnap.data() as PromptCard;

      // Firestore's serverTimestamp() retrieves as a Timestamp object.
      // To ensure our PromptCard interface holds string (ISO 8601), we convert it here.
      // This is a common pattern: store one way, retrieve/convert to match app's type.
      return {
        ...data,
        createdAt: toIsoStringIfTimestamp(data.createdAt),
        updatedAt: toIsoStringIfTimestamp(data.updatedAt),
      };
    } else {
      console.log(`No PromptCard found with ID: ${cardId} for user ${userId}`);
      return null;
    }
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    const q = query(
      this.getCollectionRef(userId),
      orderBy('updatedAt', 'desc') // Order by last updated, newest first
    );
    const querySnapshot = await getDocs(q);
    const cards: PromptCard[] = [];
    querySnapshot.forEach((doc) => {
      // Same conversion for Timestamp objects as in getPromptCard
      const data = doc.data() as PromptCard;
      cards.push({
        ...data,
        createdAt: toIsoStringIfTimestamp(data.createdAt),
        updatedAt: toIsoStringIfTimestamp(data.updatedAt),
      });
    });
    console.log(`Retrieved ${cards.length} prompt cards for user ${userId}`);
    return cards;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    await deleteDoc(cardDocRef);
    console.log(`PromptCard ${cardId} deleted for user ${userId}`);
  }

  async importPromptCards(userId: string, cards: PromptCard[]): Promise<void> {
    // Firestore transactions/batch writes are ideal for bulk operations.
    // For simplicity in MVP, we'll do individual setDoc calls in parallel.
    // A more robust solution might use writeBatch for atomicity.
    const importPromises = cards.map(async (card) => {
      // Assume cardManager has already processed these cards for import (new IDs, hashes, ownerId).
      const cardDocRef = doc(this.getCollectionRef(userId), card.id);
      await setDoc(cardDocRef, {
        ...card,
        // Ensure timestamps are correctly handled for imported cards.
        // If the imported card already has createdAt/updatedAt, use them.
        // Otherwise, serverTimestamp() is an option, but for imports,
        // it's often preferred to preserve original times or set a specific import time.
        // For now, assume the card object already has string ISO timestamps set by cardManager.
      });
    });
    await Promise.all(importPromises);
    console.log(`Successfully imported ${cards.length} prompt cards for user ${userId}`);
  }
}

// Export a singleton instance of the repository for use throughout the application
export const promptCardRepository = new FirestorePromptCardRepository();
@@END_FILE@@
@@FILE: src/index.css
/* Reset and base styles */
* {
  box-sizing: border-box;
}

html,
body,
#root {
  margin: 0;
  padding: 0;
  height: 100%;
  background-color: transparent;
  color: inherit;
}

/* Prevent default link styles from clashing */
a {
  color: inherit;
  text-decoration: none;
}

/* Smooth scrolling */
html {
  scroll-behavior: smooth;
}

@@END_FILE@@
@@FILE: src/logic/ContextStackAssembler.ts
// src/logic/ContextStackAssembler.ts
import { StackMode, FilterMode } from '../models';

import type {
  PromptCard,
  GameState,
  LogEntry,
  Message,
  SceneState,
  DigestLine,
} from '../models';
import type { IContextStackAssembler } from './IContextStackAssembler';
import { getNestedValue } from '../utils/jsonUtils'; // Assuming you have this utility function
import { debugLog, errorLog } from '../utils/debug';


export class ContextStackAssembler implements IContextStackAssembler {
  public assembleContext(card: PromptCard, gameState: GameState, logEntries: LogEntry[]): Message[] {
    const messages: Message[] = [];
    const { stackInstructions } = card;

    // 1. World State Context
    if (stackInstructions.worldStatePolicy.enabled) {
      messages.push({ role: "system", content: `## Current World State\n\`\`\`json\n${JSON.stringify(gameState.worldState, null, 2)}\n\`\`\`` });
    }

    // 2. Known Entities
    if (stackInstructions.knownEntitiesPolicy.enabled) {
      const knownEntities = this.extractKnownEntities(gameState, stackInstructions.knownEntitiesPolicy.n);
      if (knownEntities.length > 0) {
        messages.push({ role: "system", content: `## Known Entities\n${knownEntities.join('\n')}` });
      }
    }

    // 3. Digest Context
    if (stackInstructions.digestPolicy.enabled) {
      const relevantDigests = this.getRelevantDigests(logEntries, gameState, card.stackInstructions);
      if (relevantDigests.length > 0) {
        messages.push({ role: "system", content: `## Game Summary Digest\n${relevantDigests.map(d => d.text).join('\n')}` });
      }
    }

    // 4. Expression Log
    if (stackInstructions.expressionLogPolicy.enabled) {
      // Placeholder for complex expression logic
    }

    return messages;
  }
  
  private getSceneTags(scene: SceneState, worldState: Record<string, any>): string[] {
    const tags = new Set<string>();
    if (scene.location?.startsWith('@')) tags.add(scene.location);
    scene.present.forEach(path => {
      const entity = getNestedValue(worldState, path.split('.'));
      if (entity?.tag) tags.add(entity.tag);
    });
    return Array.from(tags);
  }

  private extractKnownEntities(gameState: GameState, limit: number): string[] {
    const entities = new Set(this.getSceneTags(gameState.scene, gameState.worldState));
    return Array.from(entities).slice(0, limit);
  }

  private getRelevantDigests(logs: LogEntry[], gameState: GameState, instructions: PromptCard['stackInstructions']): DigestLine[] {
    const relevantDigests: DigestLine[] = [];
    const sceneTags = this.getSceneTags(gameState.scene, gameState.worldState);
    for (const log of logs) {
      for (const digest of log.digestLines) {
        const rule = instructions.digestEmission[digest.importance];
        if (!rule || rule.mode === StackMode.NEVER) continue;
        const meetsCondition = (rule.mode === StackMode.ALWAYS) || (rule.mode === StackMode.FIRST_N && log.turnNumber <= rule.n) || (rule.mode === StackMode.AFTER_N && log.turnNumber >= rule.n);
        if (meetsCondition) {
          let include = true;
          if (instructions.digestPolicy.filtering === FilterMode.SCENE_ONLY) include = digest.tags?.some(tag => sceneTags.includes(tag)) ?? false;
          else if (instructions.digestPolicy.filtering === FilterMode.TAGGED) include = (digest.tags?.length ?? 0) > 0;
          if (include) relevantDigests.push(digest);
        }
      }
    }
    return relevantDigests;
  }
}
@@END_FILE@@
@@FILE: src/logic/GameStateManager.ts
// src/logic/GameStateManager.ts

import type { IGameStateManager } from './IGameStateManager';
import { produce } from 'immer'; // For immutable updates
import type { GameState, DeltaMap } from '../models';
/**
 * Manages the mutable aspects of the game state (world state and scene).
 * All mutations here are designed to be immutable, returning new state objects.
 */
export class GameStateManager implements IGameStateManager {

  /**
   * Applies delta instructions to the worldState within a given GameState.
   * @param gameState The current game state to modify.
   * @param deltas The map of delta instructions to apply.
   * @returns A new GameState object with deltas applied (immutable update).
   */
  public applyDeltasToGameState(gameState: GameState, deltas: DeltaMap): GameState {
    return produce(gameState, draft => {
      const updatedWorld = draft.worldState; // immer makes this a mutable draft

      for (const fullKey in deltas) {
        const instruction = deltas[fullKey];
        const parts = instruction.key.split('.');

        let currentLevel: Record<string, any> = updatedWorld;
        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!currentLevel[part] || typeof currentLevel[part] !== 'object' || Array.isArray(currentLevel[part])) {
            currentLevel[part] = {};
          }
          currentLevel = currentLevel[part];
        }

        const lastPart = parts[parts.length - 1];

        switch (instruction.op) {
          case 'add':
            const prevAddValue = typeof currentLevel[lastPart] === 'number' ? currentLevel[lastPart] : 0;
            const addValue = typeof instruction.value === 'number' ? instruction.value : 0;
            currentLevel[lastPart] = prevAddValue + addValue;
            break;
          case 'assign':
            currentLevel[lastPart] = instruction.value;
            break;
          case 'declare':
            if (!(lastPart in currentLevel)) {
              currentLevel[lastPart] = instruction.value;
            }
            break;
          case 'delete':
            delete currentLevel[lastPart];
            break;
        }
      }
    });
  }

  /**
   * Updates the scene state within a given GameState based on parsed AI output or inferred deltas.
   * @param gameState The current game state to modify.
   * @param parsedScene The parsed scene object from AI output.
   * @param deltas The delta map (for inference if no explicit scene).
   * @returns A new GameState object with updated scene (immutable update).
   */
  public updateSceneState(
    gameState: GameState,
    parsedScene: Record<string, any> | null | undefined,
    deltas: DeltaMap
  ): GameState {
    return produce(gameState, draft => {
      let newLocation: string | null = draft.scene.location;
      let newPresent: string[] = [...draft.scene.present];

      if (parsedScene) {
        if (parsedScene.location !== undefined) {
          newLocation = typeof parsedScene.location === 'string' ? parsedScene.location : null;
        }
        if (Array.isArray(parsedScene.present)) {
          newPresent = parsedScene.present.filter((item: any) => typeof item === 'string');
        }
      } else {
        if ((!newLocation && newPresent.length === 0) && deltas) {
          const inferredPresent = new Set<string>();
          for (const fullKey in deltas) {
            const instruction = deltas[fullKey];
            if (instruction.op === 'declare') {
              const parts = instruction.key.split('.');
              if (parts.length >= 2) {
                const category = parts[0];
                const entity = parts[1];
                const valueObj = instruction.value as Record<string, any>;
                if (valueObj && (valueObj.tag === "character" || valueObj.tag === "location")) {
                  inferredPresent.add(`${category}.${entity}`);
                }
              }
              if (instruction.key === "world.location" && typeof instruction.value === 'string') {
                newLocation = instruction.value;
              }
            }
          }
          newPresent = Array.from(inferredPresent);
        }
      }

      draft.scene.location = newLocation;
      draft.scene.present = newPresent;
    });
  }

  // --- World State Direct Modification Methods (Immutable) ---

  public renameCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      if (draft[oldName]) {
        draft[newName] = draft[oldName];
        delete draft[oldName];
      }
    });

    const updatedPinnedKeys = currentPinnedKeys.map(key =>
      key.startsWith(oldName + '.') ? `${newName}${key.substring(oldName.length)}` : key
    );
    return { updatedWorldState, updatedPinnedKeys };
  }

  public renameEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const categoryObj = draft[category];
      if (categoryObj && categoryObj[oldName]) {
        categoryObj[newName] = categoryObj[oldName];
        delete categoryObj[oldName];
      }
    });

    const oldEntityPath = `${category}.${oldName}`;
    const newEntityPath = `${category}.${newName}`;
    const updatedPinnedKeys = currentPinnedKeys.map(key =>
      key.startsWith(oldEntityPath + '.') ? `${newEntityPath}${key.substring(oldEntityPath.length)}` : key
    );
    return { updatedWorldState, updatedPinnedKeys };
  }

  public deleteCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      delete draft[category];
    });
    const updatedPinnedKeys = currentPinnedKeys.filter(key => !key.startsWith(category + '.'));
    return { updatedWorldState, updatedPinnedKeys };
  }

  public deleteEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, entity: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const categoryObj = draft[category];
      if (categoryObj && categoryObj[entity]) {
        delete categoryObj[entity];
      }
    });
    const entityPath = `${category}.${entity}`;
    const updatedPinnedKeys = currentPinnedKeys.filter(key => !key.startsWith(entityPath + '.'));
    return { updatedWorldState, updatedPinnedKeys };
  }

  public editKeyValue(currentWorldState: Record<string, any>, key: string, value: any): Record<string, any> {
    return produce(currentWorldState, draft => {
      const parts = key.split('.');
      let current: any = draft;
      for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!current[part] || typeof current[part] !== 'object') {
          current[part] = {};
        }
        current = current[part];
      }
      current[parts[parts.length - 1]] = value;
    });
  }

  public deleteKey(currentWorldState: Record<string, any>, currentPinnedKeys: string[], key: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const parts = key.split('.');
      let current: any = draft;
      for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!(part in current)) {
          return; // Path doesn't exist, nothing to delete
        }
        current = current[part];
      }
      delete current[parts[parts.length - 1]];
    });
    const updatedPinnedKeys = currentPinnedKeys.filter(pk => pk !== key);
    return { updatedWorldState, updatedPinnedKeys };
  }
}
@@END_FILE@@
@@FILE: src/logic/IContextStackAssembler.ts
// src/logic/IContextStackAssembler.ts
import type { PromptCard, GameState, LogEntry, Message } from '../models';

/**
 * Defines the contract for a service that assembles the dynamic parts
 * of an AI prompt's context based on StackInstructions.
 */
export interface IContextStackAssembler {
  /**
   * Assembles the full dynamic context stack based on the rules in the prompt card.
   * @param card The active PromptCard containing the StackInstructions.
   * @param gameState The current GameState.
   * @param logEntries The history of log entries for the session.
   * @returns An array of Message objects representing the assembled context.
   */
  assembleContext(
    card: PromptCard,
    gameState: GameState,
    logEntries: LogEntry[]
  ): Message[];
}


@@END_FILE@@
@@FILE: src/logic/IGameStateManager.ts
// src/logic/IGameStateManager.ts

import type { GameState, DeltaMap } from '../models';

/**
 * Defines the contract for managing the mutable state of the game (worldState and scene).
 * This manager operates on GameState objects and does not directly interact with repositories.
 */
export interface IGameStateManager {
  /**
   * Applies delta instructions to the worldState within a given GameState.
   * @param gameState The current game state to modify.
   * @param deltas The map of delta instructions to apply.
   * @returns A new GameState object with deltas applied (immutable update).
   */
  applyDeltasToGameState(gameState: GameState, deltas: DeltaMap): GameState;

  /**
   * Updates the scene state within a given GameState based on parsed AI output or inferred deltas.
   * @param gameState The current game state to modify.
   * @param parsedScene The parsed scene object from AI output.
   * @param deltas The delta map (for inference if no explicit scene).
   * @returns A new GameState object with updated scene (immutable update).
   */
  updateSceneState(gameState: GameState, parsedScene: Record<string, any> | null | undefined, deltas: DeltaMap): GameState;

  // Methods for direct world state modification (now immutable operations)
  renameCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  renameEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  deleteCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  deleteEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, entity: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  editKeyValue(currentWorldState: Record<string, any>, key: string, value: any): Record<string, any>;
  deleteKey(currentWorldState: Record<string, any>, currentPinnedKeys: string[], key: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
}
@@END_FILE@@
@@FILE: src/logic/ISnapshotUpdater.ts
// src/logic/ISnapshotUpdater.ts
import type { GameSnapshot, ParsedNarrationOutput, LogEntry } from '../models';

export interface ITurnResult {
  parsedOutput: ParsedNarrationOutput;
  logEntry: LogEntry;
  playerAction?: string; // Include the player's action for conversation history
}

export interface ISnapshotUpdater {
  /**
   * Applies the result of a processed turn to a game snapshot.
   * This handles updating game state from deltas, scene changes, adding logs,
   * updating conversation history, and incrementing the turn counter.
   * @param snapshot The current GameSnapshot.
   * @param turnResult The result from the TurnProcessor.
   * @returns A new, updated GameSnapshot.
   */
  applyTurnResultToSnapshot(snapshot: GameSnapshot, turnResult: ITurnResult): GameSnapshot;

  /**
   * Applies a direct world state category rename to the snapshot.
   * @returns A new, updated GameSnapshot.
   */
  applyCategoryRename(snapshot: GameSnapshot, oldName: string, newName: string): GameSnapshot;

  /**
   * Applies a direct world state entity rename to the snapshot.
   * @returns A new, updated GameSnapshot.
   */
  applyEntityRename(snapshot: GameSnapshot, category: string, oldName: string, newName: string): GameSnapshot;
  applyCategoryDelete(snapshot: GameSnapshot, category: string): GameSnapshot;
  applyEntityDelete(snapshot: GameSnapshot, category: string, entity: string): GameSnapshot;
  applyKeyValueEdit(snapshot: GameSnapshot, key: string, value: any): GameSnapshot;
  applyKeyDelete(snapshot: GameSnapshot, key: string): GameSnapshot;
  applyPinToggle(snapshot: GameSnapshot, keyPath: string, type: 'variable' | 'entity' | 'category'): GameSnapshot;
}
@@END_FILE@@
@@FILE: src/logic/ITurnProcessor.ts
// src/logic/ITurnProcessor.ts

import type {
  PromptCard,
  GameState,
  LogEntry,
  Message,
  AiConnection,
  ParsedNarrationOutput,
  TokenSummary
} from '../models';

/**
 * Defines the contract for processing individual game turns, including AI interaction.
 */
export interface ITurnProcessor {
  /**
   * Processes a player's action, generating the AI response and updating conversation history/logs.
   * Handles both the initial turn and subsequent turns.
   *
   * @param userId The ID of the current user.
   * @param card The PromptCard used for the game.
   * @param currentGameState The current game state before the turn.
   * @param logs The current game logs.
   * @param conversationHistory The current conversation history.
   * @param action The player's input string.
   * @param turnNumber The current turn number.
   * @param useDummyNarrator Flag to use a dummy AI.
   * @param aiConnections User's configured AI connections.
   * @param isFirstPlayerAction True if this is the first player input after game start.
   */
  processPlayerTurn(
    userId: string,
    card: PromptCard,
    currentGameState: GameState,
    logs: LogEntry[],
    conversationHistory: Message[],
    action: string,
    turnNumber: number,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[],
    isFirstPlayerAction: boolean // <-- PATCHED
  ): Promise<{
    parsedOutput: ParsedNarrationOutput;
    logEntry: LogEntry;
    aiRawOutput: string;
    tokenUsage: TokenSummary | null;
  }>;
}

@@END_FILE@@
@@FILE: src/logic/SnapshotUpdater.ts
// src/logic/SnapshotUpdater.ts
import { produce } from 'immer';
import type { GameSnapshot } from '../models';
import type { IGameStateManager } from './IGameStateManager';
import type { ISnapshotUpdater, ITurnResult } from './ISnapshotUpdater';
import { flattenJsonObject, getNestedValue } from '../utils/jsonUtils';

export class SnapshotUpdater implements ISnapshotUpdater {
  constructor(private gameStateManager: IGameStateManager) {
    console.log('[SnapshotUpdater.ts] SnapshotUpdater constructor called.');
  }

  public applyTurnResultToSnapshot(snapshot: GameSnapshot, turnResult: ITurnResult): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyTurnResultToSnapshot: Starting for snapshot ${snapshot.id}. Turn: ${snapshot.currentTurn}`);
    const { parsedOutput, logEntry, playerAction } = turnResult;

    const newSnapshot = produce(snapshot, draft => {
      let stateAfterDeltas = this.gameStateManager.applyDeltasToGameState(draft.gameState, parsedOutput.deltas);
      let finalGameState = this.gameStateManager.updateSceneState(stateAfterDeltas, parsedOutput.scene, parsedOutput.deltas);

      finalGameState.narration = parsedOutput.prose;
      draft.gameState = finalGameState;

      if (playerAction) {
        draft.conversationHistory.push({ role: 'user', content: playerAction });
      }
      draft.conversationHistory.push({ role: 'assistant', content: parsedOutput.prose });
      
      draft.logs.push(logEntry);

      draft.currentTurn += 1;
      draft.updatedAt = new Date().toISOString();
    });
    console.log(`[SnapshotUpdater.ts] applyTurnResultToSnapshot: Finished. New snapshot ID: ${newSnapshot.id}.`);
    return newSnapshot;
  }

  public applyCategoryRename(snapshot: GameSnapshot, oldName: string, newName: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyCategoryRename: ${oldName} -> ${newName}`);
    return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.renameCategory(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        oldName,
        newName
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyEntityRename(snapshot: GameSnapshot, category: string, oldName: string, newName: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyEntityRename: ${category}.${oldName} -> ${category}.${newName}`);
    return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.renameEntity(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category,
        oldName,
        newName
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }
  
  public applyCategoryDelete(snapshot: GameSnapshot, category: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyCategoryDelete: ${category}`);
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteCategory(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyEntityDelete(snapshot: GameSnapshot, category: string, entity: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyEntityDelete: ${category}.${entity}`);
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteEntity(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category,
        entity
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyKeyValueEdit(snapshot: GameSnapshot, key: string, value: any): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyKeyValueEdit: ${key} = ${JSON.stringify(value)}`);
     return produce(snapshot, draft => {
      draft.gameState.worldState = this.gameStateManager.editKeyValue(
        draft.gameState.worldState,
        key,
        value
      );
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyKeyDelete(snapshot: GameSnapshot, key: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyKeyDelete: ${key}`);
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteKey(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        key
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyPinToggle(snapshot: GameSnapshot, keyPath: string, type: 'variable' | 'entity' | 'category'): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyPinToggle: Starting for snapshot ${snapshot.id}, keyPath: ${keyPath}, type: ${type}.`);
    const newSnapshot = produce(snapshot, draft => {
      const currentWorldState = draft.gameState.worldState || {};
      const currentPinnedKeys = draft.worldStatePinnedKeys || [];
      const newPinnedKeys = new Set(currentPinnedKeys);

      const getAllChildVariableKeys = (basePath: string): string[] => {
        const nestedData = getNestedValue(currentWorldState, basePath.split('.'));
        if (typeof nestedData !== 'object' || nestedData === null) return [];
        const flattened = flattenJsonObject(nestedData, basePath);
        return Object.keys(flattened).filter(key => flattened[key] !== undefined); // Only include existing keys
      };

      let relevantKeysToToggle: string[] = [];
      if (type === 'variable') {
        relevantKeysToToggle = [keyPath];
      } else { // 'entity' or 'category'
        relevantKeysToToggle = getAllChildVariableKeys(keyPath);
      }

      // If there are no keys to toggle (e.g., entity doesn't exist), do nothing.
      if (relevantKeysToToggle.length === 0) {
        console.warn(`[SnapshotUpdater.ts] applyPinToggle: No relevant keys found for ${type} at "${keyPath}". No change.`);
        return; // No changes to draft
      }
      
      const areAllChildrenCurrentlyPinned = relevantKeysToToggle.every(key => newPinnedKeys.has(key));
      const shouldPin = !areAllChildrenCurrentlyPinned; 

      console.log(`[SnapshotUpdater.ts] applyPinToggle: Relevant keys (${relevantKeysToToggle.length}): ${relevantKeysToToggle.join(', ')}. ShouldPin: ${shouldPin}`);

      relevantKeysToToggle.forEach(key => {
        if (shouldPin) {
          newPinnedKeys.add(key);
        } else {
          newPinnedKeys.delete(key);
        }
      });

      draft.worldStatePinnedKeys = Array.from(newPinnedKeys).sort();
      draft.updatedAt = new Date().toISOString();
      console.log(`[SnapshotUpdater.ts] applyPinToggle: Final pinned keys count: ${draft.worldStatePinnedKeys.length}.`);
    });
    console.log(`[SnapshotUpdater.ts] applyPinToggle: Finished. New snapshot ID: ${newSnapshot.id}.`);
    return newSnapshot;
  }
}
@@END_FILE@@
@@FILE: src/logic/TurnProcessor.ts
// src/logic/TurnProcessor.ts

import type { AiSettings, AiConnection, GameState, LogEntry, Message, ParsedNarrationOutput, PromptCard, TokenSummary } from '../models';
import type { IAiClient } from './aiClient';
import { parseNarratorOutput } from './deltaParser';
import type { ILogManager } from './logManager';
import type { IPromptBuilder } from './promptBuilder';
import type { ITurnProcessor } from './ITurnProcessor';
import type { ModelInfo } from '../data/config/aiConnectionTemplates';

// Define a simple DummyAiClient for testing and dev
class DummyAiClient implements IAiClient {
  async generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string> {
    console.log("Dummy Narrator: Simulating AI response...");
    const lastUserMessage = messages.slice().reverse().find(m => m.role === 'user')?.content || 'No user input.';
    const dummyResponse = {
      choices: [{
        message: {
          content: `The dummy narrator observes your action: "${lastUserMessage}". A ripple of arcane energy flows through the air, subtly shifting the very fabric of reality around you. You hear a distant chime, and a curious, ancient tome appears at your feet.

@digest
\`\`\`json
[
  { "text": "The world reacted to your input: '${lastUserMessage}'.", "importance": 2 },
  { "text": "Something new has manifested nearby: the $enchanted_quill.", "importance": 4, "tags": ["$enchanted_quill"] },
  { "text": "#Brom's disposition shifted slightly.", "importance": 3, "tags": ["#brom"] },
  { "text": "A critical system event occurred, requiring your attention!", "importance": 5 }
]
\`\`\`

@delta
\`\`\`json
{
  "=player.hp": 85,
  "+player.gold": 5,
  "!items.$enchanted_quill.description": "A quill that seems to hum with forgotten magic, vibrating faintly.",
  "-npcs.#old_sage.wisdom" : true,
  "=player.status": "observant"
}
\`\`\`

@scene
\`\`\`json
{
  "location": "@forest_clearing",
  "present": ["#you", "#lyrielle", "$enchanted_quill"],
  "weather": "clear and crisp"
}
\`\`\`
`
        }
      }],
      usage: {
        prompt_tokens: 10,
        completion_tokens: 150,
        total_tokens: 160,
      }
    };
    return Promise.resolve(JSON.stringify(dummyResponse));
  }

  async testConnection(connection: AiConnection): Promise<{ success: boolean; message: string }> {
    return Promise.resolve({
      success: true,
      message: "Dummy client: test always passes."
    });
  }

  async listModels(connection: Pick<AiConnection, 'apiUrl' | 'apiToken'>): Promise<ModelInfo[]> {
    return Promise.resolve([
      { id: 'dummy-model', name: 'Dummy Model' }
    ]);
  }
}

export class TurnProcessor implements ITurnProcessor {
  private realAiClient: IAiClient;
  private dummyAiClient: IAiClient;
  private builder: IPromptBuilder;
  private logManager: ILogManager;

  constructor(
    aiClient: IAiClient,
    promptBuilder: IPromptBuilder,
    logManager: ILogManager
  ) {
    this.realAiClient = aiClient;
    this.builder = promptBuilder;
    this.logManager = logManager;
    this.dummyAiClient = new DummyAiClient();
  }

  private async executeAiCall(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings,
    useDummyNarrator: boolean
  ): Promise<{ aiRawOutput: string; tokenUsage: TokenSummary | null; fullResponse: string }> {
    const activeClient = useDummyNarrator ? this.dummyAiClient : this.realAiClient;
    const fullResponse = await activeClient.generateCompletion(connection, messages, settings);

    let aiRawOutput = '';
    let tokenUsage: TokenSummary | null = null;
    try {
      const parsedJson = JSON.parse(fullResponse);
      aiRawOutput = parsedJson.choices?.[0]?.message?.content?.trim() || fullResponse;
      tokenUsage = parsedJson.usage ? {
        inputTokens: parsedJson.usage.prompt_tokens || 0,
        outputTokens: parsedJson.usage.completion_tokens || 0,
        totalTokens: parsedJson.usage.total_tokens || 0,
      } : null;
    } catch (e) {
      aiRawOutput = fullResponse;
    }
    return { aiRawOutput, tokenUsage, fullResponse };
  }

  async processPlayerTurn(
    userId: string,
    card: PromptCard,
    currentGameState: GameState,
    logs: LogEntry[],
    conversationHistory: Message[],
    action: string,
    turnNumber: number,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[],
    isFirstPlayerAction: boolean
  ): Promise<{ parsedOutput: ParsedNarrationOutput; logEntry: LogEntry; aiRawOutput: string; tokenUsage: TokenSummary | null; }> {
    const messagesToSend = this.builder.buildEveryTurnPrompt(
      card,
      currentGameState,
      logs,
      conversationHistory,
      action,
      isFirstPlayerAction
    );
    const contextSnapshotForLog = JSON.stringify(messagesToSend, null, 2);

    const connection = aiConnections.find(c => c.id === card.aiSettings.selectedConnectionId);
    if (!connection && !useDummyNarrator) {
      throw new Error(`AI connection ${card.aiSettings.selectedConnectionId} not found.`);
    }

    const startTime = performance.now();
    const { aiRawOutput, tokenUsage, fullResponse } = await this.executeAiCall(connection!, messagesToSend, card.aiSettings, useDummyNarrator);
    const latencyMs = Math.round(performance.now() - startTime);

    const parsedOutput = parseNarratorOutput(aiRawOutput);

    const logEntry = this.logManager.assembleTurnLogEntry({
      turnNumber: turnNumber,
      userInput: action,
      rawNarratorOutput: aiRawOutput,
      parsedOutput: parsedOutput,
      contextSnapshot: contextSnapshotForLog,
      tokenUsage: tokenUsage,
      aiSettings: card.aiSettings,
      apiRequestBody: JSON.stringify({ model: connection?.modelSlug, messages: "..." }, null, 2),
      apiResponseBody: fullResponse,
      apiUrl: connection ? new URL("chat/completions", connection.apiUrl).href : 'dummy-url',
      latencyMs: latencyMs,
      modelSlugUsed: connection?.modelSlug || 'dummy-model',
    });

    return { parsedOutput, logEntry, aiRawOutput, tokenUsage };
  }
}

@@END_FILE@@
@@FILE: src/logic/aiClient.ts
// src/logic/aiClient.ts

import type { ModelInfo } from '../data/config/aiConnectionTemplates';
import type { Message, AiSettings, AiConnection } from '../models';
import { debugLog, errorLog } from '../utils/debug';

/**
 * Interface defining the contract for an AI client.
 */
export interface IAiClient {
  /**
   * Sends a completion request to the AI API.
   * @param connection The AiConnection details (URL, API key).
   * @param messages The array of messages forming the conversation context.
   * @param settings The AI settings for this specific call (temperature, etc.).
   * @returns A Promise that resolves with the raw stringified JSON of the AI's response.
   */
  generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string>;

  /**
   * Tests an AI connection by making a minimal API call.
   * @param connection The AiConnection details to test.
   * @returns A Promise that resolves to an object with success status and a descriptive message.
   */
  testConnection(connection: AiConnection): Promise<{ success: boolean, message: string }>;

  /**
   * Fetches a list of available models from the provider.
   * @param connection A partial connection object with apiUrl and apiToken.
   * @returns A Promise resolving with an array of ModelInfo objects.
   */
  listModels(connection: Pick<AiConnection, 'apiUrl' | 'apiToken'>): Promise<ModelInfo[]>;
}

/**
 * Concrete implementation of IAiClient using the browser's fetch API.
 */
class AiClient implements IAiClient {
  async generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string> {
    if (!connection.apiToken || connection.apiToken.includes('PASTE') || connection.apiToken === "MISSING_API_KEY") {
      throw new Error("API key is missing or is a placeholder. Please set it in Settings.");
    }

    const apiUrl = new URL("chat/completions", connection.apiUrl).href;
    const requestBody = {
      model: connection.modelSlug,
      messages: messages,
      temperature: settings.temperature,
      top_p: settings.topP,
      max_tokens: settings.maxTokens,
      presence_penalty: settings.presencePenalty,
      frequency_penalty: settings.frequencyPenalty,
      stream: false,
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${connection.apiToken}` },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        let specificError = `Request failed with status ${response.status}.`;
        switch (response.status) {
          case 401: specificError = "Authentication error (401). Your API Key is likely invalid or expired."; break;
          case 403: specificError = "Permission denied (403). Your API key may not have access to this model."; break;
          case 404: specificError = `Model not found (404). Check if the API URL is correct and the model slug '${connection.modelSlug}' is valid.`; break;
          case 429: specificError = "Rate limit exceeded (429). You are sending requests too quickly. Please wait and try again."; break;
          case 500: specificError = "AI Server Error (500). The provider is having issues. Please try again later."; break;
        }
        throw new Error(`${specificError} Details: ${errorBody.substring(0, 200)}...`);
      }

      const responseJson = await response.json();
      return JSON.stringify(responseJson);
    } catch (error: unknown) {
        if (error instanceof Error) {
            throw new Error(`AI API call failed: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during the AI API call.`);
    }
  }

  async testConnection(connection: AiConnection): Promise<{ success: boolean, message: string }> {
    if (!connection.apiToken || connection.apiToken.includes('PASTE') || connection.apiToken === "MISSING_API_KEY") {
      return { success: false, message: "API Key is missing or is a placeholder." };
    }

    const apiUrl = new URL("chat/completions", connection.apiUrl).href;
    const testMessage: Message[] = [{ role: 'user', content: 'hello' }];
    const requestBody = { model: connection.modelSlug, messages: testMessage, max_tokens: 10 };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${connection.apiToken}` },
        body: JSON.stringify(requestBody),
      });

      if (response.ok) {
        return { success: true, message: `Success! Received response from model.` };
      } else {
        const errorBody = await response.text();
        let specificError = `Request failed with status ${response.status}.`;
        switch (response.status) {
          case 401: specificError = "Authentication error (401). Your API Key is invalid."; break;
          case 404: specificError = `Model not found (404). Check API URL and Model Slug.`; break;
          case 403: specificError = "Permission denied (403). Key may not have access to this model."; break;
          default: specificError = `Error ${response.status}: ${errorBody.substring(0, 100)}`;
        }
        return { success: false, message: `❌ ${specificError}` };
      }
    } catch (error) {
      return { success: false, message: `❌ Network Error: Could not reach the API endpoint. Check the URL and your connection.` };
    }
  }

  async listModels(connection: Pick<AiConnection, 'apiUrl' | 'apiToken'>): Promise<ModelInfo[]> {
    if (!connection.apiToken || connection.apiToken.includes('PASTE')) {
      throw new Error("An API key is required to fetch models.");
    }
    
    const modelsUrl = new URL("models", connection.apiUrl).href;

    try {
      const response = await fetch(modelsUrl, { 
        method: 'GET', 
        headers: { 'Authorization': `Bearer ${connection.apiToken}` }
      });
      if (!response.ok) {
        throw new Error(`Failed to fetch models with status ${response.status}`);
      }
      const json = await response.json();
      
      // The data structure varies between APIs (e.g., json.data for OpenAI)
      const modelList = json.data || json.models || [];

      return modelList
        .map((model: any) => ({ 
          id: model.id, 
          name: model.name || model.id // Use 'name' if available (like OpenRouter), otherwise fall back to 'id'
        }))
        .sort((a: ModelInfo, b: ModelInfo) => a.name.localeCompare(b.name));

    } catch (error) {
      errorLog("Failed to list models:", error);
      throw error;
    }
  }
}

// Export a singleton instance of the AI client.
export const aiClient = new AiClient();
@@END_FILE@@
@@FILE: src/logic/cardManager.ts
// src/logic/cardManager.ts

import type { PromptCard, NewPromptCardData, StackInstructions} from '../models';
import { generateUuid } from '../utils/uuid';
import { generateContentHash, getPromptCardContentForHash } from '../utils/hash';
import { promptCardRepository } from '../data/repositories/promptCardRepository';
import type { IPromptCardRepository } from '../data/repositories/promptCardRepository';

import { debugLog, errorLog } from '../utils/debug';
import {
  defaultAiSettingsInCard,
  defaultStackInstructions,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../data/config/promptCardDefaults';

/**
 * Interface defining the contract for the Card Manager.
 * This can be useful for testing or providing different implementations (e.g., a mock manager).
 */
export interface ICardManager {
  /**
   * Creates a brand new PromptCard with default values for unspecified fields.
   * Generates new IDs and hash, sets creation/update timestamps.
   * @param userId The ID of the user creating the card.
   * @param data The initial data for the new card.
   * @returns A Promise resolving with the newly created PromptCard.
   */
  createNewPromptCard(userId: string, data: NewPromptCardData): Promise<PromptCard>;

  /**
   * Updates an existing PromptCard. Recalculates the content hash and updates the timestamp.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the card to update.
   * @param updates The partial PromptCard data to apply.
   * @returns A Promise resolving with the updated PromptCard or null if not found.
   */
  updatePromptCard(userId: string, cardId: string, updates: Partial<PromptCard>): Promise<PromptCard | null>;

  /**
   * Duplicates an existing PromptCard, creating a new card with a new ID
   * but linking it to the original's lineage (parentId, rootId).
   * @param userId The ID of the user performing the duplication.
   * @param sourceCardId The ID of the card to duplicate.
   * @returns A Promise resolving with the new, duplicated PromptCard or null if source not found.
   */
  duplicatePromptCard(userId: string, sourceCardId: string): Promise<PromptCard | null>;

  /**
   * Deletes a PromptCard.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the card to delete.
   * @returns A Promise resolving when the card is deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Retrieves a single PromptCard.
   * @param userId The ID of the user.
   * @param cardId The ID of the card.
   * @returns A Promise resolving with the PromptCard or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a user.
   * @param userId The ID of the user.
   * @returns A Promise resolving with an array of PromptCards.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Exports a single PromptCard for sharing/download.
   * This might involve stripping user-specific metadata like ownerId for public sharing.
   * For now, it simply returns the card, but can be extended.
   * @param userId The ID of the user exporting.
   * @param cardId The ID of the card to export.
   * @returns A Promise resolving with the PromptCard or null.
   */
  exportPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Imports PromptCards from a provided list (e.g., from a JSON file).
   * This involves generating new IDs, re-calculating hashes, setting ownerId,
   * and linking lineage appropriately.
   * @param userId The ID of the user importing.
   * @param importedCardsData An array of NewPromptCardData (or similar) from the import source.
   * @returns A Promise resolving with an array of the newly imported PromptCards.
   */
  importPromptCards(userId: string, importedCardsData: NewPromptCardData[]): Promise<PromptCard[]>;
}

/**
 * Concrete implementation of ICardManager.
 */
export class PromptCardManager implements ICardManager {
  constructor(private repo: IPromptCardRepository) {}

  private async buildPromptCard(userId: string, data: NewPromptCardData, existingCard?: PromptCard): Promise<PromptCard> {
    const now = new Date().toISOString();
    let cardId: string;
    let rootId: string;
    let parentId: string | null;
    let createdAt: string;

    if (existingCard) {
      // This path is for updates, or duplicating where we are basing off an existing structure
      cardId = existingCard.id;
      rootId = existingCard.rootId;
      parentId = existingCard.parentId; // Parent ID remains the same for updates
      createdAt = existingCard.createdAt;
    } else {
      // This path is for new creations or imports that need new IDs
      cardId = generateUuid();
      rootId = cardId; // For brand new cards, rootId is its own ID
      parentId = null; // No parent for brand new cards
      createdAt = now;
    }

    // Handle stackInstructions: if provided as string, parse it; otherwise use object or default.
    let parsedStackInstructions: StackInstructions;
    if (typeof data.stackInstructions === 'string') {
      try {
        parsedStackInstructions = JSON.parse(data.stackInstructions);
      } catch (e) {
        errorLog("Error parsing stackInstructions string for new card, falling back to default:", e);
        parsedStackInstructions = defaultStackInstructions;
      }
    } else if (data.stackInstructions) {
      parsedStackInstructions = data.stackInstructions;
    } else {
      parsedStackInstructions = defaultStackInstructions;
    }

    // Construct the card with defaults applied where data is missing
    const tempCard: PromptCard = {
      id: cardId,
      rootId: rootId,
      parentId: parentId,
      ownerId: userId,
      createdAt: createdAt,
      updatedAt: now, // Always update timestamp on creation/modification
      title: data.title,
      prompt: data.prompt,
      description: data.description ?? null,
      firstTurnOnlyBlock: data.firstTurnOnlyBlock ?? DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: parsedStackInstructions,
      emitSkeleton: data.emitSkeleton ?? DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: data.worldStateInit ?? "",
      gameRules: data.gameRules ?? "",
      aiSettings: { ...defaultAiSettingsInCard, ...data.aiSettings },
      helperAiSettings: { ...defaultAiSettingsInCard, ...data.helperAiSettings },
      isHelperAiEnabled: data.isHelperAiEnabled ?? false, // NEW: Initialize with default false
      tags: data.tags ?? [],
      isExample: data.isExample ?? false,
      functionDefs: data.functionDefs ?? "",
      isPublic: data.isPublic ?? false, // Default to private for new user-created cards
      contentHash: '', // Will be calculated below
      historyBrowsingEnabled: data.historyBrowsingEnabled ?? true, // <-- ADD THIS (default to true)
    };

    // Calculate content hash AFTER all content fields are finalized
    tempCard.contentHash = generateContentHash(getPromptCardContentForHash(tempCard));

    return tempCard;
  }

  async createNewPromptCard(userId: string, data: NewPromptCardData): Promise<PromptCard> {
    const newCard = await this.buildPromptCard(userId, data);
    await this.repo.savePromptCard(userId, newCard);
    return newCard;
  }

  async updatePromptCard(userId: string, cardId: string, updates: Partial<PromptCard>): Promise<PromptCard | null> {
    const existingCard = await this.repo.getPromptCard(userId, cardId);
    if (!existingCard) {
      return null;
    }

    // Apply updates
    const updatedCardData = { ...existingCard, ...updates };

    // Re-calculate hash based on potentially changed content fields
    const newContentHash = generateContentHash(getPromptCardContentForHash(updatedCardData));
    updatedCardData.contentHash = newContentHash;
    updatedCardData.updatedAt = new Date().toISOString(); // Update timestamp on modification

    await this.repo.savePromptCard(userId, updatedCardData);
    return updatedCardData;
  }

  async duplicatePromptCard(userId: string, sourceCardId: string): Promise<PromptCard | null> {
    const sourceCard = await this.repo.getPromptCard(userId, sourceCardId);
    if (!sourceCard) {
      debugLog(`Source card with ID ${sourceCardId} not found for duplication.`);
      return null;
    }

    const newId = generateUuid();
    const now = new Date().toISOString();

    const duplicatedCard: PromptCard = {
      ...sourceCard, // Copy all existing fields
      id: newId, // Assign new ID
      rootId: sourceCard.rootId, // Root remains the same
      parentId: sourceCard.id, // New parent is the source card
      ownerId: userId, // Ensure new owner is current user
      createdAt: now, // New creation timestamp for the duplicate
      updatedAt: now, // New update timestamp
      isExample: false, // Duplicates are user-owned, not examples
      isPublic: false, // Duplicates are private by default
      // isHelperAiEnabled will be copied correctly from sourceCard by the spread operator
    };

    // Recalculate hash for the duplicated card in case any content fields were implicitly changed
    // (e.g., if a previous source card had an older version of stack instructions that parsed differently).
    // Or just for robustness.
    duplicatedCard.contentHash = generateContentHash(getPromptCardContentForHash(duplicatedCard));

    await this.repo.savePromptCard(userId, duplicatedCard);
    debugLog(`Card ${sourceCardId} duplicated to ${newId}`);
    return duplicatedCard;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    await this.repo.deletePromptCard(userId, cardId);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    return this.repo.getPromptCard(userId, cardId);
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    return this.repo.getAllPromptCards(userId);
  }

  async exportPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const card = await this.repo.getPromptCard(userId, cardId);
    if (card) {
      // For export, you might want to strip or transform sensitive/user-specific fields.
      // For MVP, we return the full card.
      // E.g., delete card.ownerId; // if it's meant for public template export
    }
    return card;
  }

  async importPromptCards(userId: string, importedCardsData: NewPromptCardData[]): Promise<PromptCard[]> {
    const importedAndProcessedCards: PromptCard[] = [];
    for (const data of importedCardsData) {
      // For imported cards, we generate a new UUID.
      // The parentId and rootId logic for imports needs careful consideration:
      // If the imported card explicitly defines a lineage, we might keep it.
      // If it's a "fresh" import, its rootId becomes its own new ID, parentId is null.
      // For now, let's treat all imports as new roots by default for simplicity,
      // and re-establish lineage if a more complex import format is defined later.
      // OR, if `NewPromptCardData` from import includes original IDs, we could preserve root/parent
      // For MVP, let's assume they are new root cards.
      const newCard = await this.buildPromptCard(userId, data);
      importedAndProcessedCards.push(newCard);
    }
    await this.repo.importPromptCards(userId, importedAndProcessedCards);
   debugLog(`Imported ${importedAndProcessedCards.length} cards.`);
    return importedAndProcessedCards;
  }
}

// Export a singleton instance of the manager
export const promptCardManager = new PromptCardManager(promptCardRepository);
@@END_FILE@@
@@FILE: src/logic/deltaParser.ts
// src/logic/deltaParser.ts
import type { DeltaInstruction, DeltaMap,DigestLine, ParsedNarrationOutput} from '../models';
import { debugLog, errorLog } from '../utils/debug';

// Exported Marker constants
export const DELTA_MARKER = "@delta";
export const DIGEST_MARKER = "@digest";
export const SCENE_MARKER = "@scene";

/**
 * Extracts a JSON object from a string, handling potential parsing errors.
 * This function expects the *raw JSON string*, not lines including fences.
 * @param jsonString The raw JSON string.
 * @returns A JSON object, or an empty object on error.
 */
function extractJsonObject(jsonString: string): Record<string, unknown> {
  const text = jsonString.trim();
  if (!text) return {};
  try {
    const parsed = JSON.parse(text);
    return typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed) ? parsed : {};
  } catch (e: unknown) {
    errorLog("Failed to parse JSON object:", e, "\nText:", text);
    return {};
  }
}

/**
 * Extracts a JSON array from a string, handling potential parsing errors.
 * This function expects the *raw JSON string*, not lines including fences.
 * @param jsonString The raw JSON string.
 * @returns A JSON array, or an empty array on error.
 */
function extractJsonArray(jsonString: string): unknown[] {
  const text = jsonString.trim();
  if (!text) return [];
  try {
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : [];
  } catch (e: unknown) {
    errorLog("Failed to parse JSON array:", e, "\nText:", text);
    return [];
  }
}

/**
 * Extracts content from a markdown-fenced JSON block.
 * Looks for ```json and ```. Also includes a fallback for unfenced blocks
 * if a JSON start character is found immediately after the marker.
 * @param lines The full array of lines from AI output.
 * @param startIndex The index of the marker line (e.g., @delta).
 * @returns The raw JSON string content, or an empty string if not found.
 */
function extractFencedJsonBlock(lines: string[], startIndex: number): string {
    if (startIndex < 0 || startIndex >= lines.length) {
        return "";
    }

    let jsonLines: string[] = [];
    let inJsonBlock = false;
    let fenceFound = false;

    // Start searching from the line *after* the marker
    for (let i = startIndex + 1; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line.startsWith("```")) {
            if (!inJsonBlock) {
                // Found opening fence
                inJsonBlock = true;
                fenceFound = true;
                // If there's content *after* ```json on the same line
                const contentAfterFence = line.substring(line.indexOf('{'));
                if(contentAfterFence.startsWith('{') || contentAfterFence.startsWith('[')) {
                    jsonLines.push(contentAfterFence);
                }
                continue;
            } else {
                // Found closing fence
                break;
            }
        }

        if (inJsonBlock) {
            jsonLines.push(lines[i]);
        } else if (!fenceFound && (line.startsWith("{") || line.startsWith("["))) {
            // If no fence was found yet, but we encounter a JSON start,
            // assume it's an unfenced block and start capturing.
            // This is a fallback for AIs that don't use fences.
            inJsonBlock = true;
            jsonLines.push(lines[i]);
        } else if (inJsonBlock && !fenceFound && !line.startsWith("{") && !line.startsWith("[")) {
            // If we're in an unfenced block but encounter a non-JSON line, stop.
            break;
        }
    }

    return jsonLines.join('\n').trim();
}

/**
 * Parses a key-value pair from the AI's delta JSON into a DeltaInstruction.
 * Corresponds to `DeltaInstruction.fromJsonElement` from the old project.
 * The raw key is expected to be in the format `+player.gold` or `=npcs.goblin.hp`.
 * @param rawKey The raw key from the JSON, e.g., "+player.gold".
 * @param value The JSON value associated with the key.
 * @returns A DeltaInstruction object or null if parsing fails.
 */
function parseSingleDelta(rawKey: string, value: unknown): DeltaInstruction | null {
  const op = rawKey.charAt(0);
  const path = rawKey.substring(1); // The rest of the key, e.g., "player.gold"

  switch (op) {
    case '+':
      return { op: 'add', key: path, value: value };
    case '=':
      return { op: 'assign', key: path, value: value };
    case '!':
      return { op: 'declare', key: path, value: value };
    case '-':
      return { op: 'delete', key: path };
    default:
      console.warn(`Invalid delta operation character '${op}' in key '${rawKey}'`);
      return null;
  }
}

/**
 * Parses the raw AI response string into a structured ParsedNarrationOutput object.
 * This function replicates the logic of `NarrationParser.extractJsonAndCleanNarration`.
 * @param rawAiOutput The full, raw string from the AI model.
 * @returns A ParsedNarrationOutput object.
 */
export function parseNarratorOutput(rawAiOutput: string): ParsedNarrationOutput {
  const lines = rawAiOutput.split('\n');

  const deltaIndex = lines.findIndex(line => line.trim() === DELTA_MARKER);
  const digestIndex = lines.findIndex(line => line.trim() === DIGEST_MARKER);
  const sceneIndex = lines.findIndex(line => line.trim() === SCENE_MARKER);

  const firstMarkerIndex = [deltaIndex, digestIndex, sceneIndex]
    .filter(index => index !== -1)
    .reduce((min, current) => Math.min(min, current), lines.length);

  const prose = lines.slice(0, firstMarkerIndex).join('\n').trim();

  // Use the new helper to extract the raw JSON strings
  const deltaJsonString = extractFencedJsonBlock(lines, deltaIndex);
  const digestJsonString = extractFencedJsonBlock(lines, digestIndex);
  const sceneJsonString = extractFencedJsonBlock(lines, sceneIndex);

  const deltaJson = extractJsonObject(deltaJsonString);
  const digestJson = extractJsonArray(digestJsonString);
  const sceneJson = extractJsonObject(sceneJsonString);

  // --- Parse Deltas ---
  const deltas: DeltaMap = {};
  for (const key in deltaJson) {
    const instruction = parseSingleDelta(key, deltaJson[key]);
    if (instruction) {
      deltas[key] = instruction;
    }
  }

  // --- Parse Digest Lines ---
  const digestLines: DigestLine[] = digestJson.map((item) => {
    const { text = '', importance } = item as { text?: string; importance?: number };
    const finalImportance = typeof importance === 'number' ? importance : 3;
    // Extract tags from text using regex, as in original NarrationParser
    const tagPattern = /[#@$][a-zA-Z0-9_]+/g;
    const tags = text.match(tagPattern) || [];
    return { text, importance: finalImportance, tags };
  }).filter(line => line.text); // Filter out empty lines

  return {
    prose,
    deltas,
    digestLines,
    scene: sceneJson,
  };
}
@@END_FILE@@
@@FILE: src/logic/gameSession.ts
import type { IGameRepository } from '../data/repositories/gameRepository';
import type { IPromptCardRepository } from '../data/repositories/promptCardRepository';
import type { GameSnapshot, PromptCard, AiConnection, LogEntry  } from '../models';
import { formatIsoDateForDisplay } from '../utils/formatDate';
import { generateUuid } from '../utils/uuid';
import type { ITurnProcessor } from './ITurnProcessor';
import type { ISnapshotUpdater } from './ISnapshotUpdater';
import { debugLog, errorLog } from '../utils/debug';

/**
 * Defines the contract for the stateless GameSession service.
 * Its purpose is to calculate game state transitions, not to hold state itself.
 */
export interface IGameSession {
  initializeGame(userId: string, card: PromptCard): GameSnapshot;
  
  processPlayerAction(
    snapshot: GameSnapshot,
    card: PromptCard,
    action: string,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[]
  ): Promise<GameSnapshot>;

  renameWorldCategory(snapshot: GameSnapshot, oldName: string, newName: string): GameSnapshot;
  renameWorldEntity(snapshot: GameSnapshot, category: string, oldName: string, newName: string): GameSnapshot;
  deleteWorldCategory(snapshot: GameSnapshot, category: string): GameSnapshot;
  deleteWorldEntity(snapshot: GameSnapshot, category: string, entity: string): GameSnapshot;
  editWorldKeyValue(snapshot: GameSnapshot, key: string, value: any): GameSnapshot;
  deleteWorldKey(snapshot: GameSnapshot, key: string): GameSnapshot;
  toggleWorldStatePin(snapshot: GameSnapshot, keyPath: string, type: 'variable' | 'entity' | 'category'): GameSnapshot;
}

/**
 * A stateless service that calculates game state transitions.
 * It does not hold any internal state like currentSnapshot.
 */
export class GameSession implements IGameSession {
  constructor(
    private turnProcessor: ITurnProcessor,
    private snapshotUpdater: ISnapshotUpdater
  ) {
    debugLog('[gameSession.ts] Stateless GameSession service instantiated.');
  }

  public initializeGame(userId: string, card: PromptCard): GameSnapshot {
    debugLog(`[gameSession.ts] initializeGame: Creating new snapshot for User=${userId}, Card=${card.id}`);
    
    let initialWorldState = {};
    try {
      if (card.worldStateInit) initialWorldState = JSON.parse(card.worldStateInit);
    } catch (e) {
      errorLog("[gameSession.ts] initializeGame: Failed to parse worldStateInit JSON:", e);
      initialWorldState = {};
    }
    const gameId = generateUuid();
    const now = new Date().toISOString();

    // CREATE THE "TURN 0" LOG ENTRY
    const turnZeroLog: LogEntry = {
      turnNumber: 0,
      timestamp: now,
      userInput: "[GAME START]",
      narratorOutput: card.firstTurnOnlyBlock,
      prose: card.firstTurnOnlyBlock, // Merging initial text into both fields
      digestLines: [],
      deltas: null,
      contextSnapshot: "Initial game state setup.",
      tokenUsage: null,
      apiRequestBody: null,
      apiResponseBody: null,
      apiUrl: null,
      latencyMs: null,
      aiSettings: card.aiSettings,
      errorFlags: [],
      modelSlugUsed: "N/A",
    };

    const initialSnapshot: GameSnapshot = {
      id: generateUuid(),
      gameId: gameId,    // Timeline ID
      userId: userId,
      promptCardId: card.id,
      title: `Game with ${card.title} - ${formatIsoDateForDisplay(now)}`,
      createdAt: now,
      updatedAt: now,
      currentTurn: 1, // The NEXT turn to be played is Turn 1
      gameState: {
        narration: card.firstTurnOnlyBlock,
        worldState: initialWorldState,
        scene: { location: null, present: [] },
      },
      conversationHistory: [
        { role: 'assistant', content: card.firstTurnOnlyBlock },
      ],
      logs: [turnZeroLog], // SEED THE LOGS with our new Turn 0 entry
      worldStatePinnedKeys: [],
    };

    debugLog(`[gameSession.ts] initializeGame: NEW game initialized with ID ${initialSnapshot.id}. Set for Turn 1.`);
    return initialSnapshot;
  }

  public async processPlayerAction(
    snapshot: GameSnapshot,
    card: PromptCard,
    action: string,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[]
  ): Promise<GameSnapshot> {
    debugLog(`[gameSession.ts] processPlayerAction: Starting for action: "${action.substring(0, 50)}..." on snapshot ${snapshot.id}`);

    if (!snapshot || !card) {
      errorLog('[gameSession.ts] processPlayerAction: Snapshot or Card is missing.');
      throw new Error("Cannot process player action: Snapshot and Card are required.");
    }

    const isFirstPlayerAction = snapshot.currentTurn === 0 && snapshot.logs.length === 0;

    const turnResult = await this.turnProcessor.processPlayerTurn(
      snapshot.userId,
      card,
      snapshot.gameState,
      snapshot.logs,
      snapshot.conversationHistory,
      action,
      snapshot.currentTurn,
      useDummyNarrator,
      aiConnections,
      isFirstPlayerAction
    );

    debugLog('[gameSession.ts] processPlayerAction: Calling snapshotUpdater to apply turn result.');
    const newSnapshot = this.snapshotUpdater.applyTurnResultToSnapshot(snapshot, {
      ...turnResult,
      playerAction: action,
    });

    debugLog(`[gameSession.ts] processPlayerAction: new snapshot ${newSnapshot.id} created.`);
    return newSnapshot;
  }

  public renameWorldCategory(snapshot: GameSnapshot, oldName: string, newName: string): GameSnapshot {
    return this.snapshotUpdater.applyCategoryRename(snapshot, oldName, newName);
  }

  public renameWorldEntity(snapshot: GameSnapshot, category: string, oldName: string, newName: string): GameSnapshot {
    return this.snapshotUpdater.applyEntityRename(snapshot, category, oldName, newName);
  }

  public deleteWorldCategory(snapshot: GameSnapshot, category: string): GameSnapshot {
    return this.snapshotUpdater.applyCategoryDelete(snapshot, category);
  }

  public deleteWorldEntity(snapshot: GameSnapshot, category: string, entity: string): GameSnapshot {
    return this.snapshotUpdater.applyEntityDelete(snapshot, category, entity);
  }

  public editWorldKeyValue(snapshot: GameSnapshot, key: string, value: any): GameSnapshot {
    return this.snapshotUpdater.applyKeyValueEdit(snapshot, key, value);
  }

  public deleteWorldKey(snapshot: GameSnapshot, key: string): GameSnapshot {
    return this.snapshotUpdater.applyKeyDelete(snapshot, key);
  }

  public toggleWorldStatePin(snapshot: GameSnapshot, keyPath: string, type: 'variable' | 'entity' | 'category'): GameSnapshot {
    return this.snapshotUpdater.applyPinToggle(snapshot, keyPath, type);
  }
}

@@END_FILE@@
@@FILE: src/logic/gameSessionServices.ts
// src/logic/gameSessionServices.ts
import { GameStateManager } from './GameStateManager.ts';
import { SnapshotUpdater } from './SnapshotUpdater.ts'; // CORRECTED
import { TurnProcessor } from './TurnProcessor.ts';
import { aiClient } from './aiClient.ts';
import { logManager } from './logManager.ts';
import { promptBuilder } from './promptBuilder.ts';

// Instantiate all the core logic services here to be used by GameSession
const gameStateManager = new GameStateManager();
export const snapshotUpdater = new SnapshotUpdater(gameStateManager);
export const turnProcessor = new TurnProcessor(aiClient, promptBuilder, logManager);
@@END_FILE@@
@@FILE: src/logic/logManager.ts
// src/logic/logManager.ts

import { DELTA_MARKER } from './deltaParser'; // Import DELTA_MARKER
import type { 
  AiSettings, 
  ParsedNarrationOutput, 
  LogEntry,
  DeltaMap,
  DigestLine, 
  TokenSummary, 
  LogErrorFlag 
} from '../models';

/**
 * Interface defining the contract for the Log Manager.
 */
export interface ILogManager {
 /**
  * Assembles a complete LogEntry for a single turn of the game.
  * This centralizes the logic from TurnLogAssembler and DigestManager.addParsedLines.
  * @param params An object containing all necessary data for the log entry.
  * @returns A fully constructed LogEntry object.
  */
 assembleTurnLogEntry(params: {
  turnNumber: number;
  userInput: string;
  rawNarratorOutput: string;
  parsedOutput: ParsedNarrationOutput; // Output from deltaParser.ts
  contextSnapshot: string; // The full prompt string sent to AI
  tokenUsage: TokenSummary | null;
  aiSettings: AiSettings; // The AI settings used for this turn
  apiRequestBody: string | null;
  apiResponseBody: string | null;
  apiUrl: string | null;
  latencyMs: number | null;
  modelSlugUsed: string;
 }): LogEntry;

 /**
  * Infers digest lines from deltas if no explicit digest was provided by the AI.
  * Replicates logic from DigestManager.addParsedLines.
  * @param deltas The map of DeltaInstruction objects.
  * @param prose Optional: the prose of the turn, for extracting first line as digest.
  * @returns An array of inferred DigestLine objects.
  */
 inferDigestLinesFromDeltas(deltas: DeltaMap, prose?: string): DigestLine[];
}

/**
 * Concrete implementation of ILogManager.
 */
class LogManager implements ILogManager {

 inferDigestLinesFromDeltas(deltas: DeltaMap, prose?: string): DigestLine[] {
  const inferredDigests: DigestLine[] = [];

  if (Object.keys(deltas).length === 0) {
   return inferredDigests;
  }

  for (const rawKey in deltas) {
   const instruction = deltas[rawKey];
   let score = 1; // Default low importance

   // Logic from DigestManager.addParsedLines to infer importance
   if (rawKey.startsWith("player.")) {
    score = 5; // Player-related changes are critical
   } else if (rawKey.startsWith("world.")) {
    score = 5; // World-related changes are critical
   } else if (rawKey.includes(".flags.")) {
    score = 4;
   } else if (rawKey.includes(".status")) {
    score = 3;
   } else if (rawKey.startsWith("+") || rawKey.startsWith("!")) {
    score = 2; // Add or Declare operations
   }

   // Logic from DeltaInstruction.toLogValue() for summary text
   let summaryText = `Unknown delta operation: ${rawKey}`;
   if (instruction.op === 'assign') {
    summaryText = `Set ${instruction.key} = ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'add') {
    summaryText = `Added to ${instruction.key}: ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'declare') {
    // Inferred tag logic, similar to DigestManager
    let taggableKey = instruction.key;
    const pathParts = instruction.key.split(".");
    if (pathParts.length >= 2) {
      const entity = pathParts[1];
      // Infer if this is a character or location declaration for a summary
      const valueAsObject = instruction.value as Record<string, any>;
      if (valueAsObject && (valueAsObject.tag === "character" || valueAsObject.tag === "location")) {
        taggableKey = (valueAsObject.tag === "character" ? "#" : "@") + entity;
      }
    }
    summaryText = `Declared ${taggableKey} as ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'delete') {
    summaryText = `Removed ${instruction.key}`;
   }

  const tags = this.extractTags(summaryText); // Extract tags from the generated summary
    // MODIFIED: Use `importance: score` to match the DigestLine model
   inferredDigests.push({ text: summaryText, importance: score, tags });
  }

  // Optional prose line extraction from DigestManager.addParsedLines
  if (prose && prose.trim().length > 10) {
   const firstLine = prose.trim().split(/[.!?\n]/).find(line => line.trim().length > 10)?.trim();
   if (firstLine) {
    const tags = this.extractTags(firstLine);
      // MODIFIED: Use `importance: 3`
    inferredDigests.push({ text: firstLine, importance: 3, tags });
   }
  }

  // Assign consistent turn number AFTER all are collected
  // MODIFIED: Remove turn property, as it's not in the DigestLine model. It's part of the parent LogEntry.
  return inferredDigests;
}

 private extractTags(text: string): string[] {
  const tagPattern = /[#@$][a-zA-Z0-9_]+/g; // Global flag to find all matches
  const matches = text.match(tagPattern);
  return matches || [];
 }

 assembleTurnLogEntry(params: {
  turnNumber: number;
  userInput: string;
  rawNarratorOutput: string;
  parsedOutput: ParsedNarrationOutput;
  contextSnapshot: string;
  tokenUsage: TokenSummary | null;
  aiSettings: AiSettings;
  apiRequestBody: string | null;
  apiResponseBody: string | null;
  apiUrl: string | null;
  latencyMs: number | null;
  modelSlugUsed: string;
 }): LogEntry {
  const now = new Date().toISOString();
  const {
   turnNumber, userInput, rawNarratorOutput, parsedOutput,
   contextSnapshot, tokenUsage, aiSettings, apiRequestBody,
   apiResponseBody, apiUrl, latencyMs, modelSlugUsed
  } = params;

  let digestLines: DigestLine[] = parsedOutput.digestLines || [];
  if (digestLines.length === 0 && parsedOutput.deltas) {
   // If AI didn't provide digest, infer from deltas
   digestLines = this.inferDigestLinesFromDeltas(parsedOutput.deltas, parsedOutput.prose);
  }
  // Ensure correct turn number for inferred digests
  //digestLines = digestLines.map(d => ({ ...d, turn: turnNumber }));


  const errorFlags: LogErrorFlag[] = [];
  // Basic error checking (can be expanded)
  if (!parsedOutput.prose) {
   errorFlags.push('MISSING_PROSE');
  }
  // Now using DELTA_MARKER imported from deltaParser
  if (parsedOutput.deltas && Object.keys(parsedOutput.deltas).length === 0 && rawNarratorOutput.includes(DELTA_MARKER)) {
    // If the delta marker was present but no deltas were parsed
    errorFlags.push('INVALID_JSON_DELTA');
  }
  if (!tokenUsage || tokenUsage.totalTokens <= 0) {
   errorFlags.push('INVALID_TOKEN_USAGE');
  }
  // Add more validation based on your `LogErrorFlag` enum/sealed class
  // e.g., if (rawNarratorOutput.length < 50) { errorFlags.push('AI_RESPONSE_TOO_SHORT'); }


  return {
   turnNumber: turnNumber,
   timestamp: now,
   userInput: userInput,
   narratorOutput: rawNarratorOutput,
   prose: parsedOutput.prose, // ADDED: Save the clean prose here
   digestLines: digestLines, // Now an array
   deltas: parsedOutput.deltas,
   contextSnapshot: contextSnapshot,
   tokenUsage: tokenUsage,
   apiRequestBody: apiRequestBody,
   apiResponseBody: apiResponseBody,
   apiUrl: apiUrl,
   latencyMs: latencyMs,
   aiSettings: aiSettings,
   errorFlags: errorFlags,
   modelSlugUsed: modelSlugUsed,
  };
 }
}

export const logManager = new LogManager();
@@END_FILE@@
@@FILE: src/logic/promptBuilder.ts
// src/logic/promptBuilder.ts
import type { PromptCard, GameState, LogEntry, Message } from '../models';

import type { IContextStackAssembler } from './IContextStackAssembler';
import { ContextStackAssembler } from './ContextStackAssembler';
import { debugLog } from '../utils/debug';

export interface IPromptBuilder {
  buildFirstTurnPrompt(card: PromptCard): Message[]; // Deprecated but retained
  buildEveryTurnPrompt(
    card: PromptCard,
    currentGameState: GameState,
    logEntries: LogEntry[],
    conversationHistory: Message[],
    currentUserAction: string,
    isFirstPlayerAction: boolean
  ): Message[];
}

export class PromptBuilder implements IPromptBuilder {
  private stackAssembler: IContextStackAssembler;

  constructor() {
    this.stackAssembler = new ContextStackAssembler();
  }

  private buildCommonPromptParts(card: PromptCard): Message[] {
    const messages: Message[] = [];
    messages.push({ role: "system", content: `## Core Scenario / Persona\n${card.prompt}` });
    if (card.gameRules) messages.push({ role: "system", content: `\n## Game Rules\n${card.gameRules}` });
    if (card.emitSkeleton) messages.push({ role: "system", content: `\n## AI Output Structure Rules\n${card.emitSkeleton}` });
    if (card.functionDefs) messages.push({ role: "system", content: `\n## Available Functions (JSON)\n\`\`\`json\n${card.functionDefs}\n\`\`\`` });
    return messages;
  }

  public buildFirstTurnPrompt(card: PromptCard): Message[] {
    // Deprecated but preserved for compatibility
    const messages = this.buildCommonPromptParts(card);
    if (card.worldStateInit) messages.push({ role: "system", content: `\n## Initial World State (JSON)\n\`\`\`json\n${card.worldStateInit}\n\`\`\`` });
    if (card.firstTurnOnlyBlock) messages.push({ role: "system", content: `\n## First Turn Specifics\n${card.firstTurnOnlyBlock}` });
    return messages;
  }

  public buildEveryTurnPrompt(
    card: PromptCard,
    currentGameState: GameState,
    logEntries: LogEntry[],
    conversationHistory: Message[],
    currentUserAction: string,
    isFirstPlayerAction: boolean
  ): Message[] {
    const messages = this.buildCommonPromptParts(card);

    if (isFirstPlayerAction) {
      // Initial player action after game setup
      if (card.worldStateInit) {
        messages.push({ role: "system", content: `\n## Initial World State (JSON)\n\`\`\`json\n${card.worldStateInit}\n\`\`\`` });
      }
      if (card.firstTurnOnlyBlock) {
        messages.push({ role: "system", content: `\n## Initial Scene & Player Objective\n${card.firstTurnOnlyBlock}` });
      }
    } else {
      // Subsequent turns
      const dynamicContextMessages = this.stackAssembler.assembleContext(
        card,
        currentGameState,
        logEntries
      );
      messages.push(...dynamicContextMessages);
      messages.push(...conversationHistory);
    }

    messages.push({ role: "user", content: currentUserAction });

    debugLog("[PromptBuilder] Final messages sent to AI:", messages);

    return messages;
  }
}

export const promptBuilder = new PromptBuilder();

@@END_FILE@@
@@FILE: src/main.tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css';

// Import the new provider that encapsulates GameSession creation and store initialization
import { GameSessionAndStoreProvider } from './providers/GameSessionAndStoreProvider.tsx';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    {/* Wrap App with the provider */}
    <GameSessionAndStoreProvider>
      <App />
    </GameSessionAndStoreProvider>
  </React.StrictMode>,
);
@@END_FILE@@
@@FILE: src/models/AiConnection.ts
// src/models/AiConnection.ts

/**
 * Represents the configuration for a connection to an AI service.
 * Aligns with Android's AiConnection class.
 */
export interface AiConnection {
  id: string; // Unique ID for this connection
  displayName: string; // User-friendly name for the connection (e.g., "My OpenAI Key")
  modelName: string; // The full name of the model (e.g., "GPT-4 Turbo")
  modelSlug: string; // The API identifier for the model (e.g., "gpt-4-turbo", "deepseek-coder")
  apiUrl: string; // The base URL for the API (e.g., "https://api.openai.com/v1/")
  apiToken: string; // The user's API key (sensitive)
  functionCallingEnabled: boolean; // Whether this connection supports/uses function calling
  userAgent?: string | null; // Optional: User-Agent string for API calls (from Android)

  // Metadata
  createdAt: string; // ISO 8601 string
  lastUpdated: string; // ISO 8601 string
}
@@END_FILE@@
@@FILE: src/models/DeltaInstruction.ts
// src/models/DeltaInstruction.ts

/**
 * Represents a single instruction to modify the game world state, as per DeltaInstruction.kt.
 * This is a pure data definition, without logic or companion methods.
 * Corresponds to a discriminated union in TypeScript for Kotlin's sealed class.
 *
 * `value: any` corresponds to Kotlin's `JsonElement`, allowing any valid JSON value (string, number, boolean, object, array, null).
 */

export type DeltaInstruction =
  | { op: 'add'; key: string; value: any }      // Corresponds to Add data class
  | { op: 'assign'; key: string; value: any }   // Corresponds to Assign data class
  | { op: 'declare'; key: string; value: any }  // Corresponds to Declare data class
  | { op: 'delete'; key: string };              // Corresponds to Delete data class (no value)

// Helper type for the map of deltas
export type DeltaMap = { [fullKey: string]: DeltaInstruction };
@@END_FILE@@
@@FILE: src/models/GameSnapshot.ts
// src/models/GameSnapshot.ts

import type { GameState, LogEntry, Message } from './index';

/**
 * Represents a full, self-contained snapshot of a game session.
 * This is the primary object for saving and loading games.
 * Based on `StoryForgeViewModel.buildSnapshot()`.
 */
export interface GameSnapshot {
  // --- Core Identifiers ---
  id: string; // Unique ID for this snapshot/game session
  gameId: string; 
  userId: string;
  promptCardId: string; // ID of the card used
  title: string; // NEW: A human-readable title for the saved game

  // --- Timestamps ---
  createdAt: string; // When the game session was started
  updatedAt: string; // When this snapshot was last saved

  // --- Core Game State ---
  currentTurn: number;
  gameState: GameState; // Contains worldState, scene, narration
  conversationHistory: Message[]; // Full user/assistant conversation history

  // --- Logs for Context & Debugging ---
  // Note: All "digests" are now just part of the logs.
  // We extract them for context building, but don't store them separately.
  logs: LogEntry[];

  // --- UI Preferences (Persisted with Snapshot) ---
  worldStatePinnedKeys: string[]; // Stores full variable paths, e.g., "npcs.#fox.hp"
}
@@END_FILE@@
@@FILE: src/models/GameState.ts
// src/models/GameState.ts

/**
 * Represents the current scene's location and present entities.
 * Corresponds to the state managed by SceneManager.
 */
export interface SceneState {
  location: string | null;
  present: string[]; // List of entity keys, e.g., ["player.#you", "npcs.#fox"]
}

/**
 * Defines the core mutable state of the game.
 * All game variables (like HP, gold) are expected to be dynamic and reside within `worldState`.
 */
export interface GameState {
  narration: string;
  worldState: Record<string, any>; // The dynamic game world
  scene: SceneState; // The current scene state
}
@@END_FILE@@
@@FILE: src/models/LogEntry.ts
// src/models/LogEntry.ts

import type { DeltaMap, DigestLine, TokenSummary, LogErrorFlag, AiSettings } from './index';

/**
 * Canonical structured log for a single turn or significant event in the game.
 * Corresponds to TurnLogEntry.kt, enhanced with insights from DigestManager.
 */
export interface LogEntry {
 turnNumber: number;
 timestamp: string;

 userInput: string;
 narratorOutput: string; // The raw, full output from the AI
 prose: string; 

 digestLines: DigestLine[];
 deltas?: DeltaMap | null;

 contextSnapshot?: string | null;
 tokenUsage?: TokenSummary | null;
 apiRequestBody?: string | null;
 apiResponseBody?: string | null;
 apiUrl?: string | null;
 latencyMs?: number | null;

 aiSettings?: AiSettings | null;
 errorFlags: LogErrorFlag[];
 modelSlugUsed: string;
}
@@END_FILE@@
@@FILE: src/models/LogEntryElements.ts
// src/models/LogEntryElements.ts

/**
 * Represents a single summary line for the digest, as per DigestLine.kt (implied by TurnLogEntry).
 */
export interface DigestLine {
  text: string;
  importance: number; // 1 (minor) to 5 (critical)
  tags?: string[];    // Optional, e.g., for filtering by specific entities
}

/**
 * Summarizes token usage for an AI call, as per TokenSummary.kt (implied by TurnLogEntry).
 */
export interface TokenSummary {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  cachedTokens?: number; // Optional: If some tokens were served from cache
}

/**
 * Represents a flag for a validation error or issue in the log entry.
 * Based on `LogErrorFlag` (implied enum/sealed class from `TurnLogEntry`).
 */
export type LogErrorFlag =
  | 'MISSING_PROSE'
  | 'MISSING_DELTAS'
  | 'INVALID_JSON_DELTA'
  | 'INVALID_TOKEN_USAGE'
  | 'AI_RESPONSE_TOO_SHORT'
  | 'AI_RESPONSE_TOO_LONG'
  | 'UNEXPECTED_AI_FORMAT'
  | 'API_ERROR'
  | 'UNKNOWN_ERROR';
// Add more flags as needed based on your LogErrorFlag enum/sealed class if it exists.
@@END_FILE@@
@@FILE: src/models/Message.ts
// src/models/Message.ts

/**
 * Represents a single message in a conversation with the AI.
 * Corresponds to Message.kt.
 */
export interface Message {
  role: 'system' | 'user' | 'assistant';
  content: string;
}
@@END_FILE@@
@@FILE: src/models/ParsedNarrationOutput.ts
// src/models/ParsedNarrationOutput.ts

import type { DeltaMap, DigestLine} from './index';

/**
 * Represents the structured data extracted from a raw AI narrator response.
 * Corresponds to `NarrationParser.ParsedNarration` from the old project.
 *
 * @param prose The clean, human-readable narrative text.
 * @param deltas A map of world state changes to apply.
 * @param digestLines An array of summary lines.
 * @param scene A flexible JSON object describing the current scene (location, present characters, etc.).
 */
export interface ParsedNarrationOutput {
  prose: string;
  deltas: DeltaMap;
  digestLines: DigestLine[];
  scene?: Record<string, any> | null; // Corresponds to the JsonObject? for the @scene block
}
@@END_FILE@@
@@FILE: src/models/PromptCard.ts
// src/models/PromptCard.ts

import type { StackInstructions} from './index';
/**
 * Defines the configuration settings for an AI connection.
 * These fields are embedded directly within PromptCard.
 * This is a pure data definition, without logic or companion methods.
 */
export interface AiSettings {
  selectedConnectionId: string;
  temperature: number;
  topP: number;
  maxTokens: number;
  presencePenalty: number;
  frequencyPenalty: number;
  functionCallingEnabled: boolean;
  streaming: boolean; 
}

/**
 * A self-contained prompt card that can be submitted to the AI to configure tone, rules, or scenario.
 * This version consolidates AiSettings and uses a structured StackInstructions object.
 * This is a pure data definition, with no default values or logic.
 */
export interface PromptCard {
  id: string;
  rootId: string;
  parentId: string | null; // Null for root cards
  contentHash: string; // Hash of significant content fields to detect duplicates
  title: string;
  description: string | null; // Optional in Kotlin, so `string | null`
  prompt: string;
  firstTurnOnlyBlock: string;
  stackInstructions: StackInstructions; // Now a structured object
  emitSkeleton: string;      // JSON string
  worldStateInit: string;    // JSON string
  gameRules: string;
  aiSettings: AiSettings;
  helperAiSettings: AiSettings;
  isHelperAiEnabled: boolean; // NEW: Controls whether helper AI is considered active
  tags: string[];            // Kotlin `List<String>` maps to `string[]`
  isExample: boolean;        // From Kotlin `isExample`
  functionDefs: string;      // JSON string
  historyBrowsingEnabled: boolean;
  isPublic: boolean;
  createdAt: string; // ISO 8601 string
  updatedAt: string; // ISO 8601 string
  ownerId: string;   // Firebase User UID
}

/**
 * Represents the raw data needed when creating or updating a PromptCard.
 * This does not include generated fields like IDs, hashes, timestamps, or ownerId,
 * nor does it specify default values for optional fields.
 */
export interface NewPromptCardData {
  title: string;
  prompt: string;
  description?: string | null;
  firstTurnOnlyBlock?: string;
  // This is kept as 'string | StackInstructions' to allow raw JSON string input,
  // with parsing logic to convert it to StackInstructions handled elsewhere (e.g., in logic/cardManager or data repository).
  stackInstructions?: string | StackInstructions;
  emitSkeleton?: string;
  worldStateInit?: string;
  gameRules?: string;
  aiSettings?: AiSettings; // Changed from AiSettingsInCard to AiSettings for consistency
  helperAiSettings?: AiSettings; // Changed from AiSettingsInCard to AiSettings for consistency
  isHelperAiEnabled?: boolean; // NEW: Optional for new card data
  tags?: string[];
  isExample?: boolean;
  functionDefs?: string;
  isPublic?: boolean;
  historyBrowsingEnabled?: boolean;
}
@@END_FILE@@
@@FILE: src/models/StackInstructions.ts
// src/models/StackInstructions.ts

/**
 * Defines the mode for including a stack element.
 * Now an enum to allow runtime access (e.g., Object.values).
 */
export enum StackMode {
  ALWAYS = 'always',
  FIRST_N = 'firstN',
  AFTER_N = 'afterN',
  NEVER = 'never',
  FILTERED = 'filtered', // Added if 'filtered' applies to modes
}

/**
 * Defines the filtering strategy for a stack element.
 * Now an enum to allow runtime access.
 */
export enum FilterMode {
  NONE = 'none',
  SCENE_ONLY = 'sceneOnly',
  TAGGED = 'tagged',
}

/**
 * Defines a policy for including prose or other list-based context.
 * Corresponds to `ProsePolicy`.
 */
export interface ProsePolicy {
  mode: StackMode; // Use the enum
  n: number;
  filtering: FilterMode; // Use the enum
  enabled?: boolean; // NEW: Added for toggling the entire section
}

/**
 * Defines a rule for emitting digest lines based on their importance score.
 * Corresponds to `EmissionRule`.
 */
export interface EmissionRule {
  mode: StackMode; // Use the enum
  n: number;
}

/**
 * Defines the policy for filtering digest lines.
 * Corresponds to `DigestFilterPolicy`.
 */
export interface DigestFilterPolicy {
  filtering: FilterMode; // Use the enum
  enabled?: boolean; // NEW: Added for toggling the entire section
}

/**
 * Defines the policy for token usage and fallback strategies.
 * Corresponds to `TokenPolicy`.
 */
export interface TokenPolicy {
  minTokens: number;
  maxTokens: number;
  fallbackPlan: string[];
}

/**
 * The full, structured stack instructions for a PromptCard.
 * Corresponds to `StackInstructions.kt`.
 */
export interface StackInstructions {
  narratorProseEmission: ProsePolicy;
  digestPolicy: DigestFilterPolicy;
  digestEmission: Record<number, EmissionRule>; // Map<Int, EmissionRule> -> Record<number, EmissionRule>

  expressionLogPolicy: ProsePolicy;
  expressionLinesPerCharacter: number;
  emotionWeighting: boolean;

  worldStatePolicy: ProsePolicy;
  knownEntitiesPolicy: ProsePolicy;

  // REMOVED: outputFormat: string; // This field is being removed
  tokenPolicy: TokenPolicy;
}
@@END_FILE@@
@@FILE: src/models/index.ts
// src/models/index.ts

// Re-export all models for easier importing
export * from './AiConnection';
export * from './DeltaInstruction';
export * from './GameSnapshot';
export * from './GameState.ts';
export * from './LogEntry';
export * from './LogEntryElements';
export * from './Message';
export * from './ParsedNarrationOutput';
export * from './PromptCard';
export * from './StackInstructions';
@@END_FILE@@
@@FILE: src/pages/SourceDump.tsx
//SourceDump.tsx
import React, { useEffect, useState } from 'react';

const SourceDump: React.FC = () => {
  const [code, setCode] = useState<string>('Loading...');

  useEffect(() => {
    fetch('/source-dump.txt')
      .then(res => res.text())
      .then(text => setCode(text))
      .catch(err => setCode('Error loading source dump: ' + err));
  }, []);

  return (
    <pre style={{
      whiteSpace: 'pre-wrap',
      background: '#1e1e1e',
      color: '#d4d4d4',
      padding: '1rem',
      overflowX: 'auto'
    }}>
      {code}
    </pre>
  );
};

export default SourceDump;

@@END_FILE@@
@@FILE: src/providers/GameSessionAndStoreProvider.tsx
import React, { useRef } from 'react';
import { GameSession } from '../logic/gameSession';
import type { IGameSession } from '../logic/gameSession';
import { initializeGameStateStore } from '../state/useGameStateStore';
import { GameSessionProvider } from '../contexts/GameSessionContext';
// Centralized stateless services
import { turnProcessor, snapshotUpdater } from '../logic/gameSessionServices';

interface GameSessionAndStoreProviderProps {
  children: React.ReactNode;
}

export const GameSessionAndStoreProvider: React.FC<GameSessionAndStoreProviderProps> = ({ children }) => {
  const gameSessionServiceRef = useRef<IGameSession | null>(null);

  if (!gameSessionServiceRef.current) {
    console.log(
      '%c[GameSessionAndStoreProvider.tsx] Instantiating STATELESS GameSession service and initializing GameStateStore.',
      'color: blue; font-weight: bold;'
    );

    gameSessionServiceRef.current = new GameSession(turnProcessor, snapshotUpdater);
    initializeGameStateStore(gameSessionServiceRef.current);
  } else {
    console.log('[GameSessionAndStoreProvider.tsx] Re-rendering; GameSession service already instantiated.');
  }

  return (
    <GameSessionProvider gameSession={gameSessionServiceRef.current}>
      {children}
    </GameSessionProvider>
  );
};

@@END_FILE@@
@@FILE: src/state/useAuthStore.ts
// src/state/useAuthStore.ts

import { create } from 'zustand';
import { type User } from 'firebase/auth'; // Import Firebase User type
import { subscribeToAuthChanges, signInWithGoogle, signOutUser } from '../data/repositories/authRepository'; // Import auth functions
import { debugLog, errorLog } from '../utils/debug';

// Define the shape of our authentication state
interface AuthState {
  user: User | null; // The current authenticated user or null
  isLoading: boolean; // True while checking initial auth state
  error: string | null; // Any error during auth operations

  // Actions
  // These are not directly implemented here, but exposed for components to call
  signIn: () => Promise<void>;
  signOut: () => Promise<void>;
}

// Create the Zustand store
export const useAuthStore = create<AuthState>((set, get) => ({
  user: null, // Initial state: no user
  isLoading: true, // Initially loading to check auth state
  error: null, // No error initially

  // Action to handle sign-in
  signIn: async () => {
    debugLog('[useAuthStore.ts] signIn action called.');
    set({ error: null }); // Clear previous errors
    try {
      await signInWithGoogle();
      // The onAuthStateChanged listener will update the 'user' state,
      // so we don't need to manually set it here based on the signIn result.
    } catch (err: any) {
      console.error("[useAuthStore.ts] AuthStore signIn error:", err);
      set({ error: err.message || "Failed to sign in." });
    }
  },

  // Action to handle sign-out
  signOut: async () => {
    debugLog('[useAuthStore.ts] signOut action called.');
    set({ error: null }); // Clear previous errors
    try {
      await signOutUser();
    } catch (err: any) {
      console.error("[useAuthStore.ts] AuthStore signOut error:", err);
      set({ error: err.message || "Failed to sign out." });
    }
  },
}));

// --- Initialize and Subscribe to Auth Changes ---
// This part ensures our store's 'user' state is always in sync with Firebase Auth.
// It runs only once when the module is loaded.
const unsubscribe = subscribeToAuthChanges((user) => {
  // DEBUG: Log exact auth state updates
  useAuthStore.setState({ user: user, isLoading: false });
  debugLog(`%c[useAuthStore.ts] Auth State Updated: ${user ? user.uid : "No user"}, IsLoading: false`, 'color: brown;');
});

// Optional: You might want to handle unsubscription if your app could unmount this module,
// but for a core global store, it often lives for the app's lifetime.
// If you were to integrate this into a React component's useEffect, you'd return the unsubscribe function.
// For a global store, we typically let it live.
@@END_FILE@@
@@FILE: src/state/useGameStateStore.ts
// src/state/useGameStateStore.ts
import { create } from 'zustand';
import type { GameSnapshot, GameState, LogEntry, Message } from '../models';
import type { IGameSession } from '../logic/gameSession';
import { useSettingsStore } from './useSettingsStore';
import { usePromptCardStore } from './usePromptCardStore';
import { promptCardRepository } from '../data/repositories/promptCardRepository';
import { debugLog, errorLog } from '../utils/debug';
import { produce } from 'immer';
import { gameRepository } from '../data/repositories/gameRepository';
import { aiConnectionRepository } from '../data/repositories/aiConnectionRepository';

// External GameSession service instance
let _gameSessionService: IGameSession | null = null;

export const initializeGameStateStore = (gameSession: IGameSession) => {
  if (_gameSessionService === null) {
    _gameSessionService = gameSession;
    debugLog('%c[useGameStateStore.ts] GameSession service injected successfully.', 'color: green;');
  }
};

interface GameStateState {
  currentSnapshot: GameSnapshot | null;
  maxTurn: number | null;
  narratorInputText: string;
  narratorScrollPosition: number;
  gameError: string | null;
  gameLoading: boolean;
  isProcessingTurn: boolean;
}

interface GameStateActions {
  initializeGame: (userId: string, cardId: string, existingSnapshotId?: string) => Promise<void>;
  processPlayerAction: (action: string) => Promise<void>;
  loadGame: (userId: string, snapshotId: string) => Promise<void>;
  loadLastActiveGame: (userId: string) => Promise<boolean>;
  updateNarratorInputText: (text: string) => void;
  updateNarratorScrollPosition: (position: number) => void;
  renameWorldCategory: (oldName: string, newName: string) => Promise<void>;
  renameWorldEntity: (category: string, oldName: string, newName: string) => Promise<void>;
  deleteWorldCategory: (category: string) => Promise<void>;
  deleteWorldEntity: (category: string, entity: string) => Promise<void>;
  editWorldKeyValue: (key: string, value: any) => Promise<void>;
  deleteWorldKey: (key: string) => Promise<void>;
  toggleWorldStatePin: (keyPath: string, type: 'variable' | 'entity' | 'category') => Promise<void>;
  reset: () => void;
  processTurn: (action: string) => Promise<void>;
  navigateToTurn: (turnNumber: number) => Promise<void>;
}

type GameStateStore = GameStateState & GameStateActions;

const initialState: GameStateState = {
  currentSnapshot: null,
  narratorInputText: '',
  narratorScrollPosition: 0,
  gameError: null,
  gameLoading: false,
  isProcessingTurn: false,
  maxTurn: null, 
};

export const useGameStateStore = create<GameStateStore>((set, get) => {
  const getGameService = (): IGameSession => {
    if (!_gameSessionService) {
      throw new Error("GameSession service has not been initialized in the store.");
    }
    return _gameSessionService;
  };

  const updateSnapshotAndPersist = async (newSnapshot: GameSnapshot | null) => {
    if (!newSnapshot) {
      set({ currentSnapshot: null });
      return;
    }
    set({ currentSnapshot: newSnapshot });
    try {
      await gameRepository.saveGameSnapshot(newSnapshot.userId, newSnapshot);
      debugLog(`[useGameStateStore] Persisted snapshot ${newSnapshot.id}`);
    } catch (e: any) {
      errorLog("[useGameStateStore] Failed to persist snapshot:", e);
      set({ gameError: "Failed to save game progress." });
    }
  };

  const performWorldStateUpdate = async (
    updateFn: (service: IGameSession, snapshot: GameSnapshot) => GameSnapshot
  ) => {
    const currentState = get().currentSnapshot;
    if (!currentState) {
      set({ gameError: "No active game to update." });
      return;
    }
    set({ gameError: null });
    try {
      const service = getGameService();
      const updatedSnapshot = updateFn(service, currentState);
      await updateSnapshotAndPersist(updatedSnapshot);
    } catch (error: any) {
      errorLog("[useGameStateStore] Error during world state update:", error);
      set({ gameError: error.message });
    }
  };

  return {
    ...initialState,

    initializeGame: async (userId, cardId, existingSnapshotId) => {
      set({ gameLoading: true, gameError: null, currentSnapshot: null });
      try {
        if (existingSnapshotId) {
          await get().loadGame(userId, existingSnapshotId);
        } else {
          const card = await promptCardRepository.getPromptCard(userId, cardId);
          if (!card) throw new Error(`PromptCard with ID ${cardId} not found.`);
          usePromptCardStore.getState().setActivePromptCard(card);
          const service = getGameService();
          const initialSnapshot = service.initializeGame(userId, card);
          await updateSnapshotAndPersist(initialSnapshot);
        }
      } catch (error: any) {
        errorLog("[useGameStateStore] initializeGame action ERROR:", error);
        set({ gameError: error.message });
      } finally {
        set({ gameLoading: false });
      }
    },

    processPlayerAction: async (action) => {
      const snapshot = get().currentSnapshot;
      const card = usePromptCardStore.getState().activePromptCard;
      const maxTurn = get().maxTurn; // Get maxTurn from state

      if (!snapshot || !card) {
        set({ gameError: "Cannot process action: Game or Prompt Card not loaded." });
        return;
      }

      // DESTRUCTIVE RESUME LOGIC
      if (maxTurn !== null && snapshot.currentTurn < maxTurn) {
        const confirmed = window.confirm(
          "You are about to resume from an earlier point. This will delete all future turns from your previous timeline. This cannot be undone. Are you sure?"
        );
        if (!confirmed) {
          return; // User cancelled
        }
        // Tell the repository to delete the obsolete future turns
        await gameRepository.deleteFutureTurns(snapshot.userId, snapshot.gameId, snapshot.currentTurn);
      }

      set({ isProcessingTurn: true, gameError: null, narratorInputText: '' });
      const useDummyNarrator = useSettingsStore.getState().useDummyNarrator;
      try {
        const aiConnections = await aiConnectionRepository.getAiConnections(snapshot.userId);
        const service = getGameService();
        // The service returns a new snapshot with turn number incremented
        const processedSnapshot = await service.processPlayerAction(
          snapshot, card, action, useDummyNarrator, aiConnections
        );
        
        // Overwrite the ID to follow our new convention
        const finalSnapshot = {
          ...processedSnapshot,
          id: `${processedSnapshot.gameId}-${processedSnapshot.currentTurn}`
        };

        await updateSnapshotAndPersist(finalSnapshot);
        // After persisting, update the maxTurn to the current turn
        set({ maxTurn: finalSnapshot.currentTurn });

      } catch (error: any) {
        errorLog("[useGameStateStore] processPlayerAction action ERROR:", error);
        set({ gameError: error.message });
      } finally {
        set({ isProcessingTurn: false });
      }
    },

    loadGame: async (userId, gameId) => { // This now receives a gameId
      set({ gameLoading: true, gameError: null });
      try {
        const timeline = await gameRepository.getGameTimeline(userId, gameId);
        if (timeline.length === 0) throw new Error(`Game ${gameId} not found.`);
        
        const latestSnapshot = timeline[timeline.length - 1];
        const card = await promptCardRepository.getPromptCard(userId, latestSnapshot.promptCardId);
        if (!card) throw new Error(`PromptCard for game could not be found.`);

        usePromptCardStore.getState().setActivePromptCard(card);
        set({
          currentSnapshot: latestSnapshot,
          maxTurn: latestSnapshot.currentTurn, // Max turn is the turn number of the latest snapshot
          gameLoading: false,
        });
      } catch (error: any) {
        errorLog("[useGameStateStore] loadGame action ERROR:", error);
        set({ gameError: error.message, gameLoading: false });
      }
    },

    // ADD NEW ACTION: navigateToTurn
    navigateToTurn: async (turnNumber: number) => {
      const snapshot = get().currentSnapshot;
      if (!snapshot) return;

      set({ gameLoading: true, gameError: null });
      try {
        const targetSnapshotId = `${snapshot.gameId}-${turnNumber}`;
        const targetSnapshot = await gameRepository.getGameSnapshot(snapshot.userId, targetSnapshotId);
        if (!targetSnapshot) throw new Error(`Turn ${turnNumber} not found.`);
        
        set({ currentSnapshot: targetSnapshot, gameLoading: false });
      } catch(e: any) {
        set({ gameError: e.message, gameLoading: false });
      }
    },

    loadLastActiveGame: async (userId: string): Promise<boolean> => {
      set({ gameLoading: true, gameError: null });
      try {
        const allSnapshots = await gameRepository.getAllGameSnapshots(userId);
        if (allSnapshots.length > 0) {
          await get().loadGame(userId, allSnapshots[0].id);
          return true;
        }
        return false;
      } catch (error: any) {
        errorLog("[useGameStateStore] loadLastActiveGame action FAILED with error:", error);
        set({ gameError: error.message });
        return false;
      } finally {
        set({ gameLoading: false });
      }
    },

    processTurn: (action: string) => {
      return get().processPlayerAction(action);
    },

    updateNarratorInputText: (text) => set({ narratorInputText: text }),
    updateNarratorScrollPosition: (position) => set({ narratorScrollPosition: position }),

    renameWorldCategory: (oldName, newName) =>
      performWorldStateUpdate((s, snap) => s.renameWorldCategory(snap, oldName, newName)),

    renameWorldEntity: (category, oldName, newName) =>
      performWorldStateUpdate((s, snap) => s.renameWorldEntity(snap, category, oldName, newName)),

    deleteWorldCategory: (category) =>
      performWorldStateUpdate((s, snap) => s.deleteWorldCategory(snap, category)),

    deleteWorldEntity: (category, entity) =>
      performWorldStateUpdate((s, snap) => s.deleteWorldEntity(snap, category, entity)),

    editWorldKeyValue: (key, value) =>
      performWorldStateUpdate((s, snap) => s.editWorldKeyValue(snap, key, value)),

    deleteWorldKey: (key) =>
      performWorldStateUpdate((s, snap) => s.deleteWorldKey(snap, key)),

    toggleWorldStatePin: (key, type) =>
      performWorldStateUpdate((s, snap) => s.toggleWorldStatePin(snap, key, type)),

    reset: () => {
      debugLog('%c[useGameStateStore.ts] RESETTING GameStateStore to initialState.', 'color: red; font-weight: bold;');
      set(initialState);
    },
  };
});

// --- Selectors ---
export const selectCurrentGameState = (state: GameStateStore): GameState | null => {
  return state.currentSnapshot?.gameState ?? null;
};

export const selectGameLogs = (state: GameStateStore): LogEntry[] => {
  return state.currentSnapshot?.logs ?? [];
};

export const selectConversationHistory = (state: GameStateStore): Message[] => {
  return state.currentSnapshot?.conversationHistory ?? [];
};

export const selectWorldStatePinnedKeys = (state: GameStateStore): string[] => {
  return state.currentSnapshot?.worldStatePinnedKeys ?? [];
};
@@END_FILE@@
@@FILE: src/state/useLogStore.ts
// src/state/useLogStore.ts

import { create } from 'zustand';
import { LogViewMode } from '../utils/types';
import type { LogEntry } from '../models';
import { debugLog } from '../utils/debug';

const initialState = {
  logEntries: [] as LogEntry[],
  // Default to a useful set of views
  selectedLogViewModes: [LogViewMode.USER_INPUT, LogViewMode.NARRATOR_OUTPUT, LogViewMode.DIGEST_LINES, LogViewMode.DELTAS] as LogViewMode[],
  isLoading: false,
  error: null as string | null,
};

interface LogState {
  logEntries: LogEntry[];
  selectedLogViewModes: LogViewMode[];
  isLoading: boolean;
  error: string | null;
  setLogEntries: (entries: LogEntry[]) => void;
  setSelectedLogViewModes: (modes: LogViewMode[]) => void;
  reset: () => void;
}

export const useLogStore = create<LogState>((set) => ({
  ...initialState,

  setLogEntries: (entries) => set({ logEntries: entries }),

  setSelectedLogViewModes: (modes) => set({ selectedLogViewModes: modes }),

  reset: () => {
    debugLog("Resetting LogStore.");
    set(initialState);
  },
}));
@@END_FILE@@
@@FILE: src/state/usePromptCardStore.ts
// src/state/usePromptCardStore.ts

import { create } from 'zustand';
import type { PromptCard, NewPromptCardData, AiConnection } from '../models'; // Assuming index.ts exports these
import { promptCardManager } from '../logic/cardManager';
import { debugLog, errorLog } from '../utils/debug';
import { aiConnectionRepository } from '../data/repositories/aiConnectionRepository';

const initialState = {
  promptCards: [],
  activePromptCard: null,
  isLoading: false,
  error: null,
};

interface PromptCardState {
  promptCards: PromptCard[];
  activePromptCard: PromptCard | null;
  aiConnections: AiConnection[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchPromptCards: (userId: string) => Promise<void>;
  setActivePromptCard: (card: PromptCard | null) => void;
  addPromptCard: (userId: string, cardData: NewPromptCardData) => Promise<PromptCard | null>;
  updatePromptCard: (userId: string, cardId: string, updates: Partial<PromptCard>) => Promise<PromptCard | null>;
  duplicatePromptCard: (userId: string, cardId: string) => Promise<PromptCard | null>;
  deletePromptCard: (userId: string, cardId: string) => Promise<void>;
  fetchAiConnections: (userId: string) => Promise<void>;
  // Import/Export functionality will go here eventually
  importPromptCards: (userId: string, cards: NewPromptCardData[]) => Promise<PromptCard[]>;
  exportPromptCard: (userId: string, cardId: string) => Promise<PromptCard | null>;
  reset: () => void;
}

export const usePromptCardStore = create<PromptCardState>((set, get) => ({
  promptCards: [],
  activePromptCard: null,
  aiConnections: [],
  isLoading: false,
  error: null,

  fetchPromptCards: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const cards = await promptCardManager.getAllPromptCards(userId);
      set({ promptCards: cards, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error fetching prompt cards:", error);
    }
  },

  setActivePromptCard: (card) => {
    set({ activePromptCard: card });
  },

  addPromptCard: async (userId, cardData) => {
    set({ isLoading: true, error: null });
    try {
      const newCard = await promptCardManager.createNewPromptCard(userId, cardData);
      set((state) => ({
        promptCards: [...state.promptCards, newCard],
        isLoading: false,
      }));
      return newCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error adding prompt card:", error);
      return null;
    }
  },

  updatePromptCard: async (userId, cardId, updates) => {
    set({ isLoading: true, error: null });
    try {
      const updatedCard = await promptCardManager.updatePromptCard(userId, cardId, updates);
      if (updatedCard) {
        set((state) => ({
          promptCards: state.promptCards.map(card => card.id === updatedCard.id ? updatedCard : card),
          activePromptCard: state.activePromptCard?.id === updatedCard.id ? updatedCard : state.activePromptCard,
          isLoading: false,
        }));
      }
      return updatedCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error updating prompt card:", error);
      return null;
    }
  },

  duplicatePromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      const duplicatedCard = await promptCardManager.duplicatePromptCard(userId, cardId);
      if (duplicatedCard) {
        set((state) => ({
          promptCards: [...state.promptCards, duplicatedCard],
          isLoading: false,
        }));
      }
      return duplicatedCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error duplicating prompt card:", error);
      return null;
    }
  },

  deletePromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      await promptCardManager.deletePromptCard(userId, cardId);
      set((state) => ({
        promptCards: state.promptCards.filter(card => card.id !== cardId),
        activePromptCard: state.activePromptCard?.id === cardId ? null : state.activePromptCard,
        isLoading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error deleting prompt card:", error);
    }
  },

  fetchAiConnections: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const connections = await aiConnectionRepository.getAiConnections(userId);
      set({ aiConnections: connections, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error fetching AI connections:", error);
    }
  },

  importPromptCards: async (userId, cards) => {
    set({ isLoading: true, error: null });
    try {
      const imported = await promptCardManager.importPromptCards(userId, cards);
      set((state) => ({
        promptCards: [...state.promptCards, ...imported],
        isLoading: false,
      }));
      return imported;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error importing prompt cards:", error);
      return [];
    }
  },

  exportPromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      const exported = await promptCardManager.exportPromptCard(userId, cardId);
      set({ isLoading: false });
      return exported;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error exporting prompt card:", error);
      return null;
    }
  },

  reset: () => {
    debugLog("Resetting PromptCardStore.");
    set(initialState);
  },
}));
@@END_FILE@@
@@FILE: src/state/useSettingsStore.ts
// src/state/useSettingsStore.ts

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import type { AiConnection } from '../models';
import { generateUuid } from '../utils/uuid';
import { debugLog } from '../utils/debug'; 
import { aiConnectionRepository } from '../data/repositories/aiConnectionRepository';

interface SettingsState {
  aiConnections: AiConnection[];
  selectedConnectionId: string | null;
  isLoadingConnections: boolean;
  connectionsError: string | null;
  useDummyNarrator: boolean;
  themeMode: 'light' | 'dark';
  enableDebugLogging: boolean;              
  textGenerationSpeedMs: number;            

  fetchAiConnections: (userId: string) => Promise<void>;
  addAiConnection: (
    userId: string,
    connection: Omit<AiConnection, 'id' | 'createdAt' | 'lastUpdated'>
  ) => Promise<AiConnection | null>;
  updateAiConnection: (
    userId: string,
    connection: AiConnection
  ) => Promise<AiConnection | null>;
  deleteAiConnection: (userId: string, connectionId: string) => Promise<void>;

  setSelectedConnectionId: (id: string | null) => void;
  setUseDummyNarrator: (enabled: boolean) => void;
  setThemeMode: (mode: 'light' | 'dark') => void;
  setEnableDebugLogging: (enabled: boolean) => void;     
  setTextGenerationSpeedMs: (speed: number) => void;     
  reset: () => void;
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set, get) => ({
      // --- Initial State Values ---
      aiConnections: [],
      selectedConnectionId: null,
      isLoadingConnections: false,
      connectionsError: null,
      useDummyNarrator: false,
      themeMode: 'light',
      enableDebugLogging: false,             
      textGenerationSpeedMs: 20,             

      // --- Actions ---
      fetchAiConnections: async (userId) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const connections = await aiConnectionRepository.getAiConnections(userId);
          set({
            aiConnections: connections,
            isLoadingConnections: false,
            selectedConnectionId: get().selectedConnectionId &&
              connections.some(c => c.id === get().selectedConnectionId)
              ? get().selectedConnectionId
              : (connections.length > 0 ? connections[0].id : null)
          });
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
        }
      },

      addAiConnection: async (userId, newConnectionData) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const newId = generateUuid();
          const now = new Date().toISOString();
          const connection: AiConnection = {
            ...newConnectionData,
            id: newId,
            createdAt: now,
            lastUpdated: now,
          };
          await aiConnectionRepository.saveAiConnection(userId, connection);
          set(state => {
            const updatedConnections = [...state.aiConnections, connection].sort((a, b) =>
              a.displayName.localeCompare(b.displayName)
            );
            return {
              aiConnections: updatedConnections,
              isLoadingConnections: false,
              selectedConnectionId: state.selectedConnectionId || newId,
            };
          });
          return connection;
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          return null;
        }
      },

      updateAiConnection: async (userId, updatedConnection) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const now = new Date().toISOString();
          const connectionToSave = { ...updatedConnection, lastUpdated: now };
          await aiConnectionRepository.saveAiConnection(userId, connectionToSave);
          set(state => {
            const updatedConnections = state.aiConnections.map(conn =>
              conn.id === updatedConnection.id ? connectionToSave : conn
            ).sort((a, b) => a.displayName.localeCompare(b.displayName));
            return {
              aiConnections: updatedConnections,
              isLoadingConnections: false,
            };
          });
          return connectionToSave;
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          return null;
        }
      },

      deleteAiConnection: async (userId, connectionId) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          await aiConnectionRepository.deleteAiConnection(userId, connectionId);
          set(state => {
            const updatedConnections = state.aiConnections.filter(conn => conn.id !== connectionId);
            let newSelectedId = state.selectedConnectionId;
            if (newSelectedId === connectionId) {
              newSelectedId = updatedConnections.length > 0 ? updatedConnections[0].id : null;
            }
            return {
              aiConnections: updatedConnections.sort((a, b) =>
                a.displayName.localeCompare(b.displayName)
              ),
              selectedConnectionId: newSelectedId,
              isLoadingConnections: false,
            };
          });
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
        }
      },

      setSelectedConnectionId: (id) => set({ selectedConnectionId: id }),
      setUseDummyNarrator: (enabled) => set({ useDummyNarrator: enabled }),
      setThemeMode: (mode) => set({ themeMode: mode }),
      setEnableDebugLogging: (enabled) => set({ enableDebugLogging: enabled }), 
      setTextGenerationSpeedMs: (speed) => set({ textGenerationSpeedMs: speed }), 

      reset: () => {
        debugLog("Resetting SettingsStore."); // ⬅️ Replaces console.log
        set({
          aiConnections: [],
          isLoadingConnections: false,
          connectionsError: null,
        });
      },
    }),
    {
      name: 'storyforge-app-settings',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        selectedConnectionId: state.selectedConnectionId,
        useDummyNarrator: state.useDummyNarrator,
        themeMode: state.themeMode,
        enableDebugLogging: state.enableDebugLogging,         
        textGenerationSpeedMs: state.textGenerationSpeedMs,   
      }),
    }
  )
);

@@END_FILE@@
@@FILE: src/theme/index.ts
// src/theme/index.ts
import { createTheme } from '@mui/material/styles';

/* --------------------------
   BRAND & COLOR VARIABLES
   -------------------------- */

// Backgrounds - Light
const BG_LIGHT_DEFAULT = '#FAFAFA'; // soft warm white
const BG_LIGHT_PAPER = '#FFFFFF';   // pure white

// Backgrounds - Dark
const BG_DARK_DEFAULT = '#121212';  // deep black
const BG_DARK_PAPER = '#1E1E1E';    // dark grey

// Text - Light
const TEXT_LIGHT_PRIMARY = '#1A1A1A'; // rich near-black
const TEXT_LIGHT_SECONDARY = '#555555'; // medium grey

// Text - Dark
const TEXT_DARK_PRIMARY = '#F5F5F5'; // soft white
const TEXT_DARK_SECONDARY = '#BBBBBB'; // medium light grey

// Primary Accent (actions, highlights)
const BRAND_PRIMARY_LIGHT = '#A84300'; // muted burnt orange
const BRAND_PRIMARY_DARK = '#FF8C42';  // warm muted orange

// Secondary Accent
const BRAND_SECONDARY_LIGHT = '#8B5E3C'; // warm brown
const BRAND_SECONDARY_DARK = '#D4A373';  // warm beige

// Dividers
const DIVIDER_LIGHT = '#E0E0E0';
const DIVIDER_DARK = '#333333';

// Custom UI colors
const PINNED_ENTITY_LIGHT = 'rgba(168, 67, 0, 0.85)'; // burnt orange translucent
// Much darker burnt orange, less opacity
const PINNED_ENTITY_DARK = 'rgba(140, 80, 40, 0.4)';


const CHIP_BG_LIGHT = 'rgba(255,255,255,0.7)';
const CHIP_BG_DARK = 'rgba(0,0,0,0.4)';

// Frosted translucency
const FROSTED_LIGHT = 'rgba(255,255,255,0.6)';
const FROSTED_DARK = 'rgba(30,30,30,0.4)';



/* --------------------------
   THEME EXTENSIONS
   -------------------------- */
declare module '@mui/material/styles' {
  interface Palette {
    pinnedEntity: Palette['primary'];
    chipBackground: Palette['primary'];
    frostedSurface: { light: string; dark: string };
  }
  interface PaletteOptions {
    pinnedEntity?: PaletteOptions['primary'];
    chipBackground?: PaletteOptions['primary'];
    frostedSurface?: { light: string; dark: string };
  }
}

/* --------------------------
   THEME FACTORY
   -------------------------- */
export const getAppTheme = (mode: 'light' | 'dark') => {
  const isLight = mode === 'light';

  return createTheme({
    palette: {
      mode,
      primary: {
        main: isLight ? BRAND_PRIMARY_LIGHT : BRAND_PRIMARY_DARK,
      },
      secondary: {
        main: isLight ? BRAND_SECONDARY_LIGHT : BRAND_SECONDARY_DARK,
      },
      background: {
        default: isLight ? BG_LIGHT_DEFAULT : BG_DARK_DEFAULT,
        paper: isLight ? BG_LIGHT_PAPER : BG_DARK_PAPER,
      },
      text: {
        primary: isLight ? TEXT_LIGHT_PRIMARY : TEXT_DARK_PRIMARY,
        secondary: isLight ? TEXT_LIGHT_SECONDARY : TEXT_DARK_SECONDARY,
      },

      // Custom palette extensions
      pinnedEntity: {
        main: isLight ? PINNED_ENTITY_LIGHT : PINNED_ENTITY_DARK
      },
      chipBackground: {
        main: isLight ? CHIP_BG_LIGHT : CHIP_BG_DARK,
      },
      frostedSurface: {
        light: FROSTED_LIGHT,
        dark: FROSTED_DARK,
      },
    },

    shape: {
      borderRadius: 8,
    },

    typography: {
      fontFamily: `"Roboto", "Arial", sans-serif`,
      h6: { fontWeight: 600 },
    },

    components: {
      MuiPaper: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiCard: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiDialog: {
        styleOverrides: {
          paper: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiChip: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.chipBackground.main,
            color: theme.palette.text.primary,
          }),
        },
      },
      MuiButton: {
        styleOverrides: {
          root: () => ({
            borderRadius: 8,
          }),
        },
      },
    },
  });
};

@@END_FILE@@
@@FILE: src/ui/components/AiSettingsEditor.tsx
// src/ui/components/AiSettingsEditor.tsx

import React from 'react';
import {
  Box,
  Typography,
  Slider,
  Switch,
  FormControlLabel,
  Divider,
  TextField,
  MenuItem,
} from '@mui/material';
import type { AiSettings, AiConnection } from '../../models/index';
import { CollapsibleSection } from './CollapsibleSection';

interface AiSettingsEditorProps {
  label: string;
  settings: AiSettings;
  onSettingsChange: (updatedSettings: AiSettings) => void;
  availableConnections: AiConnection[];
}

export const AiSettingsEditor: React.FC<AiSettingsEditorProps> = ({
  label,
  settings,
  onSettingsChange,
  availableConnections,
}) => {
  const handleSliderChange = (
    prop: keyof AiSettings,
    newValue: number | number[]
  ) => {
    onSettingsChange({ ...settings, [prop]: newValue as number });
  };

  const handleSwitchChange = (prop: keyof AiSettings, checked: boolean) => {
    onSettingsChange({ ...settings, [prop]: checked });
  };

  const handleConnectionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onSettingsChange({ ...settings, selectedConnectionId: event.target.value });
  };

  return (
    <CollapsibleSection title={label} initiallyExpanded={false}>
      <TextField
        select
        fullWidth
        label="AI Connection"
        value={settings.selectedConnectionId}
        onChange={handleConnectionChange}
        variant="outlined"
        sx={{ mb: 2 }}
      >
        {availableConnections.map((conn) => (
          <MenuItem key={conn.id} value={conn.id}>
            {conn.modelName} ({conn.id})
          </MenuItem>
        ))}
      </TextField>

      <Typography gutterBottom>
        Temperature: {settings.temperature.toFixed(2)}
      </Typography>
      <Slider
        value={settings.temperature}
        onChange={(_e, val) => handleSliderChange('temperature', val)}
        min={0.0}
        max={1.5}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls randomness. Low = logical, high = creative. RPG-optimal:
        0.7–1.0.
      </Typography>

      <Typography gutterBottom>Top P: {settings.topP.toFixed(2)}</Typography>
      <Slider
        value={settings.topP}
        onChange={(_e, val) => handleSliderChange('topP', val)}
        min={0.0}
        max={1.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls diversity. Lower = focused, higher = expressive. RPG-optimal:
        0.8–1.0.
      </Typography>

      <Typography gutterBottom>Max Tokens: {settings.maxTokens}</Typography>
      <Slider
        value={settings.maxTokens}
        onChange={(_e, val) => handleSliderChange('maxTokens', val)}
        min={256}
        max={8192}
        step={256}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Maximum length of AI reply. Longer = more story depth. RPG-optimal:
        1024–4096.
      </Typography>

      <Typography gutterBottom>
        Presence Penalty: {settings.presencePenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.presencePenalty}
        onChange={(_e, val) => handleSliderChange('presencePenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages introducing new topics repeatedly. RPG-optimal: 0.0–0.5.
      </Typography>

      <Typography gutterBottom>
        Frequency Penalty: {settings.frequencyPenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.frequencyPenalty}
        onChange={(_e, val) => handleSliderChange('frequencyPenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages repeating phrases. Helps avoid spam. RPG-optimal: 0.2–0.8.
      </Typography>

      <Divider sx={{ my: 2 }} />

      <FormControlLabel
        control={
          <Switch
            checked={settings.functionCallingEnabled}
            onChange={(e) =>
              handleSwitchChange('functionCallingEnabled', e.target.checked)
            }
          />
        }
        label="Enable Function Calling"
      />
      <Typography variant="body2" color="text.secondary">
        Allows AI to call structured functions (if you've defined them in the
        prompt).
      </Typography>

      <FormControlLabel
        control={
          <Switch
            checked={settings.streaming} // RENAMED
            onChange={(e) =>
              handleSwitchChange('streaming', e.target.checked) // RENAMED
            }
          />
        }
        label="Enable Streaming Output" // UPDATED LABEL
      />
      <Typography variant="body2" color="text.secondary">
        Displays AI-generated narrative text as it's generated (typing effect).
      </Typography>
    </CollapsibleSection>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/AuthOrchestrator.tsx
// src/ui/components/AuthOrchestrator.tsx
import React, { useEffect, useReducer } from 'react';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useNavigate, useLocation, Outlet } from 'react-router-dom';
import { Box, CircularProgress, Typography } from '@mui/material';
import { debugLog } from '../../utils/debug';

// --- Start of State Machine Definition ---

type LoadingState = 'IDLE' | 'CHECKING_AUTH' | 'LOADING_GAME' | 'READY';
type LoadingAction =
  | { type: 'AUTH_CHECK_COMPLETE'; payload: { isAuthenticated: boolean } }
  | { type: 'GAME_LOAD_SUCCESS' }
  | { type: 'GAME_LOAD_FAIL' }
  | { type: 'RESET' };

const reducer = (state: LoadingState, action: LoadingAction): LoadingState => {
  debugLog(`%c[AuthOrchestrator] State Transition: ${state} -> Action: ${action.type}`, 'color: blue;');
  switch (state) {
    case 'IDLE':
      if (action.type === 'AUTH_CHECK_COMPLETE') {
        return action.payload.isAuthenticated ? 'LOADING_GAME' : 'READY';
      }
      return state;
    case 'LOADING_GAME':
      if (action.type === 'GAME_LOAD_SUCCESS' || action.type === 'GAME_LOAD_FAIL') {
        return 'READY';
      }
      if (action.type === 'RESET') {
        return 'IDLE';
      }
      return state;
    case 'READY':
      if (action.type === 'RESET') {
        return 'IDLE';
      }
      return state;
    default:
      return state;
  }
};
// --- End of State Machine Definition ---


const AuthOrchestrator: React.FC = () => {
  const { user, isLoading: isAuthLoading } = useAuthStore();
  const loadLastActiveGame = useGameStateStore(state => state.loadLastActiveGame);
  const navigate = useNavigate();
  const location = useLocation();

  const [state, dispatch] = useReducer(reducer, 'IDLE');

  // Effect 1: React to authentication changes to kick off the state machine.
  useEffect(() => {
    if (!isAuthLoading) {
      dispatch({ type: 'AUTH_CHECK_COMPLETE', payload: { isAuthenticated: !!user } });
    }
  }, [isAuthLoading, user]);

  // Effect 2: Perform side-effects based on the current state of the machine.
  useEffect(() => {
    if (state === 'LOADING_GAME' && user) {
      loadLastActiveGame(user.uid).then((gameLoaded) => {
        dispatch({ type: gameLoaded ? 'GAME_LOAD_SUCCESS' : 'GAME_LOAD_FAIL' });
        // Navigate only if we are at the root, otherwise stay put.
        if (location.pathname === '/') {
          navigate(gameLoaded ? '/game' : '/library', { replace: true });
        }
      }).catch(() => {
        dispatch({ type: 'GAME_LOAD_FAIL' });
        if (location.pathname === '/') {
          navigate('/library', { replace: true });
        }
      });
    }
  }, [state, user, loadLastActiveGame, navigate, location.pathname]);
  
  // Effect 3: Reset the machine if the user logs out.
  useEffect(() => {
    if (!user && state === 'READY') {
      dispatch({ type: 'RESET' });
    }
  }, [user, state]);


  // Render loading indicator until the machine is in the 'READY' state.
  if (state !== 'READY') {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Session...</Typography>
      </Box>
    );
  }

  // Once ready, render the nested routes.
  return <Outlet />;
};

export default AuthOrchestrator;
@@END_FILE@@
@@FILE: src/ui/components/CollapsibleLogEntry.tsx
// src/ui/components/CollapsibleLogEntry.tsx

import React from 'react';
import { Box, Typography, Divider } from '@mui/material';
import type { LogEntry } from '../../models/LogEntry';
import { LogViewMode } from '../../utils/types';
import { CollapsibleSection } from './CollapsibleSection';
// This component should be importing DetailedLogTurnView or LogEntryDisplay
// Let's assume you're building out the detailed view as discussed.
// If you're using the simpler LogEntryDisplay, the fix is the same.
import { LogEntryDisplay } from './LogEntryDisplay';

interface CollapsibleLogEntryProps {
  entry: LogEntry;
  selectedLogViewModes: LogViewMode[];
}

// NOTE: This component might be redundant if `DetailedLogTurnView` does everything.
// However, fixing the error is straightforward.
export const CollapsibleLogEntry: React.FC<CollapsibleLogEntryProps> = ({ entry, selectedLogViewModes }) => {
  // ... (logic to check if there's content remains the same)

  return (
    <CollapsibleSection
      title={`Turn ${entry.turnNumber} - ${new Date(entry.timestamp).toLocaleTimeString()}`}
      initiallyExpanded={entry.turnNumber === 0}
    >
      <Box sx={{ p: 1 }}>
        {selectedLogViewModes.length === 0 ? (
          <Typography variant="body2" color="text.secondary">
            No log view modes selected.
          </Typography>
        ) : (
          selectedLogViewModes.map((mode, index) => (
            <React.Fragment key={mode}>
              <CollapsibleSection title={mode} initiallyExpanded={true}>
                {/* --- THE FIX IS HERE --- */}
                {/* Remove the hideTurnInfo prop */}
                <LogEntryDisplay mode={mode} entry={entry} />
              </CollapsibleSection>
              {index < selectedLogViewModes.length - 1 && <Divider sx={{ my: 1 }} />}
            </React.Fragment>
          ))
        )}
      </Box>
    </CollapsibleSection>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/CollapsibleSection.tsx
// src/ui/components/CollapsibleSection.tsx

import React from 'react';
import {
  Card,
  CardContent,
  Typography,
  IconButton,
  Collapse,
  Box,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';

interface CollapsibleSectionProps {
  title: string;
  children: React.ReactNode;
  initiallyExpanded?: boolean;
}

export const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  children,
  initiallyExpanded = false,
}) => {
  const [expanded, setExpanded] = React.useState(initiallyExpanded);

  const handleExpandClick = () => {
    setExpanded(!expanded);
  };

  return (
    <Card variant="outlined" sx={{ mb: 2 }}>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1.5,
          cursor: 'pointer',
          '&:hover': {
            backgroundColor: (theme) => theme.palette.action.hover,
          },
        }}
        onClick={handleExpandClick}
      >
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
        </Typography>
        <IconButton
          onClick={handleExpandClick}
          aria-expanded={expanded}
          aria-label="show more"
          size="small"
        >
          {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
      </Box>
      <Collapse in={expanded} timeout="auto" unmountOnExit>
        <CardContent sx={{ pt: 1 }}>{children}</CardContent>
      </Collapse>
    </Card>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/DetailedLogTurnView.tsx
// src/ui/components/DetailedLogTurnView.tsx

import React from 'react';
import { Box, Divider } from '@mui/material';
import { LogViewMode } from '../../utils/types';
import type { LogEntry } from '../../models';
import { CollapsibleSection } from './CollapsibleSection';
import { LogEntryDisplay } from './LogEntryDisplay';

interface DetailedLogTurnViewProps {
  entry: LogEntry;
  selectedLogViewModes: LogViewMode[];
}

// This defines the ideal chronological and logical order of log parts.
const RENDER_ORDER: LogViewMode[] = [
    LogViewMode.API_DETAILS, // Metadata first
    LogViewMode.CONTEXT_SNAPSHOT,
    LogViewMode.API_REQUEST_BODY, // Then the request body
    LogViewMode.USER_INPUT,
    LogViewMode.RAW_NARRATOR_OUTPUT,
    LogViewMode.API_RESPONSE_BODY, // Then the response body
    LogViewMode.NARRATOR_OUTPUT,
    LogViewMode.DIGEST_LINES,
    LogViewMode.DELTAS,
    // These are metadata and appear last
    LogViewMode.MODEL_SLUG_USED,
    LogViewMode.AI_SETTINGS,
    LogViewMode.TOKEN_USAGE,
    LogViewMode.ERROR_FLAGS,
  ];

export const DetailedLogTurnView: React.FC<DetailedLogTurnViewProps> = ({ entry, selectedLogViewModes }) => {
  // Filter the master RENDER_ORDER array to only include modes the user has selected.
  const viewsToRender = RENDER_ORDER.filter(mode => selectedLogViewModes.includes(mode));

  if (viewsToRender.length === 0) {
    return null; // Don't render anything for this turn if no relevant views are selected
  }

  return (
    // Each turn is its own collapsible section
    <CollapsibleSection
      title={`Turn ${entry.turnNumber} - ${new Date(entry.timestamp).toLocaleTimeString()}`}
      initiallyExpanded={entry.turnNumber === 0 || !!entry.errorFlags?.length} // Expand first turn or turns with errors
    >
      <Box sx={{ p: 1 }}>
        {viewsToRender.map((mode, index) => (
          <React.Fragment key={mode}>
            {/* Each part of the log within the turn is ALSO a collapsible section */}
            <CollapsibleSection title={mode} initiallyExpanded={true}>
              <LogEntryDisplay mode={mode} entry={entry} />
            </CollapsibleSection>
            {index < viewsToRender.length - 1 && <Divider sx={{ my: 1.5, opacity: 0.5 }} />}
          </React.Fragment>
        ))}
      </Box>
    </CollapsibleSection>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/InfoDialog.tsx
// src/ui/components/InfoDialog.tsx

import React, { useState } from 'react';
import { Dialog, DialogTitle, DialogContent, DialogActions, Button, IconButton, Tooltip, Box } from '@mui/material';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';

interface InfoDialogProps {
  title: string;
  content: string | React.ReactNode; // Can be a string or JSX
  iconSize?: 'small' | 'medium' | 'large';
  tooltipText?: string; // Optional text for the initial hover tooltip
}

export const InfoDialog: React.FC<InfoDialogProps> = ({ title, content, iconSize = 'small', tooltipText = "Click for more information" }) => {
  const [open, setOpen] = useState(false);

  const handleClickOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <>
      <Tooltip title={tooltipText}>
        <IconButton size={iconSize} onClick={handleClickOpen} sx={{ ml: 0.5, p: 0 }}>
          <InfoOutlinedIcon fontSize="small" />
        </IconButton>
      </Tooltip>
      <Dialog
        open={open}
        onClose={handleClose}
        aria-labelledby="info-dialog-title"
        fullWidth
        maxWidth="sm"
      >
        <DialogTitle id="info-dialog-title">{title}</DialogTitle>
        <DialogContent dividers>
          {/* Use Box with pre-wrap to respect line breaks in string content */}
          {typeof content === 'string' ? <Box sx={{ whiteSpace: 'pre-wrap' }}>{content}</Box> : content}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Close</Button>
        </DialogActions>
      </Dialog>
    </>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/LogEntryDisplay.tsx
// src/ui/components/LogEntryDisplay.tsx

import React from 'react';
import { Typography, Alert, Paper, Box } from '@mui/material'; // Add Paper and Box
import type { LogEntry } from '../../models';
import { LogViewMode } from '../../utils/types';

interface LogEntryDisplayProps {
  mode: LogViewMode;
  entry: LogEntry;
}

export const LogEntryDisplay: React.FC<LogEntryDisplayProps> = ({ mode, entry }) => {
  const renderContent = () => {
    switch (mode) {
      case LogViewMode.USER_INPUT:
        return entry.userInput || <Alert severity="info" sx={{mt:1}}>No user input for this turn (e.g., initial game state).</Alert>;

      case LogViewMode.NARRATOR_OUTPUT:
        return entry.prose || <Alert severity="info" sx={{mt:1}}>No prose was generated for this turn.</Alert>;
        
      case LogViewMode.RAW_NARRATOR_OUTPUT: // Add a case for the raw output if needed
        return entry.narratorOutput || <Alert severity="info" sx={{mt:1}}>No raw output was logged.</Alert>;

      case LogViewMode.DIGEST_LINES:
        if (!entry.digestLines || entry.digestLines.length === 0) return <Alert severity="info" sx={{mt:1}}>No digest lines.</Alert>;
        return entry.digestLines.map((d, i) => `(Importance ${d.importance}) ${d.text}`).join('\n');

      case LogViewMode.DELTAS:
        if (!entry.deltas || Object.keys(entry.deltas).length === 0) return <Alert severity="info" sx={{mt:1}}>No deltas.</Alert>;
        return JSON.stringify(entry.deltas, null, 2);

      case LogViewMode.CONTEXT_SNAPSHOT:
        return entry.contextSnapshot || <Alert severity="info" sx={{mt:1}}>No context snapshot was logged.</Alert>;

      case LogViewMode.TOKEN_USAGE:
        if (!entry.tokenUsage) return <Alert severity="info" sx={{mt:1}}>No token usage info.</Alert>;
        return `Input: ${entry.tokenUsage.inputTokens}, Output: ${entry.tokenUsage.outputTokens}, Total: ${entry.tokenUsage.totalTokens}`;

      case LogViewMode.AI_SETTINGS:
        if (!entry.aiSettings) return <Alert severity="info" sx={{mt:1}}>No AI settings logged.</Alert>;
        return JSON.stringify(entry.aiSettings, null, 2);

      case LogViewMode.API_DETAILS:
        const details = [
          `URL: ${entry.apiUrl || 'N/A'}`,
          `Latency: ${entry.latencyMs !== null ? `${entry.latencyMs}ms` : 'N/A'}`,
        ];
        return details.join('\n');

      // ADDED: New case for the request body.
      case LogViewMode.API_REQUEST_BODY:
        if (!entry.apiRequestBody) return <Alert severity="info" sx={{mt:1}}>No request body was logged.</Alert>;
        return (
            <Paper variant="outlined" sx={{ p: 1, mt: 1, backgroundColor: (theme) => theme.palette.action.hover }}>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all', fontSize: '0.8rem' }}>
                {entry.apiRequestBody}
              </Typography>
            </Paper>
        );

      // ADDED: New case for the response body.
      case LogViewMode.API_RESPONSE_BODY:
        if (!entry.apiResponseBody) return <Alert severity="info" sx={{mt:1}}>No response body was logged.</Alert>;
        return (
            <Paper variant="outlined" sx={{ p: 1, mt: 1, backgroundColor: (theme) => theme.palette.action.hover }}>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all', fontSize: '0.8rem' }}>
                {entry.apiResponseBody}
              </Typography>
            </Paper>
        );

      case LogViewMode.ERROR_FLAGS:
        if (!entry.errorFlags || entry.errorFlags.length === 0) return <Alert severity="success" sx={{mt:1}}>No errors flagged.</Alert>;
        return <Alert severity="error" sx={{mt:1}}>{entry.errorFlags.join(', ')}</Alert>;

      case LogViewMode.RAW_NARRATOR_OUTPUT:
        return entry.narratorOutput || <Alert severity="info" sx={{mt:1}}>No raw output was logged.</Alert>;
  
      case LogViewMode.MODEL_SLUG_USED: // ADD THIS CASE
        return entry.modelSlugUsed || <Alert severity="info" sx={{mt:1}}>Model slug was not logged.</Alert>;  

      default:
        return `Unknown log view mode: ${mode}`;
    }
  };

  // The outer component can be simplified as the inner content now handles its own formatting
  // We can create a list of modes that need special paper/box wrapping
  const needsWrapper = [LogViewMode.API_REQUEST_BODY, LogViewMode.API_RESPONSE_BODY, LogViewMode.ERROR_FLAGS];
  if (needsWrapper.includes(mode)) {
    return <Box>{renderContent()}</Box>;
  }

  return (
    <Typography variant="body2" component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word', mt: 0.5, fontFamily: 'monospace', fontSize: '0.9rem' }}>
      {renderContent()}
    </Typography>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/LogView.tsx
// src/ui/components/LogView.tsx

import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
import type { Message } from '../../models';

interface LogViewProps {
  conversationHistory: Message[];
  currentStreamingNarration: string;
  isProcessingTurn: boolean;
  fullLatestNarration: string;
  enableStreaming: boolean;
}

export const LogView: React.FC<LogViewProps> = ({
  conversationHistory,
  currentStreamingNarration,
  isProcessingTurn,
  fullLatestNarration,
  enableStreaming
}) => {
  const isInitialDisplay = conversationHistory.length === 0;

  const lastMessageInHistoryIsLatest =
    conversationHistory.length > 0 &&
    conversationHistory[conversationHistory.length - 1].role === 'assistant' &&
    conversationHistory[conversationHistory.length - 1].content === fullLatestNarration;

  const messagesToRenderFromHistory =
    (enableStreaming && isProcessingTurn) ||
    (enableStreaming && !lastMessageInHistoryIsLatest && fullLatestNarration.length > 0 && currentStreamingNarration !== fullLatestNarration)
      ? conversationHistory.slice(0, -1)
      : conversationHistory;

  return (
    <Box sx={{ flexGrow: 1, overflowY: 'auto' }}>
      {isInitialDisplay ? (
        // Show initial prose block if there's no prior conversation
        <Paper elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
          <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
            AI Narrator:
          </Typography>
          <Typography variant="body1">
            {fullLatestNarration}
          </Typography>
        </Paper>
      ) : (
        messagesToRenderFromHistory.map((message, index) => (
          <Paper key={index} elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
            {message.role === 'user' ? (
              <>
                <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.primary.dark }}>
                  You:
                </Typography>
                <Typography variant="body1" sx={{ mb: 1 }}>
                  {message.content}
                </Typography>
              </>
            ) : (
              <>
                <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
                  AI Narrator:
                </Typography>
                <Typography variant="body1">
                  {message.content}
                </Typography>
              </>
            )}
          </Paper>
        ))
      )}

{!isInitialDisplay && fullLatestNarration && !lastMessageInHistoryIsLatest && (
        <Paper elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
          <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
            AI Narrator:
          </Typography>
          <Typography variant="body1">
            {isProcessingTurn || (enableStreaming && currentStreamingNarration !== fullLatestNarration)
              ? currentStreamingNarration
              : fullLatestNarration}
          </Typography>
        </Paper>
      )}
    </Box>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/MainLayout.tsx
// src/ui/components/MainLayout.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Drawer, List, ListItem, ListItemButton, ListItemIcon, ListItemText,
  CssBaseline, Box, Typography, Divider, IconButton
} from '@mui/material';
import LogoutIcon from '@mui/icons-material/Logout';
import MenuIcon from '@mui/icons-material/Menu';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { getNavItems } from '../../config/navigation';
import { LayoutProvider } from '../../contexts/LayoutContext';

const drawerWidth = 240;

const MainLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user, signOut } = useAuthStore();
  const { currentSnapshot } = useGameStateStore();
  const navigate = useNavigate();
  const [mobileOpen, setMobileOpen] = useState(false);

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleSignOut = async () => {
    await signOut();
    navigate('/login');
  };

  const navItems = getNavItems(currentSnapshot);

  const drawerContent = (
    <Box onClick={handleDrawerToggle} sx={{ textAlign: 'center' }}>
      <Typography variant="h6" sx={{ my: 2 }}>StoryForge</Typography>
      <Divider />
      <List>
        {navItems.filter(item => user ? true : !item.requiresAuth).map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton onClick={() => navigate(item.path)} disabled={item.disabled}>
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
        {user ? (
          <ListItem disablePadding>
            <ListItemButton onClick={handleSignOut}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItemButton>
          </ListItem>
        ) : (
          <ListItem disablePadding>
            <ListItemButton onClick={() => navigate('/login')}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Login" />
            </ListItemButton>
          </ListItem>
        )}
      </List>
    </Box>
  );

  return (
    <LayoutProvider>
      <Box sx={{ display: 'flex', height: '100vh' }}>
        <CssBaseline />
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{ keepMounted: true }}
          sx={{ '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth } }}
        >
          {drawerContent}
        </Drawer>

        <Box component="main" sx={{ flexGrow: 1, height: '100%', display: 'flex', flexDirection: 'column' }}>
          {user && (
            <IconButton
              color="inherit"
              aria-label="open drawer"
              onClick={handleDrawerToggle}
              edge="start"
              sx={{
                position: 'fixed',
                top: 16,
                right: 16,
                zIndex: (theme) => theme.zIndex.drawer + 1,
                backgroundColor: (theme) => theme.palette.background.paper,
                boxShadow: 2,
                '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
              }}
            >
              <MenuIcon />
            </IconButton>
          )}
          {children}
        </Box>
      </Box>
    </LayoutProvider>
  );
};

export default MainLayout;
@@END_FILE@@
@@FILE: src/ui/components/PinnedAttributeChip.tsx
// src/ui/components/PinnedAttributeChip.tsx

import React from 'react';
import { Chip, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';

interface PinnedAttributeChipProps {
  fullKey: string;
  label: string;
  value: any;
  onUnpin: (key: string) => void;
}

export const PinnedAttributeChip: React.FC<PinnedAttributeChipProps> = React.memo(
  ({ fullKey, label, value, onUnpin }) => {
    const longPressProps = useLongPress((e) => {
      e.stopPropagation();
      onUnpin(fullKey);
    });

    return (
      <Tooltip title={`Long-press to unpin '${label}'`} key={fullKey}>
        <Chip
          label={`${label}: ${JSON.stringify(value)}`}
          size="small"
          deleteIcon={<PushPinIcon />}
          sx={{
            backgroundColor: (theme) => theme.palette.chipBackground.main, // CHIP_BG_LIGHT/DARK
            color: (theme) => theme.palette.text.primary,
            fontSize: '0.8rem',
            height: '22px',
            '& .MuiChip-label': {
              px: 1,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
            },
            '& .MuiChip-deleteIcon': {
              opacity: 0.2,
            },
            '&:hover .MuiChip-deleteIcon': {
              opacity: 1,
            },
          }}
          {...longPressProps}
        />
      </Tooltip>
    );
  }
);

@@END_FILE@@
@@FILE: src/ui/components/PinnedEntityGroup.tsx
// src/ui/components/PinnedEntityGroup.tsx

import React from 'react';
import { Paper, Typography, Stack, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';
import { PinnedAttributeChip } from './PinnedAttributeChip';

interface Attribute {
  label: string;
  value: any;
  fullKey: string;
}

interface PinnedEntityGroupProps {
  entityPath: string;
  attributes: Attribute[];
  onUnpinEntity: (path: string) => void;
  onUnpinVariable: (key: string) => void;
}

export const PinnedEntityGroup: React.FC<PinnedEntityGroupProps> = ({
  entityPath,
  attributes,
  onUnpinEntity,
  onUnpinVariable,
}) => {
  const longPressEntityProps = useLongPress(() => {
    onUnpinEntity(entityPath);
  });

  const entityDisplayName = entityPath.includes('.')
    ? entityPath.split('.').pop()?.replace(/^[#@$]/, '')
    : entityPath;

  return (
    <Paper
      elevation={3}
      sx={{
        p: 1,
        minWidth: 150,
        backgroundColor: (theme) =>
          theme.palette.mode === 'light'
            ? theme.palette.pinnedEntity.main // Uses PINNED_ENTITY_LIGHT
            : theme.palette.pinnedEntity.main, // Uses PINNED_ENTITY_DARK
        backdropFilter: 'blur(4px)',
        color: (theme) => theme.palette.text.primary,
        flexShrink: 0,
        cursor: 'pointer',
        borderRadius: 3,
        boxShadow: (theme) => theme.shadows[4],
        transition: 'transform 0.15s ease, box-shadow 0.15s ease',
        '&:hover': {
          transform: 'translateY(-2px)',
          boxShadow: (theme) => theme.shadows[6],
        },
      }}
      {...longPressEntityProps}
    >

      <Typography variant="subtitle2" sx={{ fontWeight: 'bold' }}>
        {entityDisplayName}
        <Tooltip title="Long-press to unpin all for this group">
          <PushPinIcon fontSize="small" sx={{ verticalAlign: 'middle', ml: 0.5 }} />
        </Tooltip>
      </Typography>
      <Stack direction="column" spacing={0.5} sx={{ mt: 1 }}>
        {attributes.map((attr) => (
          <PinnedAttributeChip
            key={attr.fullKey}
            fullKey={attr.fullKey}
            label={attr.label}
            value={attr.value}
            onUnpin={onUnpinVariable}
          />
        ))}
      </Stack>
    </Paper>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PinnedItemsView.tsx
import React, { useEffect, useCallback } from 'react';
import { Box, Typography, Paper, Stack } from '@mui/material';
import {
  useGameStateStore,
  selectCurrentGameState,
  selectWorldStatePinnedKeys
} from '../../state/useGameStateStore';
import { flattenJsonObject } from '../../utils/jsonUtils';
import { PinnedEntityGroup } from './PinnedEntityGroup';

export const PinnedItemsView: React.FC = React.memo(() => {
  const gameState = useGameStateStore(selectCurrentGameState);
  const worldStatePinnedKeys = useGameStateStore(selectWorldStatePinnedKeys);
  const toggleWorldStatePin = useGameStateStore(state => state.toggleWorldStatePin);

  const worldState = gameState?.worldState || {};

  const flattenedWorld = React.useMemo(() => {
    return flattenJsonObject(worldState);
  }, [worldState]);

  const pinnedItems = React.useMemo(() => {
    const items = worldStatePinnedKeys
      .map((key: string) => ({
        key,
        value: flattenedWorld[key],
      }))
      .filter(item => item.value !== undefined);

    return items;
  }, [worldStatePinnedKeys, flattenedWorld]);

  const groupedPinnedItems = React.useMemo(() => {
    const grouped: { [entityPath: string]: { label: string; value: any; fullKey: string }[] } = {};
    pinnedItems.forEach(item => {
      const parts = item.key.split('.');
      if (parts.length >= 2) {
        const secondPart = parts[1];
        const isTaggedEntity = secondPart.startsWith('#') || secondPart.startsWith('@') || secondPart.startsWith('$');
        let entityPath: string;
        let label: string;

        if (parts.length >= 3 && isTaggedEntity) {
          entityPath = parts.slice(0, 2).join('.');
          label = parts.slice(2).join('.');
        } else {
          entityPath = parts[0];
          label = parts.slice(1).join('.');
        }

        if (label === '') {
          label = parts[parts.length - 1];
        }

        grouped[entityPath] = grouped[entityPath] || [];
        grouped[entityPath].push({ label, value: item.value, fullKey: item.key });
      }
    });

    Object.keys(grouped).forEach(entityPath => {
      grouped[entityPath].sort((a, b) => a.label.localeCompare(b.label));
    });

    return grouped;
  }, [pinnedItems]);

  const handleUnpinEntity = useCallback((entityPath: string) => {
    toggleWorldStatePin(entityPath, 'entity');
  }, [toggleWorldStatePin]);

  const handleUnpinVariable = useCallback((key: string) => {
    toggleWorldStatePin(key, 'variable');
  }, [toggleWorldStatePin]);

  useEffect(() => {
    console.log("[PinnedItemsView] Re-rendered");
    console.log("Pinned keys:", worldStatePinnedKeys);
    console.log("Total grouped items:", Object.keys(groupedPinnedItems).length);
  }, [worldStatePinnedKeys, pinnedItems, groupedPinnedItems]);

  if (pinnedItems.length === 0) {
    return (
      <Paper
        elevation={0}
        sx={{ p: 1.5, mt: 1, backgroundColor: (theme) => theme.palette.background.default }}
      >
        <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
          No items pinned. Right-click or long-press items in the World State screen to pin them here.
        </Typography>
      </Paper>
    );
  }

  return (
    <Stack
      direction="row"
      spacing={2}
      sx={{
        py: 1,
        overflowX: 'auto',
        backgroundColor: 'transparent',
      }}
    >
      {Object.entries(groupedPinnedItems).map(([entityPath, attributes]) => (
        <PinnedEntityGroup
          key={entityPath}
          entityPath={entityPath}
          attributes={attributes}
          onUnpinEntity={handleUnpinEntity}
          onUnpinVariable={handleUnpinVariable}
        />
      ))}
    </Stack>
  );
});

@@END_FILE@@
@@FILE: src/ui/components/PromptCard.tsx
// src/ui/components/PromptCardCard.tsx
import React from 'react';
import {
  Card, CardContent, CardActions, Typography, IconButton, Tooltip,
} from '@mui/material';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import type { PromptCard } from '../../models';

interface PromptCardCardProps {
  card: PromptCard;
  onEdit: () => void;
  onDelete: () => void;
}

export const PromptCardCard: React.FC<PromptCardCardProps> = ({ card, onEdit, onDelete }) => {
  return (
    <Card variant="outlined" sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <CardContent sx={{ flexGrow: 1 }}>
        <Typography variant="h6" gutterBottom>{card.title || 'Untitled Card'}</Typography>
        <Typography variant="body2" color="text.secondary">
          {card.prompt.slice(0, 100)}{card.prompt.length > 100 ? '…' : ''}
        </Typography>
      </CardContent>
      <CardActions>
        <Tooltip title="Edit Card">
          <IconButton onClick={onEdit}><EditIcon /></IconButton>
        </Tooltip>
        <Tooltip title="Delete Card">
          <IconButton onClick={onDelete}><DeleteIcon /></IconButton>
        </Tooltip>
      </CardActions>
    </Card>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PromptCardEditorDialog.tsx
// src/ui/components/PromptCardEditorDialog.tsx

import React, { useState, useEffect } from 'react';
import {
  Dialog, DialogTitle, DialogContent, DialogActions,
  Button, Box, TextField
} from '@mui/material';
import type { PromptCard } from '../../models';
import {
  DEFAULT_EMIT_SKELETON_STRING,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  defaultAiSettingsInCard,
  defaultStackInstructions
} from '../../data/config/promptCardDefaults'; // ✅ Use existing constants instead

import { EmitSkeletonSection } from './PromptCardEditorSections/EmitSkeletonSection.tsx';
import { PromptSection } from './PromptCardEditorSections/PromptSection.tsx';
import { WorldStateInitSection } from './PromptCardEditorSections/WorldStateInitSection.tsx';
import { GameRulesSection } from './PromptCardEditorSections/GameRulesSection.tsx';
import { AiSettingsSection } from './PromptCardEditorSections/AiSettingsSection.tsx';

interface PromptCardEditorDialogProps {
  open: boolean;
  initialCard: PromptCard | null;
  onClose: () => void;
  onSave: (card: PromptCard) => void;
}

// ✅ Local helper: mock default PromptCard (not persisted or valid for storage yet)
const createBlankPromptCard = (): PromptCard => ({
  id: 'temporary-id',
  rootId: 'temporary-id',
  parentId: null,
  ownerId: 'preview',
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  title: 'Untitled Card',
  prompt: '',
  description: null,
  firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  stackInstructions: defaultStackInstructions,
  emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
  worldStateInit: '',
  gameRules: '',
  aiSettings: { ...defaultAiSettingsInCard },
  helperAiSettings: { ...defaultAiSettingsInCard },
  isHelperAiEnabled: false,
  tags: [],
  isExample: false,
  functionDefs: '',
  isPublic: false,
  historyBrowsingEnabled: true,
  contentHash: '',
});

export const PromptCardEditorDialog: React.FC<PromptCardEditorDialogProps> = ({
  open,
  initialCard,
  onClose,
  onSave,
}) => {
  const [card, setCard] = useState<PromptCard>(initialCard || createBlankPromptCard());

  useEffect(() => {
    if (initialCard) {
      setCard(initialCard);
    } else {
      setCard(createBlankPromptCard());
    }
  }, [initialCard]);

  const handleChange = <K extends keyof PromptCard>(key: K, value: PromptCard[K]) => {
    setCard(prev => ({ ...prev, [key]: value }));
  };

  const handleSave = () => {
    onSave(card);
  };

  return (
    <Dialog open={open} onClose={onClose} fullScreen scroll="paper">
      <DialogTitle>{initialCard ? 'Edit Prompt Card' : 'New Prompt Card'}</DialogTitle>
      <DialogContent dividers>
        <Box sx={{ mb: 2 }}>
          <TextField
            fullWidth
            label="Card Title"
            value={card.title}
            onChange={(e) => handleChange('title', e.target.value)}
          />
        </Box>

        <PromptSection prompt={card.prompt} onChange={(v) => handleChange('prompt', v)} />

        <EmitSkeletonSection emitSkeleton={card.emitSkeleton} onChange={(v) => handleChange('emitSkeleton', v)} />

        <WorldStateInitSection worldState={card.worldStateInit} onChange={(v) => handleChange('worldStateInit', v)} />

        <GameRulesSection gameRules={card.gameRules} onChange={(v) => handleChange('gameRules', v)} />

        <AiSettingsSection settings={card.aiSettings} onChange={(v) => handleChange('aiSettings', v)} />
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Cancel</Button>
        <Button onClick={handleSave} variant="contained">Save</Button>
      </DialogActions>
    </Dialog>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PromptCardEditorPanel.tsx
// src/ui/components/PromptCardEditorPanel.tsx
import React from 'react';
import { Box, Typography, Button, CircularProgress } from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import type { PromptCard, AiConnection } from '../../models';
import PromptCardEditor from '../screens/PromptCardEditor'; // Note: This should eventually move to components

interface PromptCardEditorPanelProps {
  localEditedCard: PromptCard | null;
  isCardDirty: boolean;
  availableConnections: AiConnection[];
  onCardChange: (updatedCard: PromptCard) => void;
  onRevert: () => void;
  onSave: () => void;
  onSaveAs: () => void;
  onStartGame: () => void;
}

export const PromptCardEditorPanel: React.FC<PromptCardEditorPanelProps> = ({
  localEditedCard,
  isCardDirty,
  availableConnections,
  onCardChange,
  onRevert,
  onSave,
  onSaveAs,
  onStartGame,
}) => {
  if (!localEditedCard) {
    return (
      <Box sx={{ textAlign: 'center', p: 4, mt: 4 }}>
        <Typography variant="h6" color="text.secondary">
          Select a card or create a new one to begin editing.
        </Typography>
      </Box>
    );
  }

  return (
    <>
      <Box
        sx={{
          p: 2,
          borderBottom: '1px solid',
          borderColor: 'divider',
          position: 'sticky',
          top: 0,
          backgroundColor: 'background.paper',
          zIndex: 1,
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          flexWrap: 'wrap',
          gap: 1,
        }}
      >
        <Typography variant="h6">{localEditedCard.title}</Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          {isCardDirty && (
            <>
              <Button variant="outlined" onClick={onRevert}>
                Revert
              </Button>
              <Button variant="contained" onClick={onSave}>
                Save Changes
              </Button>
            </>
          )}
          <Button variant="outlined" onClick={onSaveAs}>
            Save As...
          </Button>
          <Button
            variant="contained"
            color="primary"
            onClick={onStartGame}
            startIcon={<PlayArrowIcon />}
            disabled={isCardDirty}
          >
            Start Game
          </Button>
        </Box>
      </Box>
      <PromptCardEditor
        card={localEditedCard}
        onCardChange={onCardChange}
        availableConnections={availableConnections}
      />
    </>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/PromptCardEditorSections/AiSettingsSection.tsx
// src/ui/components/PromptCardEditorSections/AiSettingsSection.tsx
import React from 'react';
import { Box, Typography, Slider, TextField } from '@mui/material';
import type { AiSettings } from '../../../models';
import { useSettingsStore } from '../../../state/useSettingsStore';

interface AiSettingsSectionProps {
  settings: AiSettings;
  onChange: (newSettings: AiSettings) => void;
}

export const AiSettingsSection: React.FC<AiSettingsSectionProps> = ({ settings, onChange }) => {
  const update = <K extends keyof AiSettings>(key: K, value: AiSettings[K]) => {
    onChange({ ...settings, [key]: value });
  };

  const availableConnections = useSettingsStore((state) => state.aiConnections);
  const selectedConnection = availableConnections.find(
    (conn) => conn.id === settings.selectedConnectionId
  );

  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>AI Settings</Typography>

      <Box sx={{ mt: 2 }}>
        <Typography gutterBottom>Model Name</Typography>
        <TextField
          fullWidth
          value={selectedConnection?.modelName || "Unknown"}
          disabled // 👈 Make this readonly
        />
      </Box>


      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Temperature: {settings.temperature}</Typography>
        <Slider
          value={settings.temperature}
          min={0}
          max={1.5}
          step={0.05}
          onChange={(_, val) => update('temperature', val as number)}
        />
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Top P: {settings.topP}</Typography>
        <Slider
          value={settings.topP}
          min={0}
          max={1}
          step={0.05}
          onChange={(_, val) => update('topP', val as number)}
        />
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Max Tokens</Typography>
        <TextField
          type="number"
          fullWidth
          value={settings.maxTokens}
          onChange={(e) => update('maxTokens', parseInt(e.target.value) || 0)}
        />
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Presence Penalty: {settings.presencePenalty}</Typography>
        <Slider
          value={settings.presencePenalty}
          min={-2}
          max={2}
          step={0.1}
          onChange={(_, val) => update('presencePenalty', val as number)}
        />
      </Box>

      <Box sx={{ mt: 3 }}>
        <Typography gutterBottom>Frequency Penalty: {settings.frequencyPenalty}</Typography>
        <Slider
          value={settings.frequencyPenalty}
          min={-2}
          max={2}
          step={0.1}
          onChange={(_, val) => update('frequencyPenalty', val as number)}
        />
      </Box>
    </Box>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PromptCardEditorSections/EmitSkeletonSection.tsx
// src/ui/components/PromptCardEditorSections/EmitSkeletonSection.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';

interface EmitSkeletonSectionProps {
  emitSkeleton: string;
  onChange: (value: string) => void;
}

export const EmitSkeletonSection: React.FC<EmitSkeletonSectionProps> = ({ emitSkeleton, onChange }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>Emit Skeleton</Typography>
      <TextField
        label="Emit Skeleton JSON"
        multiline
        fullWidth
        minRows={6}
        value={emitSkeleton}
        onChange={(e) => onChange(e.target.value)}
      />
    </Box>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PromptCardEditorSections/GameRulesSection.tsx
// src/ui/components/PromptCardEditorSections/GameRulesSection.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';

interface GameRulesSectionProps {
  gameRules: string;
  onChange: (value: string) => void;
}

export const GameRulesSection: React.FC<GameRulesSectionProps> = ({ gameRules, onChange }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>Game Rules</Typography>
      <TextField
        label="Rules Text"
        multiline
        fullWidth
        minRows={6}
        value={gameRules}
        onChange={(e) => onChange(e.target.value)}
      />
    </Box>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PromptCardEditorSections/PromptSection.tsx
// src/ui/components/PromptCardEditorSections/PromptSection.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';

interface PromptSectionProps {
  prompt: string;
  onChange: (value: string) => void;
}

export const PromptSection: React.FC<PromptSectionProps> = ({ prompt, onChange }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>Core Prompt</Typography>
      <TextField
        label="Prompt Text"
        multiline
        fullWidth
        minRows={6}
        value={prompt}
        onChange={(e) => onChange(e.target.value)}
      />
    </Box>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PromptCardEditorSections/WorldStateInitSection.tsx
// src/ui/components/PromptCardEditorSections/WorldStateInitSection.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';

interface WorldStateInitSectionProps {
  worldState: string;
  onChange: (value: string) => void;
}

export const WorldStateInitSection: React.FC<WorldStateInitSectionProps> = ({ worldState, onChange }) => {
  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>Initial World State</Typography>
      <TextField
        label="World State JSON"
        multiline
        fullWidth
        minRows={8}
        value={worldState}
        onChange={(e) => onChange(e.target.value)}
      />
    </Box>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PromptCardList.tsx
import React from 'react';
import {
  List,
  ListItem,
  ListItemText,
  ListItemButton,
  Typography,
  Divider,
  IconButton,
  Box,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import type { PromptCard } from '../../models';

interface PromptCardListProps {
  cards: PromptCard[];
  activeCardId: string | null;
  onSelectCard: (card: PromptCard) => void;
  onDeleteCard: (cardId: string) => void;
  onDuplicateCard: (cardId: string) => void;
  onExportCard: (cardId: string) => void;
}

export const PromptCardList: React.FC<PromptCardListProps> = ({
  cards,
  activeCardId,
  onSelectCard,
  onDeleteCard,
  onDuplicateCard,
  onExportCard,
}) => {
  return (
    <>
      <Typography variant="h6" sx={{ p: 2, pb: 1 }}>
        Your Cards
      </Typography>
      <Divider />
      <List>
        {cards.length === 0 ? (
          <ListItem>
            <ListItemText
              primary="No cards yet. Create one!"
              sx={{ textAlign: 'center' }}
            />
          </ListItem>
        ) : (
          cards.map((card) => (
            <ListItem
              key={card.id}
              disablePadding
              secondaryAction={
                <Box>
                  <IconButton
                    edge="end"
                    aria-label="duplicate"
                    onClick={() => onDuplicateCard(card.id)}
                  >
                    <ContentCopyIcon />
                  </IconButton>
                  <IconButton
                    edge="end"
                    aria-label="export"
                    onClick={() => onExportCard(card.id)}
                  >
                    <FileDownloadIcon />
                  </IconButton>
                  <IconButton
                    edge="end"
                    aria-label="delete"
                    onClick={() => onDeleteCard(card.id)}
                  >
                    <DeleteIcon />
                  </IconButton>
                </Box>
              }
            >
              <ListItemButton
                selected={activeCardId === card.id}
                onClick={() => onSelectCard(card)}
              >
                <ListItemText primary={card.title || 'Untitled Card'} />
              </ListItemButton>
            </ListItem>
          ))
        )}
      </List>
    </>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/PromptCardListPanel.tsx
// src/ui/components/PromptCardListPanel.tsx
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import FileUploadIcon from '@mui/icons-material/FileUpload';
import type { PromptCard } from '../../models';
import { PromptCardList } from './PromptCardList';

interface PromptCardListPanelProps {
  cards: PromptCard[];
  activeCardId: string | null;
  onSelectCard: (card: PromptCard) => void;
  onDeleteCard: (cardId: string) => void;
  onDuplicateCard: (cardId: string) => void;
  onExportCard: (cardId: string) => void;
  onNewCard: () => void;
  onImport: (event: React.ChangeEvent<HTMLInputElement>) => void;
}

export const PromptCardListPanel: React.FC<PromptCardListPanelProps> = ({
  cards,
  activeCardId,
  onSelectCard,
  onDeleteCard,
  onDuplicateCard,
  onExportCard,
  onNewCard,
  onImport,
}) => {
  return (
    <>
      <Box sx={{ p: 2, borderBottom: '1px solid', borderColor: 'divider' }}>
        <Typography variant="h6" component="h2">
          Card Library
        </Typography>
        <Box sx={{ display: 'flex', gap: 1, mt: 2, flexWrap: 'wrap' }}>
          <Button
            variant="contained"
            onClick={onNewCard}
            startIcon={<AddIcon />}
            size="small"
          >
            New Card
          </Button>
          <Button
            variant="outlined"
            component="label"
            startIcon={<FileUploadIcon />}
            size="small"
          >
            Import
            <input type="file" hidden accept=".json" onChange={onImport} multiple />
          </Button>
        </Box>
      </Box>
      <PromptCardList
        cards={cards}
        activeCardId={activeCardId}
        onSelectCard={onSelectCard}
        onDeleteCard={onDeleteCard}
        onDuplicateCard={onDuplicateCard}
        onExportCard={onExportCard}
      />
    </>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/ProtectedRoute.tsx
// src/ui/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../../state/useAuthStore';
import { Box, CircularProgress, Typography } from '@mui/material';

interface ProtectedRouteProps {
  children: JSX.Element;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { user, isLoading } = useAuthStore();
  const location = useLocation();

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Verifying Authentication...</Typography>
      </Box>
    );
  }

  if (!user) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to. This allows us to send them along to that page after they login.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default ProtectedRoute;
@@END_FILE@@
@@FILE: src/ui/components/SourceDumpPanel.tsx
// src/ui/components/SourceDumpPanel.tsx
import React, { useEffect, useState } from 'react';
import { debugLog, errorLog } from '../../utils/debug';

// --- Type Definitions ---
interface File {
  name: string;
  content: string;
}

// A TreeNode represents a folder. It has a list of its own files (`__files`)
// and its properties are other folders (child TreeNodes).
interface TreeNode {
  __files: File[];
  [key: string]: TreeNode | File[]; // This is the key change to fix the error.
}

// --- Helper Components ---

function CopyButton({ text }: { text: string }) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch (err) {
      errorLog('Copy failed', err);
    }
  };

  return (
    <button
      onClick={handleCopy}
      style={{
        marginLeft: '6px',
        fontSize: '0.8rem',
        cursor: 'pointer',
        background: 'none',
        border: '1px solid #ccc',
        borderRadius: '4px',
        padding: '2px 5px',
      }}
    >
      {copied ? '✅' : '📋'}
    </button>
  );
}

function FolderView({ name, node, level = 0 }: { name: string; node: TreeNode | null; level?: number }) {
  const [open, setOpen] = useState(true);

  if (!node) {
    return null;
  }

  const folderIndent = { paddingLeft: `${level * 1.2}rem` };
  const folderText = node.__files ? node.__files.map(f => f.content).join('\n') : '';

  return (
    <div style={{ ...folderIndent }}>
      <div style={{ cursor: 'pointer', userSelect: 'none', fontWeight: 'bold' }} onClick={() => setOpen(!open)}>
        {open ? '📂' : '📁'} {name}
        {folderText && <CopyButton text={folderText} />}
      </div>
      {open && (
        <>
          {node.__files && node.__files.map((file: File) => (
            <div key={file.name} style={{ paddingLeft: '1.5rem' }}>
              📄 {file.name}
              <CopyButton text={file.content} />
            </div>
          ))}
          {Object.entries(node)
            .filter(([key]) => key !== '__files')
            .map(([childName, childNode]) => (
              // The `childNode` is now correctly typed as `TreeNode`
              <FolderView key={childName} name={childName} node={childNode as TreeNode} level={level + 1} />
            ))}
        </>
      )}
    </div>
  );
}

// --- Main Component ---

export default function SourceDumpPanel() {
  const [dumpText, setDumpText] = useState('');
  const [tree, setTree] = useState<TreeNode | null>(null);

  useEffect(() => {
    debugLog('[SourceDumpPanel] fetching /source-dump.txt');
    let mounted = true;
    (async () => {
      try {
        const res = await fetch(`/source-dump.txt?_=${Date.now()}`, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        if (!mounted) return;
        setDumpText(text);
        setTree(parseDumpToTree(text));
      } catch (e) {
        errorLog('[SourceDump] fetch failed', e);
      }
    })();
    return () => { mounted = false; };
  }, []);

  if (!dumpText) return <div>Loading...</div>;

  return (
    <div style={{ padding: '1rem', fontFamily: 'monospace' }}>
      <h2>
        📋 Copy Entire Repo
        <CopyButton text={dumpText} />
      </h2>
      {tree && <FolderView name="src" node={(tree.src as TreeNode) || tree} />}
      <hr style={{ margin: '2rem 0' }} />
      <h3>Full Dump:</h3>
      <pre style={{ whiteSpace: 'pre-wrap', fontSize: '0.85rem', maxHeight: '400px', overflow: 'auto' }}>{dumpText}</pre>
    </div>
  );
}

// --- Parsing Logic ---

function parseDumpToTree(dump: string): TreeNode {
    const root: any = { __files: [] };
    let currentFile: File | null = null;

    const ensureFolder = (parts: string[]): TreeNode => {
        let node = root;
        for (const part of parts) {
            if (!part) continue;
            if (!node[part]) {
                node[part] = { __files: [] };
            }
            node = node[part];
        }
        return node;
    };

    const lines = dump.split('\n');

    // Detect format quickly (@@ markers)
    const isAtMarkers = dump.includes('@@FILE:') || dump.includes('@@FOLDER:');
    if (isAtMarkers) {
        for (const rawLine of lines) {
            const line = rawLine.trimEnd();
            if (line.startsWith('@@FOLDER:')) {
                const folderPath = line.replace('@@FOLDER:', '').trim();
                const parts = folderPath.split('/').filter(Boolean);
                const start = parts[0] === 'src' ? 1 : 0;
                ensureFolder(parts.slice(start));
            } else if (line.startsWith('@@FILE:')) {
                const filePath = line.replace('@@FILE:', '').trim();
                const parts = filePath.split('/').filter(Boolean);
                const start = parts[0] === 'src' ? 1 : 0;
                const fileParts = parts.slice(start);
                const fileName = fileParts.pop()!;
                const folderNode = ensureFolder(fileParts);
                currentFile = { name: fileName, content: '' };
                folderNode.__files.push(currentFile);
            } else {
                if (currentFile) currentFile.content += rawLine + '\n';
            }
        }
        return root;
    }

    // Fallback to BEGIN/END format
    const BEGIN_SIG = '===== BEGIN FILE: ';
    const END_SIG = '===== END FILE';
    let filePath: string | null = null;

    for (const rawLine of lines) {
        if (filePath === null) {
            if (rawLine.startsWith(BEGIN_SIG)) {
                const p = rawLine.slice(BEGIN_SIG.length).replace(/ =====$/, '').trim();
                const parts = p.split('/').filter(Boolean);
                const start = parts[0] === 'src' ? 1 : 0;
                const fileParts = parts.slice(start);
                const fileName = fileParts.pop()!;
                const folderNode = ensureFolder(fileParts);
                currentFile = { name: fileName, content: '' };
                folderNode.__files.push(currentFile);
                filePath = p;
            }
        } else {
            if (rawLine === END_SIG) {
                // When a file ends, reset its content to ensure the next line doesn't get appended
                if (currentFile) {
                    currentFile.content = currentFile.content.trimEnd();
                }
                filePath = null;
                currentFile = null;
            } else if (currentFile) {
                currentFile.content += rawLine + '\n';
            }
        }
    }
    return root;
}
@@END_FILE@@
@@FILE: src/ui/components/StackInstructionsEditor.tsx
// src/ui/components/StackInstructionsEditor.tsx
import React from 'react';
import { Box, Typography, Divider, Checkbox, FormControlLabel, TextField } from '@mui/material';
import { CollapsibleSection } from './CollapsibleSection';
import { InfoDialog } from './InfoDialog';
import type { StackInstructions, ProsePolicy, DigestFilterPolicy, TokenPolicy, EmissionRule } from '../../models';

// Import the new, smaller components
import { PolicyEditor } from './stackInstructions/PolicyEditor';
import { DigestPolicyEditor } from './stackInstructions/DigestPolicyEditor';
import { TokenPolicyEditor } from './stackInstructions/TokenPolicyEditor';

interface StackInstructionsEditorProps {
  stackInstructions: StackInstructions;
  onStackInstructionsChange: (updatedInstructions: StackInstructions) => void;
}

const StackInstructionsEditor: React.FC<StackInstructionsEditorProps> = ({
  stackInstructions,
  onStackInstructionsChange,
}) => {
  // Generic handler to update a top-level policy object in the main state
  const handlePolicyChange = (
    policyKey: keyof StackInstructions,
    value: ProsePolicy | DigestFilterPolicy | TokenPolicy | Record<number, EmissionRule> | boolean | number
  ) => {
    onStackInstructionsChange({
      ...stackInstructions,
      [policyKey]: value,
    });
  };

  return (
    <CollapsibleSection title="🧠 Stack Instructions" initiallyExpanded={false}>
      <Box sx={{ mb: 3 }}>
        <Typography variant="body2" color="text.secondary">
          These settings control how previous game information (the 'context stack') is assembled
          and presented to the AI for each new turn.
          <InfoDialog
            title="Understanding the Context Stack"
            content={`The AI's 'memory' for each turn is built from a 'context stack'. The order and content of this stack significantly impact AI responses. Each section below can be individually enabled/disabled.`}
          />
        </Typography>
      </Box>

      {/* -- Use the new PolicyEditor for repeating patterns -- */}
      <PolicyEditor
        title="Narrator Prose Emission"
        policy={stackInstructions.narratorProseEmission}
        onPolicyChange={(p) => handlePolicyChange('narratorProseEmission', p)}
        infoContent={{
          main: "Controls how past narrator output (the main story text) is included in the AI's context.",
          mode: "- ALWAYS: Include all past narrator prose.\n- FIRST_N: Include prose only from the first 'N' turns.\n- AFTER_N: Include prose only from turns after 'N'.\n- NEVER: Do not include any past narrator prose.",
          filtering: "- NONE: Include all prose based on the selected mode.\n- SCENE_ONLY: Only include prose relevant to the current scene.\n- TAGGED: Only include prose that contains any recognized tags."
        }}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Use the new DigestPolicyEditor -- */}
      <DigestPolicyEditor
        digestPolicy={stackInstructions.digestPolicy}
        digestEmission={stackInstructions.digestEmission}
        onPolicyChange={(p) => handlePolicyChange('digestPolicy', p)}
        onEmissionChange={(e) => handlePolicyChange('digestEmission', e)}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Expression Log is another ProsePolicy, so reuse PolicyEditor -- */}
      <PolicyEditor
        title="Expression Log Policy"
        policy={stackInstructions.expressionLogPolicy}
        onPolicyChange={(p) => handlePolicyChange('expressionLogPolicy', p)}
        infoContent={{
          main: "Controls how character 'expression' (portions of past narrator prose related to character actions/emotions) is included.",
          mode: "Controls when expression logs are included (Always, First N turns, etc.).",
          filtering: "Filters which expression logs are included based on tags."
        }}
      />
      {/* Specific fields for Expression Log that aren't in the generic policy */}
      <Box sx={{ ml: 2, mt: -2, mb: 2 }}>
        <TextField
          label="Expression Lines Per Character"
          type="number"
          value={stackInstructions.expressionLinesPerCharacter}
          onChange={(e) => handlePolicyChange('expressionLinesPerCharacter', parseInt(e.target.value))}
          sx={{ my: 2, width: '250px' }}
          inputProps={{ min: 0 }}
          InputProps={{
            endAdornment: <InfoDialog title="Expression Lines Per Character" content="The maximum number of lines of narrative prose to extract and summarize for character expressions." />
          }}
        />
        <FormControlLabel
          control={
            <Checkbox
              checked={stackInstructions.emotionWeighting}
              onChange={(e) => handlePolicyChange('emotionWeighting', e.target.checked)}
            />
          }
          label="Emotion Weighting"
        />
      </Box>

      <Divider sx={{ my: 3 }} />

      <PolicyEditor
        title="World State Policy"
        policy={stackInstructions.worldStatePolicy}
        onPolicyChange={(p) => handlePolicyChange('worldStatePolicy', p)}
        infoContent={{
          main: "Controls how the current world state JSON is included in the AI's context.",
          mode: "Controls when the world state is included.",
          filtering: "Filters which parts of the world state are included (e.g., scene-only)."
        }}
      />

      <Divider sx={{ my: 3 }} />

      <PolicyEditor
        title="Known Entities Policy"
        policy={stackInstructions.knownEntitiesPolicy}
        onPolicyChange={(p) => handlePolicyChange('knownEntitiesPolicy', p)}
        infoContent={{
          main: "Controls how a list of 'known entities' (tagged items, characters, locations) is included. This list reminds the AI of important things without sending the full world state.",
          mode: "Controls when the known entities list is included.",
          filtering: "Filters which known entities are listed."
        }}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Use the new TokenPolicyEditor -- */}
      <TokenPolicyEditor
        tokenPolicy={stackInstructions.tokenPolicy}
        onPolicyChange={(p) => handlePolicyChange('tokenPolicy', p)}
      />
    </CollapsibleSection>
  );
};

export { StackInstructionsEditor };
@@END_FILE@@
@@FILE: src/ui/components/TurnNavigator.tsx
// src/ui/components/TurnNavigator.tsx
import React from 'react';
import { Box, IconButton, Typography, Tooltip } from '@mui/material';
import ArrowBackIosNewIcon from '@mui/icons-material/ArrowBackIosNew';
import ArrowForwardIosIcon from '@mui/icons-material/ArrowForwardIos';

interface TurnNavigatorProps {
  currentTurn: number;
  maxTurn: number;
  onNavigate: (turn: number) => void;
  isLoading: boolean;
}

export const TurnNavigator: React.FC<TurnNavigatorProps> = ({
  currentTurn,
  maxTurn,
  onNavigate,
  isLoading,
}) => {
  const canGoBack = currentTurn > 0;
  const canGoForward = currentTurn < maxTurn;

  return (
    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', p: 1, gap: 2, backgroundColor: 'action.selected', borderRadius: 2 }}>
      <Tooltip title="Previous Turn">
        <span>
          <IconButton onClick={() => onNavigate(currentTurn - 1)} disabled={!canGoBack || isLoading}>
            <ArrowBackIosNewIcon />
          </IconButton>
        </span>
      </Tooltip>
      <Typography variant="body1" sx={{ fontWeight: 'bold' }}>
        Turn {currentTurn} / {maxTurn}
      </Typography>
      <Tooltip title="Next Turn">
        <span>
          <IconButton onClick={() => onNavigate(currentTurn + 1)} disabled={!canGoForward || isLoading}>
            <ArrowForwardIosIcon />
          </IconButton>
        </span>
      </Tooltip>
    </Box>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/WorldStateCategory.tsx
import React from 'react';
import {
  Box,
  Typography,
  IconButton,
  Collapse,
  Checkbox,
  List,
  Divider,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import { WorldStateEntity } from './WorldStateEntity';
import { WorldStateItemRow } from './WorldStateItemRow';

interface WorldStateCategoryProps {
  categoryName: string;
  entities: Record<string, Record<string, any>>;
  isExpanded: boolean;
  areAllChildrenPinned: boolean;
  isAnyChildPinned: boolean;
  expandedEntities: Set<string>;
  worldStatePinnedKeys: string[];
  onToggleExpand: () => void;
  onTogglePin: () => void;
  onStartRename: () => void;
  onDelete: () => void;
  // Entity-level handlers
  onToggleEntityExpand: (entityKey: string) => void;
  onToggleEntityPin: (entityPath: string) => void;
  onStartRenameEntity: (category: string, entity: string) => void;
  onDeleteEntity: (category: string, entity: string) => void;
  // Variable-level handlers
  onDeleteKey: (key: string) => Promise<void>;
  onEditKey: (key: string, value: any) => Promise<void>;
  onToggleVariablePin: (key: string) => void;
}

export const WorldStateCategory: React.FC<WorldStateCategoryProps> = ({
  categoryName,
  entities,
  isExpanded,
  areAllChildrenPinned,
  isAnyChildPinned,
  expandedEntities,
  worldStatePinnedKeys,
  onToggleExpand,
  onTogglePin,
  onStartRename,
  onDelete,
  onToggleEntityExpand,
  onToggleEntityPin,
  onStartRenameEntity,
  onDeleteEntity,
  onDeleteKey,
  onEditKey,
  onToggleVariablePin,
}) => {
  return (
    <Box
      sx={{
        mb: 2,
        border: '1px solid',
        borderColor: 'divider',
        borderRadius: 1,
      }}
    >
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1.5,
          cursor: 'pointer',
          backgroundColor: 'action.hover',
        }}
        onClick={onToggleExpand}
      >
        <IconButton size="small" sx={{ mr: 1 }}>
          {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {categoryName}
        </Typography>
        <IconButton
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            onStartRename();
          }}
        >
          <EditIcon fontSize="small" />
        </IconButton>
        <Checkbox
          checked={areAllChildrenPinned}
          indeterminate={isAnyChildPinned && !areAllChildrenPinned}
          onClick={(e) => {
            e.stopPropagation();
            onTogglePin();
          }}
        />
        <IconButton
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            onDelete();
          }}
        >
          <DeleteIcon fontSize="small" color="error" />
        </IconButton>
      </Box>
      <Collapse in={isExpanded}>
        <Divider />
        <List component="div" disablePadding sx={{ pl: 2, pr: 1, pt: 1 }}>
          {Object.entries(entities).map(([entityKey, variables]) => {
            const entityPath = `${categoryName}.${entityKey}`;

            if (entityKey === '@@_direct') {
              return Object.entries(variables).map(([varName, value]) => (
                <WorldStateItemRow
                  key={`${categoryName}.${varName}`}
                  itemKey={`${categoryName}.${varName}`}
                  value={value}
                  onDelete={onDeleteKey}
                  onEdit={onEditKey}
                  isPinned={worldStatePinnedKeys.includes(`${categoryName}.${varName}`)}
                  onTogglePin={onToggleVariablePin}
                />
              ));
            }

            return (
              <WorldStateEntity
                key={entityPath}
                categoryName={categoryName}
                entityKey={entityKey}
                entityPath={entityPath}
                variables={variables}
                isExpanded={expandedEntities.has(entityPath)}
                worldStatePinnedKeys={worldStatePinnedKeys}
                onToggleExpand={() => onToggleEntityExpand(entityPath)}
                onTogglePin={() => onToggleEntityPin(entityPath)}
                onStartRename={() => onStartRenameEntity(categoryName, entityKey)}
                onDelete={() => onDeleteEntity(categoryName, entityKey)}
                onDeleteKey={onDeleteKey}
                onEditKey={onEditKey}
                onToggleVariablePin={onToggleVariablePin}
              />
            );
          })}
        </List>
      </Collapse>
    </Box>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/WorldStateEntity.tsx
import React from 'react';
import {
  Box,
  Typography,
  IconButton,
  Collapse,
  Checkbox,
  Divider,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import { WorldStateItemRow } from './WorldStateItemRow';
import { flattenJsonObject } from '../../utils/jsonUtils';

interface WorldStateEntityProps {
  categoryName: string;
  entityKey: string;
  entityPath: string;
  variables: Record<string, any>;
  isExpanded: boolean;
  worldStatePinnedKeys: string[];
  onToggleExpand: () => void;
  onTogglePin: () => void;
  onStartRename: () => void;
  onDelete: () => void;
  onDeleteKey: (key: string) => Promise<void>;
  onEditKey: (key: string, value: any) => Promise<void>;
  onToggleVariablePin: (key: string) => void;
}

export const WorldStateEntity: React.FC<WorldStateEntityProps> = ({
  entityPath,
  variables,
  isExpanded,
  worldStatePinnedKeys,
  onToggleExpand,
  onTogglePin,
  onStartRename,
  onDelete,
  onDeleteKey,
  onEditKey,
  onToggleVariablePin,
}) => {
  const childVariableKeys = React.useMemo(
    () => Object.keys(flattenJsonObject(variables, entityPath)),
    [variables, entityPath]
  );

  const areAllChildrenPinned =
    childVariableKeys.length > 0 &&
    childVariableKeys.every((key) => worldStatePinnedKeys.includes(key));

  const isAnyChildPinned =
    childVariableKeys.length > 0 &&
    childVariableKeys.some((key) => worldStatePinnedKeys.includes(key));

  const entityDisplayName = entityPath.split('.').pop() || entityPath;

  return (
    <Box
      sx={{
        mb: 1,
        border: '1px dashed',
        borderColor: 'divider',
        borderRadius: 1,
        mt: 1,
      }}
    >
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1,
          cursor: 'pointer',
        }}
        onClick={onToggleExpand}
      >
        <IconButton size="small" sx={{ mr: 1 }}>
          {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
        <Typography variant="subtitle1" sx={{ flexGrow: 1 }}>
          {entityDisplayName}
        </Typography>
        <IconButton
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            onStartRename();
          }}
        >
          <EditIcon fontSize="small" />
        </IconButton>
        <Checkbox
          checked={areAllChildrenPinned}
          indeterminate={isAnyChildPinned && !areAllChildrenPinned}
          onClick={(e) => {
            e.stopPropagation();
            onTogglePin();
          }}
        />
        <IconButton
          size="small"
          onClick={(e) => {
            e.stopPropagation();
            onDelete();
          }}
        >
          <DeleteIcon fontSize="small" color="error" />
        </IconButton>
      </Box>
      <Collapse in={isExpanded}>
        <Divider />
        <Box sx={{ p: 1.5 }}>
          {Object.entries(variables).map(([varName, value]) => (
            <WorldStateItemRow
              key={varName}
              itemKey={`${entityPath}.${varName}`}
              value={value}
              onDelete={onDeleteKey}
              onEdit={onEditKey}
              isPinned={worldStatePinnedKeys.includes(`${entityPath}.${varName}`)}
              onTogglePin={() => onToggleVariablePin(`${entityPath}.${varName}`)}
            />
          ))}
        </Box>
      </Collapse>
    </Box>
  );
};

@@END_FILE@@
@@FILE: src/ui/components/WorldStateItemRow.tsx
// src/ui/components/WorldStateItemRow.tsx

import React, { useState } from 'react';
import {
  Box,
  Typography,
  IconButton,
  TextField,
  InputAdornment,
  Checkbox,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import PushPinIcon from '@mui/icons-material/PushPin';
import PushPinOutlinedIcon from '@mui/icons-material/PushPinOutlined';
import { parseJsonPrimitive } from '../../utils/jsonUtils';

interface WorldStateItemRowProps {
  itemKey: string; // Full key, e.g., "npcs.goblin_1.hp"
  value: any; // The raw value, JsonElement equivalent
  onDelete: (key: string) => Promise<void>; // Make it async as store actions might be async
  onEdit: (key: string, value: any) => Promise<void>; // Make it async
  isPinned: boolean;
  onTogglePin: (key: string) => void; // This will call the store's toggleWorldStatePin with 'variable' type
}

export const WorldStateItemRow: React.FC<WorldStateItemRowProps> = ({
  itemKey,
  value,
  onDelete,
  onEdit,
  isPinned,
  onTogglePin,
}) => {
  const [editMode, setEditMode] = useState(false);
  const [editText, setEditText] = useState(JSON.stringify(value)); // Use JSON.stringify for complex values

  // Extract the last part of the key for display name
  const displayName = itemKey.substring(itemKey.lastIndexOf('.') + 1);

  const handleEditConfirm = async () => {
    try {
      const parsedValue = parseJsonPrimitive(editText);
      await onEdit(itemKey, parsedValue); // Await the async edit operation
      setEditMode(false);
    } catch (e) {
      console.error("Failed to parse input for world state edit:", e);
      // TODO: Provide user feedback (e.g., Snackbar) for parsing errors
    }
  };

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        mb: 1,
        p: 1,
        borderRadius: 1,
        backgroundColor: (theme) => (editMode ? theme.palette.action.hover : 'transparent'),
      }}
    >
      <Typography variant="body2" sx={{ fontWeight: 'bold', flexShrink: 0 }}>
        {displayName}:
      </Typography>
      <Box sx={{ flexGrow: 1 }}>
        {editMode ? (
          <TextField
            fullWidth
            size="small"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onBlur={handleEditConfirm}
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleEditConfirm();
              }
            }}
            InputProps={{
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton size="small" onClick={handleEditConfirm}>
                    <EditIcon fontSize="small" />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        ) : (
          <Typography
            variant="body2"
            sx={{
              cursor: 'pointer',
              border: '1px solid',
              borderColor: (theme) => theme.palette.divider,
              borderRadius: 1,
              p: 0.8,
              '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
            }}
            onClick={() => setEditMode(true)}
          >
            {JSON.stringify(value)}
          </Typography>
        )}
      </Box>
      <Checkbox
        icon={<PushPinOutlinedIcon fontSize="small" />}
        checkedIcon={<PushPinIcon fontSize="small" />}
        checked={isPinned}
        onChange={() => onTogglePin(itemKey)} // Pass the full itemKey
        size="small"
        sx={{ p: 0.5 }}
      />
      <IconButton size="small" onClick={() => onDelete(itemKey)} sx={{ p: 0.5 }}>
        <DeleteIcon fontSize="small" color="error" />
      </IconButton>
    </Box>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/stackInstructions/DigestPolicyEditor.tsx
// src/ui/components/stackInstructions/DigestPolicyEditor.tsx
import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  RadioGroup,
  FormControlLabel,
  Radio,
  Grid,
  Switch,
} from '@mui/material';
import type {
  DigestFilterPolicy,
  EmissionRule
} from '../../../models';

import  {
  StackMode,
  FilterMode,
} from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface DigestPolicyEditorProps {
  digestPolicy: DigestFilterPolicy;
  digestEmission: Record<number, EmissionRule>;
  onPolicyChange: (updatedPolicy: DigestFilterPolicy) => void;
  onEmissionChange: (updatedEmission: Record<number, EmissionRule>) => void;
}

export const DigestPolicyEditor: React.FC<DigestPolicyEditorProps> = ({
  digestPolicy,
  digestEmission,
  onPolicyChange,
  onEmissionChange,
}) => {
  const handleEmissionRuleChange = (score: number, field: keyof EmissionRule, value: any) => {
    const currentRule = digestEmission[score] || { mode: StackMode.NEVER, n: 0 };
    onEmissionChange({
      ...digestEmission,
      [score]: { ...currentRule, [field]: value },
    });
  };

  return (
    <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          Digest Lines Emission & Policy
        </Typography>
        <FormControlLabel
          control={
            <Switch
              checked={digestPolicy.enabled ?? false}
              onChange={(e) => onPolicyChange({ ...digestPolicy, enabled: e.target.checked })}
            />
          }
          label="Enable"
          labelPlacement="start"
        />
      </Box>
      <Box sx={{ opacity: digestPolicy.enabled ? 1 : 0.5, pointerEvents: digestPolicy.enabled ? 'auto' : 'none' }}>
        <Typography gutterBottom>
          Global Digest Filtering Policy
          <InfoDialog
            title="Global Digest Filtering Policy"
            content={`Applies a filter to ALL digest lines before their individual emission rules are checked.\n\n- NONE: No global filtering.\n- SCENE_ONLY: Only consider digests relevant to the current scene.\n- TAGGED: Only consider digests that have any tags.`}
          />
        </Typography>
        <FormControl component="fieldset" fullWidth margin="normal">
          <RadioGroup
            row
            value={digestPolicy.filtering}
            onChange={(e) => onPolicyChange({ ...digestPolicy, filtering: e.target.value as FilterMode })}
          >
            {Object.values(FilterMode).map((mode) => (
              <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
            ))}
          </RadioGroup>
        </FormControl>
        <Grid container spacing={2} sx={{ mt: 2 }}>
          {[5, 4, 3, 2, 1].map((score) => (
            // 1. Grid item is now ONLY responsible for layout.
            <Grid item xs={12} sm={6} md={4} key={score}>
              {/* 2. A nested Box handles ALL styling (border, padding). This resolves the error. */}
              <Box sx={{ border: '1px solid', borderColor: 'divider', p: 1.5, borderRadius: 1 }}>
                <Typography variant="subtitle2">
                  Importance {score} Digests
                  <InfoDialog
                    title={`Digest Importance Score ${score} Rule`}
                    content={`Determines how digest lines with an importance score of ${score} are included.`}
                  />
                </Typography>
                <FormControl component="fieldset" fullWidth size="small">
                  <RadioGroup
                    row
                    value={digestEmission[score]?.mode || StackMode.NEVER}
                    onChange={(e) => handleEmissionRuleChange(score, 'mode', e.target.value as StackMode)}
                  >
                    {Object.values(StackMode).filter(m => m !== StackMode.FILTERED).map((mode) => (
                      <FormControlLabel key={mode} value={mode} control={<Radio size="small" />} label={mode} sx={{ mb: -1 }}/>
                    ))}
                  </RadioGroup>
                  {(digestEmission[score]?.mode === StackMode.FIRST_N ||
                    digestEmission[score]?.mode === StackMode.AFTER_N) && (
                      <TextField
                        label="N"
                        type="number"
                        value={digestEmission[score]?.n || 0}
                        onChange={(e) => handleEmissionRuleChange(score, 'n', parseInt(e.target.value))}
                        size="small"
                        sx={{ mt: 1, width: '100px' }}
                        inputProps={{ min: 0 }}
                      />
                    )}
                </FormControl>
              </Box>
            </Grid>
          ))}
        </Grid>        
      </Box>
    </Box>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/stackInstructions/PolicyEditor.tsx
// src/ui/components/stackInstructions/PolicyEditor.tsx
import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  RadioGroup,
  FormControlLabel,
  Radio,
  InputLabel,
  Select,
  MenuItem,
  Switch,
} from '@mui/material';
import type { ProsePolicy} from '../../../models';
import {StackMode, FilterMode } from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface PolicyEditorProps {
  title: string;
  policy: ProsePolicy;
  onPolicyChange: (updatedPolicy: ProsePolicy) => void;
  infoContent: {
    main: string;
    mode: string;
    filtering: string;
  };
}

export const PolicyEditor: React.FC<PolicyEditorProps> = ({
  title,
  policy,
  onPolicyChange,
  infoContent,
}) => {
  const handleFieldChange = (field: keyof ProsePolicy, value: any) => {
    onPolicyChange({ ...policy, [field]: value });
  };

  return (
    <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
          <InfoDialog title={title} content={infoContent.main} />
        </Typography>
        <FormControlLabel
          control={
            <Switch
              checked={policy.enabled ?? false}
              onChange={(e) => handleFieldChange('enabled', e.target.checked)}
            />
          }
          label="Enable"
          labelPlacement="start"
        />
      </Box>
      <Box sx={{ opacity: policy.enabled ? 1 : 0.5, pointerEvents: policy.enabled ? 'auto' : 'none' }}>
        <Typography gutterBottom>
          Mode
          <InfoDialog title={`${title} Mode`} content={infoContent.mode} />
        </Typography>
        <FormControl component="fieldset" fullWidth margin="normal">
          <RadioGroup
            row
            value={policy.mode}
            onChange={(e) => handleFieldChange('mode', e.target.value as StackMode)}
          >
            {Object.values(StackMode).filter(m => m !== StackMode.FILTERED).map((mode) => (
              <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
            ))}
          </RadioGroup>
          {(policy.mode === StackMode.FIRST_N || policy.mode === StackMode.AFTER_N) && (
            <TextField
              label="N (Turns)"
              type="number"
              value={policy.n}
              onChange={(e) => handleFieldChange('n', parseInt(e.target.value))}
              sx={{ mt: 1, width: '150px' }}
              inputProps={{ min: 0 }}
            />
          )}
        </FormControl>

        <Typography gutterBottom sx={{ mt: 2 }}>
          Filtering
          <InfoDialog title={`${title} Filtering`} content={infoContent.filtering} />
        </Typography>
        <FormControl fullWidth>
          <InputLabel id={`${title}-filtering-label`}>Filtering</InputLabel>
          <Select
            labelId={`${title}-filtering-label`}
            value={policy.filtering}
            label="Filtering"
            onChange={(e) => handleFieldChange('filtering', e.target.value as FilterMode)}
          >
            {Object.values(FilterMode).map((mode) => (
              <MenuItem key={mode} value={mode}>{mode}</MenuItem>
            ))}
          </Select>
        </FormControl>
      </Box>
    </Box>
  );
};
@@END_FILE@@
@@FILE: src/ui/components/stackInstructions/TokenPolicyEditor.tsx
// src/ui/components/stackInstructions/TokenPolicyEditor.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';
import type { TokenPolicy } from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface TokenPolicyEditorProps {
  tokenPolicy: TokenPolicy;
  onPolicyChange: (updatedPolicy: TokenPolicy) => void;
}

export const TokenPolicyEditor: React.FC<TokenPolicyEditorProps> = ({
  tokenPolicy,
  onPolicyChange,
}) => {
  const handleFieldChange = (field: keyof TokenPolicy, value: any) => {
    onPolicyChange({ ...tokenPolicy, [field]: value });
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Token Policy
      </Typography>
      <TextField
        fullWidth
        label="Min Tokens"
        type="number"
        value={tokenPolicy.minTokens}
        onChange={(e) => handleFieldChange('minTokens', parseInt(e.target.value))}
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
        InputProps={{
          endAdornment: <InfoDialog title="Min Tokens" content="The AI will attempt to generate a response of at least this many tokens." />
        }}
      />
      <TextField
        fullWidth
        label="Max Tokens"
        type="number"
        value={tokenPolicy.maxTokens}
        onChange={(e) => handleFieldChange('maxTokens', parseInt(e.target.value))}
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
        InputProps={{
          endAdornment: <InfoDialog title="Max Tokens" content="The absolute maximum number of tokens the AI can generate." />
        }}
      />
      <TextField
        fullWidth
        label="Fallback Plan"
        value={tokenPolicy.fallbackPlan.join(', ')}
        onChange={(e) => handleFieldChange('fallbackPlan', e.target.value.split(',').map((s) => s.trim()))}
        sx={{ mb: 2 }}
        InputProps={{
          endAdornment: <InfoDialog title="Fallback Plan" content={`A prioritized, comma-separated list of strategies the system will use to reduce the *input prompt's* token count if it exceeds the AI model's context window.\n\nCommon Strategies:\ndrop_known_entities, drop_low_importance_digest, truncate_expression_logs, drop_narrator_prose, truncate_conversation_history`} />
        }}
      />
    </Box>
  );
};
@@END_FILE@@
@@FILE: src/ui/screens/CardLibraryScreen.tsx
// src/ui/screens/PromptCardLibraryScreen.tsx
// RENAMED from GameLibraryScreen.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  TextField,
  InputAdornment,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import type { PromptCard } from '../../models';
import Snackbar from '@mui/material/Snackbar';
import { useNavigate } from 'react-router-dom';


interface PromptCardLibraryScreenProps { // RENAMED interface
  onNavToggle: () => void;
  // onNavigateToEditor: (cardId?: string) => void; // To navigate to editor with a specific card
}

const PromptCardLibraryScreen: React.FC<PromptCardLibraryScreenProps> = ({ onNavToggle }) => { // RENAMED component
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const {
    promptCards,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    deletePromptCard,
  } = usePromptCardStore();
  const { initializeGame } = useGameStateStore();

  const [searchTerm, setSearchTerm] = useState('');
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info'>('info');


  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
    }
  }, [user?.uid, fetchPromptCards]);

  const filteredCards = promptCards.filter(card =>
    card.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  const handleEditCard = (card: PromptCard) => {
    setActivePromptCard(card);
    // Navigate to PromptCardManager/Editor screen
    navigate('/cards'); // Navigate to the PromptCardManager
    setSnackbarMessage(`Editing "${card.title}"`);
    setSnackbarSeverity('info');
    console.log(`Navigating to editor for card: ${card.id}`);
  };

  const handleDeleteCard = async (cardId: string) => {
    if (!user?.uid) return;
    try {
      await deletePromptCard(user.uid, cardId);
      setSnackbarMessage('Card deleted successfully!');
      setSnackbarSeverity('success');
    } catch (e) {
      setSnackbarMessage(`Failed to delete card: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };

  const handleStartGame = async (card: PromptCard) => {
    if (!user?.uid) {
      setSnackbarMessage('Must be logged in to start a game.');
      setSnackbarSeverity('error');
      return;
    }
    try {
      // First, set the active card, then initialize game
      setActivePromptCard(card);
      await initializeGame(user.uid, card.id);
      setSnackbarMessage(`Game "${card.title}" initialized! Navigating to game...`);
      setSnackbarSeverity('success');
      navigate('/game'); // Navigate to the GameScreen
      console.log(`Game "${card.title}" started! Navigating to GameScreen.`);
    } catch (e) {
      setSnackbarMessage(`Failed to start game: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };


  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Card Library...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Prompt Card Library
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {error && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {error}
        </Alert>
      )}

      <Box sx={{ p: 2 }}>
        <TextField
          fullWidth
          label="Search Cards"
          variant="outlined"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon />
              </InputAdornment>
            ),
          }}
          sx={{ mb: 2 }}
        />
      </Box>

      <Paper elevation={1} sx={{ flexGrow: 1, m: 2, overflowY: 'auto' }}>
        {filteredCards.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              {searchTerm ? "No cards match your search." : "No cards available. Go to Prompt Cards Manager to create one!"}
            </Typography>
            <Button variant="contained" startIcon={<AddIcon />} sx={{ mt: 2 }} onClick={() => navigate('/cards')}>
              Go to Prompt Card Manager
            </Button>
          </Box>
        ) : (
          <List>
            {filteredCards.map((card) => (
              <React.Fragment key={card.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="start-game" onClick={() => handleStartGame(card)}>
                        <PlayArrowIcon color="primary" />
                      </IconButton>
                      <IconButton edge="end" aria-label="edit-card" onClick={() => handleEditCard(card)}>
                        <EditIcon />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete-card" onClick={() => handleDeleteCard(card.id)}>
                        <DeleteIcon color="error" />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={card.title}
                    secondary={card.description || 'No description'}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>
      <Snackbar
        open={!!snackbarMessage}
        autoHideDuration={6000}
        onClose={() => setSnackbarMessage(null)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={() => setSnackbarMessage(null)} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardLibraryScreen;
@@END_FILE@@
@@FILE: src/ui/screens/GameLibraryScreen.tsx
import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  IconButton,
  Snackbar,
} from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import DeleteIcon from '@mui/icons-material/Delete';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { gameRepository } from '../../data/repositories/gameRepository';
import { useNavigate } from 'react-router-dom';
import type { GameSnapshot } from '../../models';
import { formatIsoDateForDisplay } from '../../utils/formatDate';

const GameLibraryScreen: React.FC = () => {
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const { loadGame, gameLoading } = useGameStateStore();

  const [savedGames, setSavedGames] = useState<GameSnapshot[]>([]);
  const [loadingSavedGames, setLoadingSavedGames] = useState(true);
  const [savedGamesError, setSavedGamesError] = useState<string | null>(null);
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info' | 'warning'>('info');
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  const fetchSavedGames = async (userId: string) => {
    setLoadingSavedGames(true);
    setSavedGamesError(null);
    try {
      const games = await gameRepository.getAllGameSnapshots(userId);
      setSavedGames(games);
    } catch (e: any) {
      setSavedGamesError(e.message || 'Failed to fetch saved games.');
    } finally {
      setLoadingSavedGames(false);
    }
  };

  useEffect(() => {
    if (user?.uid) {
      fetchSavedGames(user.uid);
    }
  }, [user?.uid]);

  const showSnackbar = (
    message: string,
    severity: 'success' | 'error' | 'info' | 'warning' = 'info'
  ) => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };

  const handleSnackbarClose = (event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') return;
    setSnackbarOpen(false);
  };

  const handleLoadGame = async (snapshotId: string) => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to load a game.', 'error');
      return;
    }
    try {
      await loadGame(user.uid, snapshotId);
      showSnackbar('Game loaded successfully! Navigating to game...', 'success');
      navigate('/game');
    } catch (e) {
      showSnackbar(
        `Failed to load game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  const handleDeleteGame = async (snapshotId: string) => {
    if (!user?.uid) return;
    try {
      await gameRepository.deleteGameSnapshot(user.uid, snapshotId);
      fetchSavedGames(user.uid);
      showSnackbar('Game deleted successfully!', 'success');
    } catch (e) {
      showSnackbar(
        `Failed to delete game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  if (loadingSavedGames || gameLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>
          Loading Games...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">
          Game Library (Saved Games)
        </Typography>
      </Box>

      {savedGamesError && (
        <Alert
          severity="error"
          sx={{
            m: 2,
            backgroundColor: (theme) => theme.palette.background.paper,
            color: (theme) => theme.palette.text.primary,
          }}
        >
          Error: {savedGamesError}
        </Alert>
      )}

      <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
        <Button
          variant="contained"
          color="primary"
          sx={{ mt: 2 }}
          onClick={() => navigate('/cards')}
        >
          Start New Game (Select Prompt Card)
        </Button>
      </Box>

      <Paper
        elevation={1}
        sx={{
          flexGrow: 1,
          m: 2,
          overflowY: 'auto',
          backgroundColor: (theme) => theme.palette.background.paper,
        }}
      >
        {savedGames.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              No saved games found. Start a new one!
            </Typography>
          </Box>
        ) : (
          <List>
            {savedGames.map((game) => (
              <React.Fragment key={game.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="load-game" onClick={() => handleLoadGame(game.id)}>
                        <PlayArrowIcon sx={{ color: (theme) => theme.palette.primary.main }} />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete-game" onClick={() => handleDeleteGame(game.id)}>
                        <DeleteIcon sx={{ color: (theme) => theme.palette.error.main }} />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={game.title}
                    secondary={`Turn: ${game.currentTurn} | Last Saved: ${formatIsoDateForDisplay(game.updatedAt)}`}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>

      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default GameLibraryScreen;

@@END_FILE@@
@@FILE: src/ui/screens/GameScreen.tsx
// src/ui/screens/GameScreen.tsx

import React, { useState, useEffect, useRef, useCallback } from 'react';
import {
  Box, Paper, Typography, TextField, IconButton, Stack, Divider,
  CircularProgress, Button, Fab,
  Dialog, DialogActions, DialogContent, DialogTitle,
  Snackbar, Alert
} from '@mui/material';

import type {AlertColor} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import CasinoIcon from '@mui/icons-material/Casino';
import { TurnNavigator } from '../components/TurnNavigator';
import { useGameStateStore, selectConversationHistory } from '../../state/useGameStateStore';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { PinnedItemsView } from '../components/PinnedItemsView';
import { DiceRoller } from '../../utils/diceRoller';
import { useLongPress } from '../../utils/hooks/useLongPress';

export const GameScreen: React.FC = () => {
  const {
    gameLoading,
    isProcessingTurn,
    processTurn,
    currentSnapshot,    
    maxTurn,            
    navigateToTurn,   
  } = useGameStateStore();

  const conversationHistory = useGameStateStore(selectConversationHistory);
  const activePromptCard = usePromptCardStore((state) => state.activePromptCard);

  const [userInput, setUserInput] = useState('');
  const logEndRef = useRef<HTMLDivElement>(null);

  const [isRollDialogOpen, setIsRollDialogOpen] = useState(false);
  const [rollFormula, setRollFormula] = useState('1d20');
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'info' as AlertColor });

  const showSnackbar = (message: string, severity: AlertColor = 'info') => {
    setSnackbar({ open: true, message, severity });
  };
  const closeSnackbar = () => setSnackbar(prev => ({ ...prev, open: false }));

  const handleQuickRoll = useCallback(async () => {
    if (isProcessingTurn) return;
    try {
      const result = DiceRoller.roll(rollFormula);
      const summary = DiceRoller.format(result);
      const actionString = `(The player quickly rolls ${rollFormula}. Result: ${summary})`;
      await processTurn(actionString);
      showSnackbar(`Rolled ${rollFormula}: ${summary}`, 'success');
    } catch (e) {
      showSnackbar("Invalid dice formula. Long-press the dice icon to fix it.", 'error');
    }
  }, [rollFormula, isProcessingTurn, processTurn]);

  const handleOpenRollDialog = () => setIsRollDialogOpen(true);
  const handleCloseRollDialog = () => setIsRollDialogOpen(false);
  
  const handleRollFromDialog = useCallback(async () => {
    await handleQuickRoll();
    handleCloseRollDialog();
  }, [handleQuickRoll]);
  
  const longPressProps = useLongPress(
    handleOpenRollDialog,
    handleQuickRoll,
    { delay: 400 }
  );

  useEffect(() => {
    logEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [conversationHistory]);

  const handleSubmit = useCallback(async () => {
    if (!userInput.trim() || isProcessingTurn) return;
    await processTurn(userInput);
    setUserInput('');
  }, [userInput, isProcessingTurn, processTurn]);

  const handleKeyPress = useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  }, [handleSubmit]);

  if (gameLoading || !activePromptCard) {
    return (
      <Box sx={{ p: 3, display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Game...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ position: 'relative', display: 'flex', flexDirection: 'column', height: '100%', p: 2 }}>
      <PinnedItemsView />
      <Divider sx={{ my: 1 }} />
      {/* ADD TURN NAVIGATOR HERE */}
      {activePromptCard?.historyBrowsingEnabled && currentSnapshot && maxTurn !== null && (
        <TurnNavigator
          currentTurn={currentSnapshot.currentTurn}
          maxTurn={maxTurn}
          onNavigate={navigateToTurn}
          isLoading={isProcessingTurn || gameLoading}
        />
      )}
      <Box sx={{ flex: 1, overflowY: 'auto', px: 1, pb: 8 }}>
        {conversationHistory.map((msg, index) => (
          <Paper key={index} elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
            <Typography variant="body2" sx={{ fontWeight: 'bold', color: msg.role === 'user' ? 'primary.main' : 'secondary.main' }}>
              {msg.role === 'user' ? 'You' : 'Narrator'}
            </Typography>
            <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
              {msg.content}
            </Typography>
          </Paper>
        ))}
        {isProcessingTurn && (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 2 }}>
            <CircularProgress size={30} />
          </Box>
        )}
        <div ref={logEndRef} />
      </Box>

      <Fab
        color="secondary"
        aria-label="roll dice"
        {...longPressProps}
        sx={{
          position: 'absolute',
          bottom: 120, 
          right: 32,
        }}
      >
        <CasinoIcon />
      </Fab>

      <Dialog open={isRollDialogOpen} onClose={handleCloseRollDialog}>
        <DialogTitle>Set Dice Formula</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Dice Formula"
            type="text"
            fullWidth
            variant="standard"
            value={rollFormula}
            onChange={(e) => setRollFormula(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleRollFromDialog()}
            placeholder="e.g., 2d6+3"
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseRollDialog}>Cancel</Button>
          <Button onClick={handleRollFromDialog} variant="contained">Roll</Button>
        </DialogActions>
      </Dialog>
      
      <Snackbar open={snackbar.open} autoHideDuration={4000} onClose={closeSnackbar}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>

      <Paper elevation={3} sx={{ p: 1, mt: 1 }}>
        <Stack direction="row" spacing={1} alignItems="center">
          <TextField
            fullWidth
            placeholder="What do you do next?"
            multiline
            minRows={1}
            maxRows={5}
            value={userInput}
            onChange={(e) => setUserInput(e.target.value)}
            onKeyPress={handleKeyPress}
            disabled={isProcessingTurn}
          />
          <IconButton onClick={handleSubmit} color="primary" disabled={isProcessingTurn || !userInput.trim()}>
            <SendIcon />
          </IconButton>
        </Stack>
      </Paper>
    </Box>
  );
};
@@END_FILE@@
@@FILE: src/ui/screens/LogViewerScreen.tsx
// src/ui/screens/LogViewerScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  Box, Typography, Paper, Alert, Fab, Popover,
  List, ListItem, ListItemIcon, ListItemText, Checkbox
} from '@mui/material';
import TuneIcon from '@mui/icons-material/Tune'; // A more fitting icon for "views/filters"
import { useLogStore } from '../../state/useLogStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { LogViewMode } from '../../utils/types';
import { DetailedLogTurnView } from '../components/DetailedLogTurnView';

export const LogViewerScreen: React.FC = () => {
  const { logEntries, selectedLogViewModes, setLogEntries, setSelectedLogViewModes } = useLogStore();
  const currentSnapshot = useGameStateStore(state => state.currentSnapshot);

  // The critical synchronization effect
  useEffect(() => {
    setLogEntries(currentSnapshot?.logs || []);
  }, [currentSnapshot, setLogEntries]);

  // State for the Popover menu
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const isMenuOpen = Boolean(anchorEl);

  const handleMenuClick = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleCheckboxChange = (mode: LogViewMode) => {
    const newSelection = selectedLogViewModes.includes(mode)
      ? selectedLogViewModes.filter((m) => m !== mode)
      : [...selectedLogViewModes, mode];
    setSelectedLogViewModes(newSelection);
  };

  return (
    // Use position relative to anchor the floating button
    <Box sx={{ position: 'relative', height: '100%', p: 2 }}>
      <Typography variant="h5" component="h1" sx={{ mb: 2, textAlign: 'center' }}>
        Game Log
      </Typography>

      <Paper elevation={2} sx={{ height: 'calc(100% - 60px)', overflowY: 'auto' }}>
        {logEntries.length === 0 ? (
          <Box sx={{ p: 4, textAlign: 'center' }}>
            <Typography color="text.secondary">No log entries to display.</Typography>
          </Box>
        ) : (
          logEntries.map((entry) => (
            <Box key={entry.turnNumber} sx={{ p: 1 }}>
              <DetailedLogTurnView
                entry={entry}
                selectedLogViewModes={selectedLogViewModes}
              />
            </Box>
          ))
        )}
      </Paper>

      {/* Floating Action Button (FAB) for the menu */}
      <Fab
        color="primary"
        aria-label="log views"
        onClick={handleMenuClick}
        sx={{ position: 'absolute', bottom: 32, right: 32 }}
      >
        <TuneIcon />
      </Fab>

      {/* Popover Menu - Non-blocking */}
      <Popover
        open={isMenuOpen}
        anchorEl={anchorEl}
        onClose={handleMenuClose}
        anchorOrigin={{ vertical: 'top', horizontal: 'left' }}
        transformOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Paper sx={{ width: 320 }}>
          <List dense>
          {logEntries.map((entry) => (
            <Box key={entry.turnNumber} sx={{ p: 1 }}>
              <DetailedLogTurnView // <-- This is the main component to use
                entry={entry}
                selectedLogViewModes={selectedLogViewModes}
              />
            </Box>
          ))}
          </List>
        </Paper>
      </Popover>
    </Box>
  );
};
@@END_FILE@@
@@FILE: src/ui/screens/LoginScreen.tsx
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom'; // Add this
import { useAuthStore } from '../../state/useAuthStore';

const styles: { [key: string]: React.CSSProperties } = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: '100vh',
    backgroundColor: '#f0f2f5',
    fontFamily: 'Arial, sans-serif',
    padding: '20px',
  },
  button: {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#4285F4',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    marginTop: '20px',
    transition: 'background-color 0.3s ease',
  },
  errorText: {
    color: 'red',
    marginTop: '10px',
  },
};


const LoginScreen: React.FC = () => {
  const { user, isLoading, error, signIn, signOut } = useAuthStore();
  const navigate = useNavigate(); // Add this

  // ✅ Redirect out of login screen if user is authenticated
  useEffect(() => {
    if (user) {
      navigate('/library', { replace: true });
    }
  }, [user, navigate]);

  if (isLoading) {
    return (
      <div style={styles.container}>
        <h2>Loading Authentication Status...</h2>
      </div>
    );
  }

  if (user) {
    return (
      <div style={styles.container}>
        <h2>Welcome, {user.displayName || user.email}!</h2>
        <p>Your User ID: {user.uid}</p>
        <button onClick={signOut} style={styles.button}>
          Sign Out
        </button>
      </div>
    );
  } else {
    return (
      <div style={styles.container}>
        <h2>Please Log In to StoryForge</h2>
        {error && <p style={styles.errorText}>Error: {error}</p>}
        <button onClick={signIn} style={styles.button}>
          Sign in with Google
        </button>
      </div>
    );
  }
};
export default LoginScreen;
@@END_FILE@@
@@FILE: src/ui/screens/PromptCardEditor.tsx
// src/ui/screens/PromptCardEditor.tsx
import React from 'react';
import { Box, Divider, FormControlLabel, Switch, TextField } from '@mui/material';
import type { PromptCard, AiConnection } from '../../models';

// Import the more complex, reusable editor components
import { AiSettingsEditor } from '../components/AiSettingsEditor';
import { StackInstructionsEditor } from '../components/StackInstructionsEditor';
import { CollapsibleSection } from '../components/CollapsibleSection';
import { InfoDialog } from '../components/InfoDialog';

// Import constants for placeholders
import {
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../../data/config/promptCardDefaults';

interface PromptCardEditorProps {
  card: PromptCard;
  onCardChange: (updatedCard: PromptCard) => void;
  availableConnections: AiConnection[];
}

const PromptCardEditor: React.FC<PromptCardEditorProps> = ({
  card,
  onCardChange,
  availableConnections,
}) => {
  // A single handler to update the parent component's state
  const handleFieldChange = (updates: Partial<PromptCard>) => {
    onCardChange({ ...card, ...updates });
  };

  return (
    <Box sx={{ p: 2, pb: 4 }}>
      {/* --- Title & Description Section (Merged) --- */}
      <CollapsibleSection title="Title & Description" initiallyExpanded={true}>
        <TextField
          fullWidth
          label="Title"
          value={card.title}
          onChange={(e) => handleFieldChange({ title: e.target.value })}
          sx={{ mb: 2 }}
        />
        <TextField
          fullWidth
          label="Description"
          multiline
          minRows={2}
          value={card.description || ''}
          onChange={(e) => handleFieldChange({ description: e.target.value || null })}
          placeholder="Optional: A short description for this card (not sent to AI)."
        />
      </CollapsibleSection>

      {/* --- Core Prompt Section (Merged) --- */}
      <CollapsibleSection title="AI Prompt" initiallyExpanded={true}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label="Core Scenario / Persona Prompt"
          value={card.prompt}
          onChange={(e) => handleFieldChange({ prompt: e.target.value })}
        />
      </CollapsibleSection>

      {/* --- First Turn Section (Merged) --- */}
      <CollapsibleSection title="First Turn Scene Setup" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={4}
          label="Intro scene shown only on turn 1"
          value={card.firstTurnOnlyBlock}
          onChange={(e) => handleFieldChange({ firstTurnOnlyBlock: e.target.value })}
          placeholder={DEFAULT_FIRST_TURN_PROMPT_BLOCK}
        />
      </CollapsibleSection>

      {/* --- Emit Skeleton Section (Merged) --- */}
      <CollapsibleSection title="Emit & Tagging Skeleton" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={6}
          label="AI Output Structure & Rules"
          value={card.emitSkeleton}
          onChange={(e) => handleFieldChange({ emitSkeleton: e.target.value })}
          placeholder={DEFAULT_EMIT_SKELETON_STRING}
        />
      </CollapsibleSection>

      {/* --- World State Init Section (Merged) --- */}
      <CollapsibleSection title="World State Initialization" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label="Initial World State (JSON)"
          value={card.worldStateInit}
          onChange={(e) => handleFieldChange({ worldStateInit: e.target.value })}
          placeholder="{}"
        />
      </CollapsibleSection>

      {/* --- Game Rules Section (Merged) --- */}
      <CollapsibleSection title="Game Rules Skeleton" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label="Game Rules"
          value={card.gameRules}
          onChange={(e) => handleFieldChange({ gameRules: e.target.value })}
          placeholder="Rules for the AI to follow during gameplay."
        />
      </CollapsibleSection>

      {/* --- AI Settings Section (Uses Reusable Component) --- */}
      <AiSettingsEditor
        label="Primary AI Settings"
        settings={card.aiSettings}
        onSettingsChange={(aiSettings) => handleFieldChange({ aiSettings })}
        availableConnections={availableConnections}
      />

      {/* --- Helper AI Settings Section (Uses Reusable Component) --- */}
      <CollapsibleSection title="Helper AI Settings" initiallyExpanded={false}>
        <FormControlLabel
          control={
            <Switch
              checked={card.isHelperAiEnabled}
              onChange={(e) => handleFieldChange({ isHelperAiEnabled: e.target.checked })}
            />
          }
          label={<>Enable Helper AI <InfoDialog title="Enable Helper AI" content="Toggle to enable a secondary AI call for specific tasks."/></>}
          sx={{ mb: 2 }}
        />
        <Divider sx={{ mb: 2 }} />
        <Box sx={{ opacity: card.isHelperAiEnabled ? 1 : 0.5, pointerEvents: card.isHelperAiEnabled ? 'auto' : 'none' }}>
          <AiSettingsEditor
            label="" // No label for the nested editor
            settings={card.helperAiSettings}
            onSettingsChange={(helperAiSettings) => handleFieldChange({ helperAiSettings })}
            availableConnections={availableConnections}
          />
        </Box>
      </CollapsibleSection>
      
      {/* --- Function Definitions Section (Merged) --- */}
      <CollapsibleSection title="Function Definitions" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={6}
          label="Function Definitions (JSON)"
          value={card.functionDefs}
          onChange={(e) => handleFieldChange({ functionDefs: e.target.value })}
          placeholder="e.g., { 'name': 'action', 'parameters': { ... } }"
        />
      </CollapsibleSection>

      {/* --- Stack Instructions Section (Uses Reusable Component) --- */}
      <StackInstructionsEditor
        stackInstructions={card.stackInstructions}
        onStackInstructionsChange={(stackInstructions) => handleFieldChange({ stackInstructions })}
      />

      {/* --- Metadata Section (Merged) --- */}
       <Box sx={{ mt: 3, display: 'flex', flexDirection: 'column', gap: 1 }}>
        <FormControlLabel
          control={
            <Switch
              checked={card.isPublic}
              onChange={(e) => handleFieldChange({ isPublic: e.target.checked })}
            />
          }
          label="Make Public (visible to others)"
        />
        <FormControlLabel
          control={
            <Switch
              checked={card.isExample}
              onChange={(e) => handleFieldChange({ isExample: e.target.checked })}
            />
          }
          label="Is Example Card (for showcase)"
        />
      </Box>
    </Box>
  );
};

export default PromptCardEditor;
@@END_FILE@@
@@FILE: src/ui/screens/PromptCardManager.tsx
// src/ui/screens/PromptCardManager.tsx
import React from 'react';
import {
  Box, Typography, Paper, CircularProgress, Alert, Dialog,
  DialogTitle, DialogContent, DialogActions, Button, TextField, Snackbar,
} from '@mui/material';
import { useAuthStore } from '../../state/useAuthStore';
import { usePromptCardManagerLogic } from '../../utils/hooks/usePromptCardManagerLogic';
import { PromptCardListPanel } from '../components/PromptCardListPanel';
import { PromptCardEditorPanel } from '../components/PromptCardEditorPanel';

const PromptCardManager: React.FC = () => {
  const { user } = useAuthStore();
  const {
    isLoading, error, promptCards, activePromptCard, localEditedCard, isCardDirty,
    aiConnections, saveDialog, snackbar,
    handleCardSelect, handleLocalCardChange, handleSaveCard, handleRevert,
    handleNewCard, handleDeleteCard, handleDuplicateCard, handleImport,
    handleExport, handleStartGame, setSaveDialog, setSaveAsNewTitle, closeSnackbar,
  } = usePromptCardManagerLogic(user);

  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Cards...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%', p: 2 }}>
      <Typography variant="h5" component="h1" sx={{ mb: 2 }}>
        Prompt Cards Manager
      </Typography>

      {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

      <Box sx={{ display: 'flex', flex: 1, overflow: 'hidden', gap: 2 }}>
        <Paper elevation={1} sx={{ flex: 1, minWidth: 300, maxWidth: 450, overflowY: 'auto', display: 'flex', flexDirection: 'column' }}>
          <PromptCardListPanel
            cards={promptCards}
            activeCardId={activePromptCard?.id || null}
            onSelectCard={handleCardSelect}
            onDeleteCard={handleDeleteCard}
            onDuplicateCard={handleDuplicateCard}
            onExportCard={handleExport}
            onNewCard={handleNewCard}
            onImport={handleImport}
          />
        </Paper>

        <Paper elevation={1} sx={{ flex: 2, minWidth: 400, overflowY: 'auto' }}>
          <PromptCardEditorPanel
            localEditedCard={localEditedCard}
            isCardDirty={isCardDirty}
            availableConnections={aiConnections}
            onCardChange={handleLocalCardChange}
            onRevert={handleRevert}
            onSave={() => handleSaveCard(false)}
            onSaveAs={() => setSaveDialog(true)}
            onStartGame={handleStartGame}
          />
        </Paper>
      </Box>

      <Dialog open={saveDialog.open} onClose={() => setSaveDialog(false)}>
        <DialogTitle>Save As New Card</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="New Title"
            type="text"
            fullWidth
            variant="outlined"
            value={saveDialog.title}
            onChange={(e) => setSaveAsNewTitle(e.target.value)}
            placeholder={`${localEditedCard?.title} (Copy)`}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setSaveDialog(false)}>Cancel</Button>
          <Button onClick={() => handleSaveCard(true)}>Save</Button>
        </DialogActions>
      </Dialog>

      <Snackbar open={snackbar.open} autoHideDuration={4000} onClose={closeSnackbar} anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardManager;
@@END_FILE@@
@@FILE: src/ui/screens/SettingsScreen.tsx
// src/ui/screens/SettingsScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, Paper, Divider, CircularProgress, Alert, TextField, Switch, FormControlLabel,
  Snackbar, Dialog, DialogTitle, DialogContent, DialogActions, ListItemButton,
  Stack, Select, MenuItem, InputLabel, FormControl, Card, CardActionArea, Grid,
  ListSubheader, InputAdornment, ListItemText, Tooltip, List, ListItem, IconButton
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import SearchIcon from '@mui/icons-material/Search';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
import WifiTetheringIcon from '@mui/icons-material/WifiTethering';
import { useSettingsLogic } from '../../utils/hooks/useSettingsLogic';
import { CollapsibleSection } from '../components/CollapsibleSection';

const SettingsScreen: React.FC = () => {
  const {
    aiConnections, selectedConnectionId, isLoadingConnections, connectionsError,
    useDummyNarrator, themeMode, setUseDummyNarrator, setThemeMode,
    isDialogOpen, dialogStep, editingConnection, isFetchingModels, testStatus, snackbar, templates,
    setModelSearchTerm, filteredModels,
    handleOpenDialog, handleCloseDialog, handleLoadTemplate, handleUpdateEditingConnection, 
    handleFetchModels, handleSaveAndTest, handleDelete, closeSnackbar, setSelectedConnectionId, handleTest,
    modelInfo, openModelInfo, handleOpenModelInfo, handleCloseModelInfo,
  } = useSettingsLogic();

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">Settings</Typography>
      </Box>

      {connectionsError && <Alert severity="error" sx={{ m: 2 }}>Error: {connectionsError}</Alert>}
      
      {isLoadingConnections && aiConnections.length === 0 && <CircularProgress sx={{ m: 2 }} />}

      <Paper sx={{ mt: 2, p: 2 }}>
        <Typography variant="h6" gutterBottom>Global Settings</Typography>
        <FormControlLabel control={<Switch checked={useDummyNarrator} onChange={(e) => setUseDummyNarrator(e.target.checked)} />} label="Use Dummy Narrator (for offline testing)" />
        <Divider sx={{ my: 1 }} />
        <FormControlLabel control={<Switch checked={themeMode === 'dark'} onChange={(e) => setThemeMode(e.target.checked ? 'dark' : 'light')} />} label="Dark Mode" />
      </Paper>
      
      <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>AI Connections</Typography>
      <Paper elevation={1} sx={{ flexGrow: 1, overflowY: 'auto' }}>
        <List>
            {aiConnections.map((conn) => (
              <React.Fragment key={conn.id}>
                <ListItem
                  disablePadding
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="edit" onClick={() => handleOpenDialog(conn)}><EditIcon fontSize="small" /></IconButton>
                      <IconButton edge="end" aria-label="delete" onClick={() => handleDelete(conn.id)}><DeleteIcon fontSize="small" color="error" /></IconButton>
                    </Box>
                  }
                >
                  <ListItemButton selected={selectedConnectionId === conn.id} onClick={() => setSelectedConnectionId(conn.id)}>
                    <ListItemText primary={conn.displayName} secondary={`${conn.modelName} (${conn.apiUrl.substring(0, 30)}...)`} />
                  </ListItemButton>
                </ListItem>
                <Divider />
              </React.Fragment>
            ))}
          </List>
      </Paper>
      <Button variant="contained" startIcon={<AddIcon />} onClick={() => handleOpenDialog()} sx={{ mt: 2 }}>
        Add New Connection
      </Button>

      <Dialog open={isDialogOpen} onClose={handleCloseDialog} fullWidth maxWidth="md" transitionDuration={{ enter: 200, exit: 0 }}>
        <DialogTitle>
          {dialogStep === 'select' ? 'Add a New Connection' : (editingConnection?.displayName || 'Connection Details')}
        </DialogTitle>
        <DialogContent>
          {dialogStep === 'select' && (
            <Stack spacing={2} sx={{ mt: 1 }}>
              <Typography>Start with a template for a popular provider.</Typography>
              <Grid container spacing={2}>
                {Object.entries(templates).filter(([key]) => key !== 'custom').map(([key, template]) => (
                  <Grid item xs={12} sm={6} key={key}>
                    <Card variant="outlined">
                      <CardActionArea onClick={() => handleLoadTemplate(key)} sx={{ p: 2, textAlign: 'center' }}>
                        <Typography variant="h6">{template.displayName}</Typography>
                      </CardActionArea>
                    </Card>
                  </Grid>
                ))}
              </Grid>
              <Divider>OR</Divider>
              <Button variant="outlined" onClick={() => handleLoadTemplate('custom')}>Start with a Blank Custom Connection</Button>
            </Stack>
          )}

          {dialogStep === 'details' && editingConnection && (
            // ... (The rest of the dialog content is correct)
            <Stack spacing={2.5} sx={{ mt: 1 }}>
              <TextField label="Connection Name" value={editingConnection.displayName} onChange={(e) => handleUpdateEditingConnection({ displayName: e.target.value })} autoFocus fullWidth />
              <TextField label="API Token (Key)" value={editingConnection.apiToken} onChange={(e) => handleUpdateEditingConnection({ apiToken: e.target.value })} fullWidth type="password" />

              <FormControl fullWidth>
                <InputLabel id="model-select-label">Model</InputLabel>
                <Select
                  labelId="model-select-label"
                  value={editingConnection.modelSlug}
                  label="Model"
                  onChange={(e) => {
                    const selectedModel = filteredModels.find(m => m.id === e.target.value);
                    handleUpdateEditingConnection({ modelSlug: e.target.value, modelName: selectedModel?.name || e.target.value });
                  }}
                  MenuProps={{ autoFocus: false }}
                >
                  <ListSubheader>
                    <TextField size="small" autoFocus placeholder="Type to filter models..." fullWidth
                      InputProps={{startAdornment: (<InputAdornment position="start"><SearchIcon /></InputAdornment>)}}
                      onChange={(e) => setModelSearchTerm(e.target.value)} onKeyDown={(e) => e.stopPropagation()} />
                  </ListSubheader>
                  {filteredModels.map(model => (
                    <MenuItem key={model.id} value={model.id}>
                      <Tooltip title={model.description || 'No description available.'} placement="right" enterDelay={500}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' }}>
                          <ListItemText primary={model.name} secondary={model.id} />
                          <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleOpenModelInfo(model); }} sx={{ display: { xs: 'flex', md: 'none' } }}>
                            <InfoOutlinedIcon fontSize="small" />
                          </IconButton>
                        </Box>
                      </Tooltip>
                    </MenuItem>
                  ))}
                  {filteredModels.length === 0 && <MenuItem disabled>No models match your search.</MenuItem>}
                </Select>
              </FormControl>
              
              {templates[editingConnection.displayName.toLowerCase()]?.supportsModelDiscovery && (
                <Button onClick={handleFetchModels} disabled={isFetchingModels} variant="outlined">
                  {isFetchingModels ? <CircularProgress size={24} /> : `Fetch All ${editingConnection.displayName} Models`}
                </Button>
              )}
              
              <CollapsibleSection title="Advanced Options" initiallyExpanded={false}>
                 <Stack spacing={2.5} sx={{mt: 2}}>
                    <TextField label="API URL" value={editingConnection.apiUrl} onChange={(e) => handleUpdateEditingConnection({ apiUrl: e.target.value })} fullWidth />
                    <TextField label="User Agent" value={editingConnection.userAgent || ''} onChange={(e) => handleUpdateEditingConnection({ userAgent: e.target.value })} fullWidth />
                    <FormControlLabel control={<Switch checked={editingConnection.functionCallingEnabled} onChange={(e) => handleUpdateEditingConnection({ functionCallingEnabled: e.target.checked })} />}
                        label="Function Calling Enabled" />
                 </Stack>
              </CollapsibleSection>
              
              {testStatus && <Alert severity={testStatus.type} sx={{ mt: 1 }}>{testStatus.text}</Alert>}
            </Stack>
          )}
        </DialogContent>
        <DialogActions sx={{ p: '16px 24px' }}>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          {dialogStep === 'details' && (
            <Stack direction="row" spacing={1}>
              <Button onClick={handleTest} startIcon={<WifiTetheringIcon />}>Test</Button>
              <Button onClick={handleSaveAndTest} variant="contained">Save Connection</Button>
            </Stack>
          )}
        </DialogActions>
      </Dialog>
      
      <Dialog open={openModelInfo} onClose={handleCloseModelInfo}>
        <DialogTitle>{modelInfo?.name}</DialogTitle>
        <DialogContent>
            <Typography variant="body1">{modelInfo?.description || "No description available."}</Typography>
            <Typography variant="caption" color="text.secondary" sx={{mt: 2, display: 'block'}}>ID: {modelInfo?.id}</Typography>
        </DialogContent>
        <DialogActions>
            <Button onClick={handleCloseModelInfo}>Close</Button>
        </DialogActions>
      </Dialog>
      
      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={closeSnackbar}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>{snackbar.message}</Alert>
      </Snackbar>
    </Box>
  );
};

export default SettingsScreen;
@@END_FILE@@
@@FILE: src/ui/screens/SourceDump.tsx
import React, { useEffect, useState } from 'react';
import { debugLog, errorLog } from '../../utils/debug';

// Small reusable copy button
function CopyButton({ text }: { text: string }) {
  const [copied, setCopied] = useState(false);
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch (err) {
      errorLog('Copy failed', err);
    }
  };
  return (
    <button
      onClick={handleCopy}
      style={{
        marginLeft: '6px',
        fontSize: '0.8rem',
        cursor: 'pointer',
        background: 'none',
        border: '1px solid #ccc',
        borderRadius: '4px',
        padding: '2px 5px',
      }}
    >
      {copied ? '✅' : '📋'}
    </button>
  );
}

function FolderView({
  name,
  node,
  level = 0,
}: {
  name: string;
  node: any;
  level?: number;
}) {
  const [open, setOpen] = useState(true);

  const isFolder = typeof node === 'object';
  if (!isFolder) return null;

  const folderIndent = { paddingLeft: `${level * 1.2}rem` };

  // Gather folder text for copy
  const folderText = node.__files
    ? node.__files.map((f: any) => f.content).join('\n')
    : '';

  return (
    <div style={{ ...folderIndent }}>
      <div
        style={{
          cursor: 'pointer',
          userSelect: 'none',
          fontWeight: 'bold',
        }}
        onClick={() => setOpen(!open)}
      >
        {open ? '📂' : '📁'} {name}
        {folderText && <CopyButton text={folderText} />}
      </div>

      {open && (
        <>
          {node.__files &&
            node.__files.map((file: any) => (
              <div key={file.name} style={{ paddingLeft: '1.5rem' }}>
                📄 {file.name}
                <CopyButton text={file.content} />
              </div>
            ))}
          {Object.entries(node)
            .filter(([k]) => k !== '__files')
            .map(([childName, childNode]) => (
              <FolderView
                key={childName}
                name={childName}
                node={childNode}
                level={level + 1}
              />
            ))}
        </>
      )}
    </div>
  );
}

export default function SourceDump() {
  const [dumpText, setDumpText] = useState('');
  const [tree, setTree] = useState<any>(null);

  useEffect(() => {
    fetch(`/source-dump.txt?_=${Date.now()}`)
      .then((res) => res.text())
      .then((text) => {
        setDumpText(text);
        setTree(parseDumpToTree(text));
      });
  }, []);

  if (!dumpText) return <div>Loading...</div>;

  return (
    <div style={{ padding: '1rem', fontFamily: 'monospace' }}>
      <h2>
        📋 Copy Entire Repo
        <CopyButton text={dumpText} />
      </h2>

      {tree && <FolderView name="src" node={tree.src || tree} />}

      <hr style={{ margin: '2rem 0' }} />
      <h3>Full Dump:</h3>
      <pre
        style={{
          whiteSpace: 'pre-wrap',
          fontSize: '0.85rem',
          maxHeight: '400px',
          overflow: 'auto',
        }}
      >
        {dumpText}
      </pre>
    </div>
  );
}

function parseDumpToTree(dump: string) {
  const lines = dump.split('\n');
  const root: any = { __files: [] };;
  let currentFolder: string[] = [];
  let currentFile: { name: string; content: string } | null = null;

  const ensureFolder = (pathParts: string[]) => {
    let node = root;
    for (const part of pathParts) {
      if (!node[part]) node[part] = { __files: [] };
      node = node[part];
    }
    return node;
  };

  for (let line of lines) {
    if (line.startsWith('@@FOLDER:')) {
      const folderPath = line.replace('@@FOLDER: ', '').trim();
      currentFolder = folderPath.split('/').slice(1); // remove 'src'
      ensureFolder(currentFolder);
    } else if (line.startsWith('@@FILE:')) {
      const filePath = line.replace('@@FILE: ', '').trim();
      const parts = filePath.split('/');
      const fileName = parts.pop()!;
      currentFolder = parts.slice(1);
      const folderNode = ensureFolder(currentFolder);
      currentFile = { name: fileName, content: '' };
      folderNode.__files.push(currentFile);
    } else {
      if (currentFile) currentFile.content += line + '\n';
    }
  }

  return root;
}

@@END_FILE@@
@@FILE: src/ui/screens/SourceDumpScreen.tsx
// src/ui/screens/SourceDumpScreen.tsx
import React from 'react';
import { Box } from '@mui/material';
import { SourceDumpPanel } from '../components/SourceDumpPanel';

const SourceDumpScreen: React.FC = () => {
return (
<Box p={1}>
<SourceDumpPanel />
</Box>
);
};

export default SourceDumpScreen;
@@END_FILE@@
@@FILE: src/ui/screens/WorldStateScreen.tsx
// src/ui/screens/WorldStateScreen.tsx
import React, { useState, useMemo, useCallback } from 'react';
import {
  Box, Typography, Button, Paper, 
  Alert, Dialog, DialogTitle, DialogContent,
  DialogActions, TextField,
} from '@mui/material';
import {
  useGameStateStore,
  selectWorldStatePinnedKeys,
  selectCurrentGameState,
} from '../../state/useGameStateStore';
import { flattenJsonObject, getNestedValue } from '../../utils/jsonUtils';
import { WorldStateCategory } from '../components/WorldStateCategory';

const WorldStateScreen: React.FC = () => {
  // --- Start of Co-located Logic (from the old useWorldStateViewLogic hook) ---

  const gameState = useGameStateStore(selectCurrentGameState);
  const worldStatePinnedKeys = useGameStateStore(selectWorldStatePinnedKeys);
  const {
    toggleWorldStatePin, renameWorldCategory, renameWorldEntity,
    deleteWorldCategory, deleteWorldEntity, editWorldKeyValue, deleteWorldKey,
  } = useGameStateStore();

  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());
  const [expandedEntities, setExpandedEntities] = useState<Set<string>>(new Set());
  const [editingCategory, setEditingCategory] = useState<string | null>(null);
  const [newCategoryName, setNewCategoryName] = useState('');
  const [editingEntity, setEditingEntity] = useState<[string, string] | null>(null);
  const [newEntityName, setNewEntityName] = useState('');

  const worldState = gameState?.worldState || {};

  const flattenedWorld = useMemo(() => flattenJsonObject(worldState), [worldState]);

  const groupedByCategory = useMemo(() => {
    const grouped: Record<string, Record<string, Record<string, any>>> = {};
    Object.keys(flattenedWorld).forEach(fullKey => {
      const value = flattenedWorld[fullKey];
      const parts = fullKey.split(".");
      if (parts.length < 1) return;

      const category = parts[0];
      const entity = (parts.length > 1 && /^[#@$]/.test(parts[1])) ? parts[1] : '@@_direct';
      const variable = (entity === '@@_direct') ? parts.slice(1).join('.') : parts.slice(2).join('.');
      if (!variable && entity !== '@@_direct') return; // Skip if entity has no variables

      grouped[category] = grouped[category] || {};
      grouped[category][entity] = grouped[category][entity] || {};
      grouped[category][entity][variable] = value;
    });
    // Clean up empty direct keys
    Object.keys(grouped).forEach(category => {
      if (grouped[category]['@@_direct'] && Object.keys(grouped[category]['@@_direct']).length === 0) {
        delete grouped[category]['@@_direct'];
      }
    });
    return grouped;
  }, [flattenedWorld]);

  const getAllChildVariableKeys = useCallback((basePath: string): string[] => {
    const nestedData = getNestedValue(worldState, basePath.split('.'));
    if (typeof nestedData !== 'object' || nestedData === null) return [];
    return Object.keys(flattenJsonObject(nestedData, basePath));
  }, [worldState]);

  const isAnyChildPinned = useCallback((parentPath: string) => {
    return getAllChildVariableKeys(parentPath).some(key => worldStatePinnedKeys.includes(key));
  }, [getAllChildVariableKeys, worldStatePinnedKeys]);

  const areAllChildrenPinned = useCallback((parentPath: string) => {
    const childKeys = getAllChildVariableKeys(parentPath);
    return childKeys.length > 0 && childKeys.every(key => worldStatePinnedKeys.includes(key));
  }, [getAllChildVariableKeys, worldStatePinnedKeys]);

  const handleToggleCategoryExpand = useCallback((category: string) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev);
      newSet.has(category) ? newSet.delete(category) : newSet.add(category);
      return newSet;
    });
  }, []);

  const handleToggleEntityExpand = useCallback((entityPath: string) => {
    setExpandedEntities(prev => {
      const newSet = new Set(prev);
      newSet.has(entityPath) ? newSet.delete(entityPath) : newSet.add(entityPath);
      return newSet;
    });
  }, []);
  
  const handleToggleCategoryPin = useCallback((category: string) => toggleWorldStatePin(category, 'category'), [toggleWorldStatePin]);
  const handleToggleEntityPin = useCallback((entityPath: string) => toggleWorldStatePin(entityPath, 'entity'), [toggleWorldStatePin]);
  const handleToggleVariablePin = useCallback((key: string) => toggleWorldStatePin(key, 'variable'), [toggleWorldStatePin]);

  const handleStartRenameCategory = useCallback((category: string) => { setEditingCategory(category); setNewCategoryName(category); }, []);
  const handleStartRenameEntity = useCallback((category: string, entity: string) => { setEditingEntity([category, entity]); setNewEntityName(entity); }, []);

  const cancelEdit = useCallback(() => { setEditingCategory(null); setEditingEntity(null); }, []);

  const handleConfirmRenameCategory = useCallback(async () => {
    if (editingCategory && newCategoryName.trim() && newCategoryName !== editingCategory) {
      await renameWorldCategory(editingCategory, newCategoryName.trim());
    }
    cancelEdit();
  }, [editingCategory, newCategoryName, renameWorldCategory, cancelEdit]);

  const handleConfirmRenameEntity = useCallback(async () => {
    if (editingEntity && newEntityName.trim() && newEntityName !== editingEntity[1]) {
      await renameWorldEntity(editingEntity[0], editingEntity[1], newEntityName.trim());
    }
    cancelEdit();
  }, [editingEntity, newEntityName, renameWorldEntity, cancelEdit]);

  // --- End of Co-located Logic ---

  const { gameError } = useGameStateStore();

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">World State</Typography>
      </Box>

      {gameError && (<Alert severity="error" sx={{ m: 2 }}>{gameError}</Alert>)}

      {Object.keys(groupedByCategory).length === 0 ? (
        <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
          <Typography variant="body1" color="text.secondary">No world state data available.</Typography>
        </Box>
      ) : (
        <Paper elevation={1} sx={{ flexGrow: 1, m: 2, p: 2, overflowY: 'auto' }}>
          {Object.entries(groupedByCategory).map(([categoryName, entities]) => (
            <WorldStateCategory
              key={categoryName}
              categoryName={categoryName}
              entities={entities}
              isExpanded={expandedCategories.has(categoryName)}
              areAllChildrenPinned={areAllChildrenPinned(categoryName)}
              isAnyChildPinned={isAnyChildPinned(categoryName)}
              expandedEntities={expandedEntities}
              worldStatePinnedKeys={worldStatePinnedKeys}
              onToggleExpand={() => handleToggleCategoryExpand(categoryName)}
              onTogglePin={() => handleToggleCategoryPin(categoryName)}
              onStartRename={() => handleStartRenameCategory(categoryName)}
              onDelete={() => deleteWorldCategory(categoryName)}
              onToggleEntityExpand={handleToggleEntityExpand}
              onToggleEntityPin={handleToggleEntityPin}
              onStartRenameEntity={handleStartRenameEntity}
              onDeleteEntity={deleteWorldEntity}
              onDeleteKey={deleteWorldKey}
              onEditKey={editWorldKeyValue}
              onToggleVariablePin={handleToggleVariablePin}
            />
          ))}
        </Paper>
      )}

      {/* Dialogs for renaming */}
      <Dialog open={!!editingCategory} onClose={cancelEdit}>
        <DialogTitle>Rename Category</DialogTitle>
        <DialogContent>
          <TextField autoFocus margin="dense" label="New Category Name" fullWidth variant="outlined" value={newCategoryName} onChange={(e) => setNewCategoryName(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && handleConfirmRenameCategory()} />
        </DialogContent>
        <DialogActions>
          <Button onClick={cancelEdit}>Cancel</Button>
          <Button onClick={handleConfirmRenameCategory}>Rename</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={!!editingEntity} onClose={cancelEdit}>
        <DialogTitle>Rename Entity</DialogTitle>
        <DialogContent>
          <TextField autoFocus margin="dense" label="New Entity Name" fullWidth variant="outlined" value={newEntityName} onChange={(e) => setNewEntityName(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && handleConfirmRenameEntity()} />
        </DialogContent>
        <DialogActions>
          <Button onClick={cancelEdit}>Cancel</Button>
          <Button onClick={handleConfirmRenameEntity}>Rename</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default WorldStateScreen;
@@END_FILE@@
@@FILE: src/utils/debug.ts
// src/utils/debug.ts
import { useSettingsStore } from '../state/useSettingsStore';

/**
 * A centralized logging utility that conditionally logs messages based on a debug setting.
 * This function should be used in place of direct `console.log` for debug messages.
 * @param message The message to log.
 * @param optionalParams Any additional data to log.
 */
export const debugLog = (message?: any, ...optionalParams: any[]) => {
  const { enableDebugLogging } = useSettingsStore.getState();
  if (enableDebugLogging) {
    console.log(message, ...optionalParams);
  }
};

/**
 * A centralized error logging utility that always logs errors, regardless of debug setting.
 * @param message The error message to log.
 * @param optionalParams Any additional error data to log.
 */
export const errorLog = (message?: any, ...optionalParams: any[]) => {
  console.error(message, ...optionalParams);
};
@@END_FILE@@
@@FILE: src/utils/diceRoller.ts
// src/utils/diceRoller.ts

/**
 * Represents the result of a dice roll.
 */
interface DiceRollResult {
  rolls: number[];
  sum: number;
  modifier: number;
  formula: string;
}

export const DiceRoller = {
  /**
   * Rolls dice based on a formula (e.g., "1d20", "2d6+3").
   * Supports basic NdN and optional +M or -M.
   * @param formula The dice rolling formula string.
   * @returns A DiceRollResult object.
   */
  roll: (formula: string): DiceRollResult => {
    const parts = formula.match(/^(\d*)d(\d+)([\+\-]\d+)?$/i);
    if (!parts) {
      throw new Error(`Invalid dice formula: ${formula}. Expected format: NdN[+M|-M]`);
    }

    const numDice = parseInt(parts[1] || '1', 10);
    const numSides = parseInt(parts[2], 10);
    const modifier = parts[3] ? parseInt(parts[3], 10) : 0;

    const rolls: number[] = [];
    let sum = 0;

    for (let i = 0; i < numDice; i++) {
      const roll = Math.floor(Math.random() * numSides) + 1;
      rolls.push(roll);
      sum += roll;
    }

    return {
      rolls,
      sum: sum + modifier,
      modifier,
      formula,
    };
  },

  /**
   * Formats a DiceRollResult into a human-readable string.
   * @param result The DiceRollResult to format.
   * @returns A formatted string (e.g., "Roll: 2d6 -> [3, 5] = 8").
   */
  format: (result: DiceRollResult): string => {
    let summary = `Roll: ${result.formula} -> [${result.rolls.join(', ')}]`;
    if (result.modifier !== 0) {
      summary += `${result.modifier >= 0 ? '+' : ''}${result.modifier}`;
    }
    summary += ` = ${result.sum}`;
    return summary;
  },
};
@@END_FILE@@
@@FILE: src/utils/formatDate.ts
// src/utils/formatDate.ts

/**
 * Formats an ISO 8601 date string into a more human-readable local date and time.
 * @param isoString The date string in ISO 8601 format (e.g., "2023-10-27T10:00:00Z").
 * @returns A formatted date string (e.g., "October 27, 2023, 10:00 AM").
 */
export function formatIsoDateForDisplay(isoString: string): string {
  try {
    const date = new Date(isoString);
    if (isNaN(date.getTime())) {
      // Invalid date string
      return "Invalid Date";
    }
    // Options for a readable format. Adjust as needed.
    const options: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: true, // Use 12-hour clock with AM/PM
    };
    return new Intl.DateTimeFormat(undefined, options).format(date);
  } catch (error) {
    console.error("Error formatting date:", error);
    return "Error formatting date";
  }
}

/**
 * Converts a Firestore Timestamp-like object to an ISO string if applicable.
 * If not a Timestamp, returns the value unchanged.
 */
export function toIsoStringIfTimestamp(value: any): string {
  return value instanceof Object && 'toDate' in value
    ? value.toDate().toISOString()
    : value;
}


@@END_FILE@@
@@FILE: src/utils/hash.ts
// src/utils/hash.ts

import type { AiSettings, StackInstructions } from '../models';


/**
 * Generates a simple, non-cryptographic hash from a string.
 * This is suitable for content deduplication checks within the application.
 *
 * Based on the 'sdbm' hash algorithm.
 * @param str The input string to hash.
 * @returns A string representation of the hash.
 */
export function generateContentHash(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = char + (hash << 6) + (hash << 16) - hash; // sdbm hash algorithm
  }
  // Convert to unsigned 32-bit integer and then to hex string
  return (hash >>> 0).toString(16);
}

/**
 * Creates a normalized string representation of key PromptCard content for hashing.
 * This function defines which fields are considered for deduplication.
 * It's important that this function is deterministic: the same input should always
 * produce the same output string.
 * @param card The PromptCard object (or partial object containing relevant fields).
 * @returns A string representing the key content of the card.
 */
export function getPromptCardContentForHash(card: {
  title: string;
  description: string | null;
  prompt: string;
  firstTurnOnlyBlock: string;
  stackInstructions: StackInstructions | string; // Can be object or string, needs to be stringified
  emitSkeleton: string;
  worldStateInit: string;
  gameRules: string;
  tags: string[];
  functionDefs: string;
  aiSettings: AiSettings; // Include AI settings in hash as they affect "content"
  helperAiSettings: AiSettings; // Include helper AI settings
}): string {
  // Use a consistent order and join method to ensure same content yields same hash
  // Sort tags for consistent hashing regardless of input order
  const sortedTags = [...(card.tags || [])].sort().join(',');

  // Stringify complex objects for consistent hashing.
  // We need to handle both the structured StackInstructions object and a potential raw JSON string input.
  const stackInstructionsString = typeof card.stackInstructions === 'object'
    ? JSON.stringify(card.stackInstructions)
    : (card.stackInstructions || '');

  // Stringify AI settings objects consistently
  const aiSettingsString = JSON.stringify(card.aiSettings);
  const helperAiSettingsString = JSON.stringify(card.helperAiSettings);

  // Concatenate all relevant content fields.
  // Order matters here for deterministic hashing.
  return [
    card.title,
    card.description || '', // Treat null as empty string for hashing
    card.prompt,
    card.firstTurnOnlyBlock,
    stackInstructionsString,
    card.emitSkeleton,
    card.worldStateInit,
    card.gameRules,
    aiSettingsString,
    helperAiSettingsString,
    sortedTags,
    card.functionDefs,
  ].join('|||'); // Use a distinctive separator to avoid accidental matches
}
@@END_FILE@@
@@FILE: src/utils/hooks/useDialog.ts
// src/utils/hooks/useDialog.ts
import { useState, useCallback } from 'react';

/**
 * A custom hook to manage the state of a dialog or modal.
 * @param initialState - The initial open state of the dialog (defaults to false).
 * @returns An object with { isOpen, open, close } properties for controlling the dialog.
 */
export const useDialog = (initialState = false) => {
  const [isOpen, setIsOpen] = useState(initialState);

  /**
   * Opens the dialog.
   */
  const open = useCallback(() => setIsOpen(true), []);

  /**
   * Closes the dialog.
   */
  const close = useCallback(() => setIsOpen(false), []);

  return { isOpen, open, close };
};
@@END_FILE@@
@@FILE: src/utils/hooks/useGameScreenLogic.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore, selectCurrentGameState, selectConversationHistory } from '../../state/useGameStateStore';
import { DiceRoller } from '../../utils/diceRoller';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useSettingsStore } from '../../state/useSettingsStore';
import { debugLog, errorLog } from '../../utils/debug';

export const useGameScreenLogic = () => {
  const navigate = useNavigate();
  const { user } = useAuthStore();

  const enableDebugLogging = useSettingsStore(state => state.enableDebugLogging);
  const typingSpeedMs = useSettingsStore(state => state.textGenerationSpeedMs);

  const currentSnapshot = useGameStateStore(state => state.currentSnapshot);
  const currentGameState = useGameStateStore(selectCurrentGameState);
  const conversationHistory = useGameStateStore(selectConversationHistory);
  const narratorInputText = useGameStateStore(state => state.narratorInputText);
  const gameLoading = useGameStateStore(state => state.gameLoading);
  const isProcessingTurn = useGameStateStore(state => state.isProcessingTurn);
  const gameError = useGameStateStore(state => state.gameError);
  const activePromptCard = usePromptCardStore(state => state.activePromptCard);

  const processPlayerAction = useGameStateStore(state => state.processPlayerAction);
  const updateNarratorInputText = useGameStateStore(state => state.updateNarratorInputText); // Keep this one for the input text field

  const [showRollDialog, setShowRollDialog] = useState(false);
  const [rollFormula, setRollFormula] = useState("2d6");
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'info', // Initial value (no change needed here)
  });

  const [displayedCurrentNarration, setDisplayedCurrentNarration] = useState('');

  const logContainerRef = useRef<HTMLDivElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const isFirstPlayerAction = currentSnapshot?.conversationHistory?.length === 1;

  useEffect(() => {
    if (enableDebugLogging) {
      debugLog(`[useGameScreenLogic.ts] useEffect (auto-scroll): conversationHistory changed. Count: ${conversationHistory.length}`);
    }
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [conversationHistory, enableDebugLogging, displayedCurrentNarration]);

  useEffect(() => {
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    const fullNarration = currentGameState?.narration || '';
    const enableStreaming = activePromptCard?.aiSettings?.streaming ?? true;

    const shouldTypeOut = enableStreaming && fullNarration.length > 0 && !isProcessingTurn;
    const shouldAnimateFirstTurn = isFirstPlayerAction && shouldTypeOut;

    if (shouldAnimateFirstTurn) {
      setDisplayedCurrentNarration('');
      let i = 0;
      const typeCharacter = () => {
        if (i < fullNarration.length) {
          setDisplayedCurrentNarration((prev) => prev + fullNarration.charAt(i));
          i++;
          typingTimeoutRef.current = setTimeout(typeCharacter, typingSpeedMs);
        } else {
          typingTimeoutRef.current = null;
        }
      };
      typingTimeoutRef.current = setTimeout(typeCharacter, typingSpeedMs);
    } else {
      setDisplayedCurrentNarration(fullNarration);
    }

    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, [
    currentGameState?.narration,
    activePromptCard?.aiSettings?.streaming,
    isProcessingTurn,
    typingSpeedMs,
    isFirstPlayerAction,
  ]);

  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] Snackbar: "${message}" (${severity})`);
    setSnackbar({ open: true, message, severity });
  }, [enableDebugLogging]);

  const handleSendAction = useCallback(async () => {
    if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] handleSendAction: Input: "${narratorInputText}"`);
    if (narratorInputText.trim() === '' || isProcessingTurn) {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Skipping send — empty or already processing.');
      return;
    }
    try {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
      }
      setDisplayedCurrentNarration(currentGameState?.narration || '');
      await processPlayerAction(narratorInputText);
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] processPlayerAction completed.');
    } catch (e) {
      errorLog('[useGameScreenLogic.ts] Error in handleSendAction:', e);
      showSnackbar(`Failed to process action: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  }, [narratorInputText, isProcessingTurn, processPlayerAction, showSnackbar, currentGameState?.narration, enableDebugLogging]);

  const handleRollDice = useCallback(async () => {
    if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] Rolling formula: ${rollFormula}`);
    try {
      const result = DiceRoller.roll(rollFormula);
      const summary = DiceRoller.format(result);
      if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] Dice result: ${summary}`);

      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
      }
      setDisplayedCurrentNarration(currentGameState?.narration || '');

      await processPlayerAction(`I roll the dice (${rollFormula}) and get the following result:\n${summary}`);
      showSnackbar(`Rolled ${rollFormula}: ${summary}`, 'success');
      setShowRollDialog(false);
    } catch (e) {
      errorLog('[useGameScreenLogic.ts] Error in handleRollDice:', e);
      showSnackbar(`Failed to roll dice: ${e instanceof Error ? e.message : 'Invalid formula'}`, 'error');
    }
  }, [rollFormula, processPlayerAction, showSnackbar, currentGameState?.narration, enableDebugLogging]);

  const handleOpenRollDialog = useCallback(() => {
    if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Opening roll dialog.');
    setShowRollDialog(true);
  }, [enableDebugLogging]);

  const handleKeyPress = useCallback((event: React.KeyboardEvent) => {
    if (event.key === 'Enter' && !event.shiftKey) {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Enter pressed — sending action.');
      event.preventDefault();
      handleSendAction();
    }
  }, [handleSendAction, enableDebugLogging]);

  const closeSnackbar = useCallback(() => {
    if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Closing snackbar.');
    setSnackbar(prev => ({ ...prev, open: false }));
  }, [enableDebugLogging]);

  return {
    isReady: !!user && !!currentSnapshot && !!currentGameState,
    isLoading: gameLoading,
    isProcessingTurn,
    gameError,
    conversationHistory,
    narratorInputText,
    logContainerRef,
    snackbar,
    displayedCurrentNarration,
    fullLatestNarration: currentGameState?.narration || '',
    enableStreaming: activePromptCard?.aiSettings?.streaming ?? true,

    rollDialog: {
      open: showRollDialog,
      formula: rollFormula,
    },

    handleGoToLogin: () => {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Navigating to /login');
      navigate('/login');
    },
    handleSendAction,
    handleInputChange: updateNarratorInputText,
    handleKeyPress,
    handleRollDice,
    handleOpenRollDialog,
    handleCloseRollDialog: () => {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Closing roll dialog.');
      setShowRollDialog(false);
    },
    handleRollFormulaChange: setRollFormula,
    closeSnackbar,
  };
};

@@END_FILE@@
@@FILE: src/utils/hooks/useLogViewerLogic.ts
// src/utils/hooks/useLogViewerLogic.ts
import { useState, useEffect, useCallback } from 'react';
import { useLogStore } from '../../state/useLogStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { LogViewMode } from '../../utils/types';

export const useLogViewerLogic = () => {
  // 1. Consume global stores
  const { logEntries, selectedLogViewModes, isLoading, error, setLogEntries, setSelectedLogViewModes } = useLogStore();
  const { currentSnapshot } = useGameStateStore();

  // 2. Local UI state
  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
  const isMenuOpen = Boolean(menuAnchorEl);

  // 3. Data synchronization effect
  useEffect(() => {
    // When the game snapshot changes, update the logs in the log store
    setLogEntries(currentSnapshot?.logs || []);
  }, [currentSnapshot, setLogEntries]);

  // 4. Handlers
  const handleMenuClick = useCallback((event: React.MouseEvent<HTMLButtonElement>) => {
    setMenuAnchorEl(event.currentTarget);
  }, []);

  const handleMenuClose = useCallback(() => {
    setMenuAnchorEl(null);
  }, []);

  const handleCheckboxChange = useCallback((mode: LogViewMode) => {
    const newSelection = selectedLogViewModes.includes(mode)
      ? selectedLogViewModes.filter((m) => m !== mode)
      : [...selectedLogViewModes, mode];
    setSelectedLogViewModes(newSelection);
  }, [selectedLogViewModes, setSelectedLogViewModes]);

  // 5. Return Clean API
  return {
    logEntries,
    selectedLogViewModes,
    isLoading,
    error,
    menuAnchorEl,
    isMenuOpen,
    handleMenuClick,
    handleMenuClose,
    handleCheckboxChange,
  };
};
@@END_FILE@@
@@FILE: src/utils/hooks/useLongPress.ts
// src/utils/hooks/useLongPress.ts

import React, { useRef, useCallback } from 'react';

/**
 * Custom hook to detect long press events.
 * @param onLongPress The callback function to execute on long press.
 * @param onClick The callback function to execute on a regular click (optional).
 * @param options Configuration options for long press.
 * @param options.delay The duration in milliseconds for a press to be considered a long press (default: 500).
 */
export function useLongPress<T extends HTMLElement>(
  onLongPress: (event: React.MouseEvent<T> | React.TouchEvent<T>) => void,
  onClick?: (event: React.MouseEvent<T> | React.TouchEvent<T>) => void,
  { delay = 500 } = {}
) {
  // Initialize useRef with null to satisfy the 'initialValue' requirement
  // and extend the type to allow null, as a timeout reference might be null initially
  const timeout = useRef<NodeJS.Timeout | null>(null);
  // Initialize useRef with null and extend the type to allow null,
  // as the target element might not be immediately available or might be cleared
  const target = useRef<T | null>(null);

  const start = useCallback(
    (event: React.MouseEvent<T> | React.TouchEvent<T>) => {
      // Stop the event from bubbling to parent elements
      event.stopPropagation();

      // Prevent context menu on long press on some browsers
      event.preventDefault();

      target.current = event.currentTarget as T;
      timeout.current = setTimeout(() => {
        onLongPress(event);
        // Assign null instead of undefined, as the type for target.current is T | null
        target.current = null; // Clear target after long press
      }, delay);
    },
    [onLongPress, delay]
  );

  const clear = useCallback(
    (event: React.MouseEvent<T> | React.TouchEvent<T>, shouldClick = true) => {
      // Clear the timeout if it exists
      if (timeout.current) {
        clearTimeout(timeout.current);
      }

      if (shouldClick && onClick && target.current === event.currentTarget) {
        onClick(event);
      }
      // Assign null instead of undefined
      target.current = null;
    },
    [onClick]
  );

  return {
    onMouseDown: start,
    onTouchStart: start,
    onMouseUp: (e: React.MouseEvent<T>) => clear(e),
    onMouseLeave: (e: React.MouseEvent<T>) => clear(e, false),
    onTouchEnd: (e: React.TouchEvent<T>) => clear(e),
    onTouchCancel: (e: React.TouchEvent<T>) => clear(e, false),
  };
}
@@END_FILE@@
@@FILE: src/utils/hooks/usePromptCardManagerLogic.ts
// src/utils/hooks/usePromptCardManagerLogic.ts
import { useState, useEffect, useCallback } from 'react';
import type { User } from 'firebase/auth';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useSettingsStore } from '../../state/useSettingsStore';
import type { PromptCard, NewPromptCardData } from '../../models';
import {
  defaultStackInstructions,
  defaultAiSettingsInCard,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../../data/config/promptCardDefaults';
import { useNavigate } from 'react-router-dom';

export const usePromptCardManagerLogic = (user: User | null) => {
  const navigate = useNavigate();

  // 1. All state and store hooks are moved here
  const {
    promptCards,
    activePromptCard,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    addPromptCard,
    updatePromptCard,
    duplicatePromptCard,
    deletePromptCard,
    importPromptCards,
    exportPromptCard,
  } = usePromptCardStore();

  const { initializeGame } = useGameStateStore();
  const { aiConnections, fetchAiConnections } = useSettingsStore();

  const [localEditedCard, setLocalEditedCard] = useState<PromptCard | null>(null);
  const [isCardDirty, setIsCardDirty] = useState(false);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [saveAsNewTitle, setSaveAsNewTitle] = useState('');
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' | 'info' | 'warning' }>({ open: false, message: '', severity: 'info' });

  // 2. All useEffects are moved here
  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
      fetchAiConnections(user.uid);
    }
  }, [user?.uid, fetchPromptCards, fetchAiConnections]);

  useEffect(() => {
    setLocalEditedCard(activePromptCard ? { ...activePromptCard } : null);
    setIsCardDirty(false);
  }, [activePromptCard]);

  // 3. All handler functions are moved here and wrapped in useCallback
  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbar({ open: true, message, severity });
  }, []);

  const handleCardSelect = useCallback((card: PromptCard) => {
    if (isCardDirty) {
      showSnackbar('Unsaved changes will be lost if you switch cards.', 'warning');
    }
    setActivePromptCard(card);
  }, [isCardDirty, setActivePromptCard, showSnackbar]);

  const handleLocalCardChange = useCallback((updatedCard: PromptCard) => {
    setLocalEditedCard(updatedCard);
    setIsCardDirty(JSON.stringify(updatedCard) !== JSON.stringify(activePromptCard));
  }, [activePromptCard]);

  const handleSaveCard = useCallback(async (saveAsNew: boolean = false) => {
    if (!user?.uid || !localEditedCard) return;

    try {
      let savedCard: PromptCard | null = null;
      if (saveAsNew) {
        const newCardData: NewPromptCardData = {
          ...localEditedCard,
          title: saveAsNewTitle || `${localEditedCard.title} (Copy)`,
        };
        savedCard = await addPromptCard(user.uid, newCardData);
      } else {
        savedCard = await updatePromptCard(user.uid, localEditedCard.id, localEditedCard);
      }

      if (savedCard) {
        setActivePromptCard(savedCard);
        showSnackbar('Card saved successfully!', 'success');
      }
    } catch (e) {
      showSnackbar(`Failed to save card: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    } finally {
      setShowSaveDialog(false);
      setSaveAsNewTitle('');
    }
  }, [user, localEditedCard, saveAsNewTitle, addPromptCard, updatePromptCard, setActivePromptCard, showSnackbar]);

  const handleRevert = useCallback(() => {
    if (activePromptCard) {
      setLocalEditedCard({ ...activePromptCard });
      setIsCardDirty(false);
      showSnackbar('Changes reverted.', 'info');
    }
  }, [activePromptCard, showSnackbar]);

  const handleNewCard = useCallback(async () => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to create a new card.', 'error');
      return;
    }
    const defaultConnectionId = aiConnections.length > 0 ? aiConnections[0].id : "";
    const newCardData: NewPromptCardData = {
      title: "New Prompt Card",
      prompt: "This is a new prompt card. Describe the setting and your character's starting situation.",
      description: null,
      firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: defaultStackInstructions,
      emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: '',
      gameRules: '',
      aiSettings: { ...defaultAiSettingsInCard, selectedConnectionId: defaultConnectionId },
      helperAiSettings: { ...defaultAiSettingsInCard, selectedConnectionId: defaultConnectionId },
      isHelperAiEnabled: false,
      tags: [],
      isExample: false,
      functionDefs: '',
      isPublic: false,
    };
    const createdCard = await addPromptCard(user.uid, newCardData);
    if (createdCard) {
      setActivePromptCard(createdCard);
      showSnackbar('New card created successfully!', 'success');
    }
  }, [user, aiConnections, addPromptCard, setActivePromptCard, showSnackbar]);

  const handleDeleteCard = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    await deletePromptCard(user.uid, cardId);
    showSnackbar('Card deleted successfully!', 'success');
  }, [user, deletePromptCard, showSnackbar]);

  const handleDuplicateCard = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    const duplicated = await duplicatePromptCard(user.uid, cardId);
    if (duplicated) {
      showSnackbar('Card duplicated successfully!', 'success');
    }
  }, [user, duplicatePromptCard, showSnackbar]);

  const handleImport = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !user?.uid) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const content = e.target?.result as string;
        const parsed = JSON.parse(content) as NewPromptCardData | NewPromptCardData[];
        const cardsToImport = Array.isArray(parsed) ? parsed : [parsed];
        await importPromptCards(user.uid, cardsToImport);
        showSnackbar(`Successfully imported ${cardsToImport.length} cards!`, 'success');
      } catch (err) {
        showSnackbar(`Failed to import cards: ${err instanceof Error ? err.message : 'Invalid JSON'}`, 'error');
      }
    };
    reader.readAsText(file);
    event.target.value = ''; // Reset file input
  }, [user, importPromptCards, showSnackbar]);

  const handleExport = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    const card = await exportPromptCard(user.uid, cardId);
    if (card) {
      const json = JSON.stringify(card, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `prompt_card_${card.title.replace(/\s/g, '_')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showSnackbar(`Card "${card.title}" exported.`, 'success');
    }
  }, [user, exportPromptCard, showSnackbar]);

  const handleStartGame = useCallback(async () => {
    if (!user?.uid || !activePromptCard) return;
    if (isCardDirty) {
      showSnackbar('Please save changes before starting a game.', 'warning');
      return;
    }
    await initializeGame(user.uid, activePromptCard.id);
    navigate('/game');
  }, [user, activePromptCard, isCardDirty, initializeGame, navigate, showSnackbar]);

  // 4. Return a clean API for the component
  return {
    // State for Rendering
    isLoading,
    error,
    promptCards,
    activePromptCard,
    localEditedCard,
    isCardDirty,
    aiConnections,
    saveDialog: {
      open: showSaveDialog,
      title: saveAsNewTitle
    },
    snackbar,

    // Functions for Event Handlers
    handleCardSelect,
    handleLocalCardChange,
    handleSaveCard,
    handleRevert,
    handleNewCard,
    handleDeleteCard,
    handleDuplicateCard,
    handleImport,
    handleExport,
    handleStartGame,
    setSaveDialog: setShowSaveDialog,
    setSaveAsNewTitle,
    closeSnackbar: () => setSnackbar(prev => ({ ...prev, open: false })),
  };
};
@@END_FILE@@
@@FILE: src/utils/hooks/useSettingsLogic.ts
// src/utils/hooks/useSettingsLogic.ts
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useAuthStore } from '../../state/useAuthStore';
import { useSettingsStore } from '../../state/useSettingsStore';
import type { AiConnection } from '../../models';
import { aiClient } from '../../logic/aiClient';
import { aiConnectionTemplates } from '../../data/config/aiConnectionTemplates';
import type { ModelInfo } from '../../data/config/aiConnectionTemplates';
import { useDialog } from './useDialog'; // <-- ADD IMPORT

export const useSettingsLogic = () => {
  const { user } = useAuthStore();
  const settingsStore = useSettingsStore();

  const [dialogStep, setDialogStep] = useState<'select' | 'details'>('select');
  const [editingConnection, setEditingConnection] = useState<AiConnection | null>(null);
  const [availableModels, setAvailableModels] = useState<ModelInfo[]>([]);
  const [isFetchingModels, setIsFetchingModels] = useState(false);
  const [modelSearchTerm, setModelSearchTerm] = useState('');
  

  const connectionDialog = useDialog();
  const modelInfoDialog = useDialog();

  
  const [testStatus, setTestStatus] = useState<{ text: string, type: 'success' | 'error' | 'info' } | null>(null);
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' | 'info' | 'warning' }>({ open: false, message: '', severity: 'info' });
  const [modelInfo, setModelInfo] = useState<ModelInfo | null>(null);

  useEffect(() => {
    if (user?.uid) {
      settingsStore.fetchAiConnections(user.uid);
    }
  }, [user?.uid, settingsStore.fetchAiConnections]);

  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbar({ open: true, message, severity });
  }, []);

  const handleOpenDialog = useCallback((connection?: AiConnection) => {
    setDialogStep(connection ? 'details' : 'select');
    setEditingConnection(connection ? { ...connection } : null);
    
    const templateKey = connection ? Object.keys(aiConnectionTemplates).find(k => aiConnectionTemplates[k].displayName === connection.displayName) : undefined;
    const initialModels = templateKey ? aiConnectionTemplates[templateKey].commonModels : (connection ? [{ id: connection.modelSlug, name: connection.modelName }] : []);
    
    setAvailableModels(initialModels);
    setModelSearchTerm('');
    setTestStatus(null);
    connectionDialog.open(); // <-- UPDATE TO USE HOOK
  }, [connectionDialog]);

  const handleOpenModelInfo = useCallback((model: ModelInfo) => {
    setModelInfo(model);
    modelInfoDialog.open(); // <-- UPDATE TO USE HOOK
  }, [modelInfoDialog]);

  const handleLoadTemplate = useCallback((templateKey: string) => {
    const template = aiConnectionTemplates[templateKey] || {
        displayName: 'Custom', modelName: '', modelSlug: '', apiUrl: '', apiToken: '', functionCallingEnabled: false,
        userAgent: 'StoryForge/1.0', supportsModelDiscovery: false, commonModels: [],
    };
    setEditingConnection({
      displayName: template.displayName,
      modelName: template.modelName,
      modelSlug: template.modelSlug,
      apiUrl: template.apiUrl,
      apiToken: template.apiToken,
      functionCallingEnabled: template.functionCallingEnabled,
      userAgent: template.userAgent || null,
      id: '',
      createdAt: '',
      lastUpdated: '',
    });
    
    setAvailableModels(template.commonModels);
    setModelSearchTerm('');
    setDialogStep('details');
  }, []);

  const handleFetchModels = useCallback(async () => {
    if (!editingConnection?.apiToken || editingConnection.apiToken.includes('PASTE')) {
      showSnackbar("Please enter a valid API key first.", "warning");
      return;
    }
    setIsFetchingModels(true);
    setTestStatus({ text: "Fetching models...", type: "info" });
    try {
      const models = await aiClient.listModels(editingConnection);
      setAvailableModels(models);
      setTestStatus({ text: `Success! Found ${models.length} models.`, type: "success" });
    } catch (error) {
      setTestStatus({ text: "Failed to fetch models. Check API Key and URL.", type: "error" });
    } finally {
      setIsFetchingModels(false);
    }
  }, [editingConnection, showSnackbar]);

  const filteredModels = useMemo(() => {
    if (!modelSearchTerm) {
      return availableModels;
    }
    const lowercasedFilter = modelSearchTerm.toLowerCase();
    return availableModels.filter(model =>
      model.name.toLowerCase().includes(lowercasedFilter) ||
      model.id.toLowerCase().includes(lowercasedFilter)
    );
  }, [availableModels, modelSearchTerm]);

  const handleCloseDialog = useCallback(() => {
    connectionDialog.close(); // <-- UPDATE TO USE HOOK
  }, [connectionDialog]);
  
  const handleCloseModelInfo = useCallback(() => {
    modelInfoDialog.close(); // <-- UPDATE TO USE HOOK
  }, [modelInfoDialog]);

  const handleUpdateEditingConnection = useCallback((updates: Partial<AiConnection>) => {
    setEditingConnection(prev => prev ? ({ ...prev, ...updates }) : null);
  }, []);

  const handleTest = useCallback(async () => {
    if (!editingConnection) return;
    setTestStatus({ text: 'Testing...', type: 'info' });
    const result = await aiClient.testConnection(editingConnection);
    if (result.success) {
      setTestStatus({ text: `✅ ${result.message}`, type: 'success' });
    } else {
      setTestStatus({ text: result.message, type: 'error' });
    }
  }, [editingConnection]);

  const handleSaveAndTest = useCallback(async () => {
    if (!user?.uid || !editingConnection) return;
    try {
      let savedConn: AiConnection | null;
      if (editingConnection.id) {
        savedConn = await settingsStore.updateAiConnection(user.uid, editingConnection);
        showSnackbar('Connection updated.', 'success');
      } else {
        savedConn = await settingsStore.addAiConnection(user.uid, editingConnection);
        showSnackbar('Connection added.', 'success');
      }
      
      if (savedConn) {
        setEditingConnection(savedConn);
        await handleTest();
      }
    } catch (e) {
      showSnackbar(`Failed to save: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  }, [user, editingConnection, settingsStore, showSnackbar, handleTest]);

  const handleDelete = useCallback(async (connectionId: string) => {
    if (!user?.uid || !window.confirm("Are you sure you want to delete this connection?")) return;
    await settingsStore.deleteAiConnection(user.uid, connectionId);
    showSnackbar('Connection deleted.', 'success');
  }, [user, settingsStore, showSnackbar]);

  const closeSnackbar = useCallback(() => setSnackbar(prev => ({ ...prev, open: false })), []);

  return {
    ...settingsStore,
    isDialogOpen: connectionDialog.isOpen, // <-- UPDATE RETURN VALUE
    openModelInfo: modelInfoDialog.isOpen, // <-- UPDATE RETURN VALUE
    dialogStep,
    editingConnection,
    availableModels,
    isFetchingModels,
    testStatus,
    snackbar,
    templates: aiConnectionTemplates,
    modelSearchTerm,
    setModelSearchTerm,
    filteredModels,
    modelInfo,
    handleOpenDialog,
    handleCloseDialog,
    handleLoadTemplate,
    handleUpdateEditingConnection,
    handleFetchModels,
    handleSaveAndTest,
    handleDelete,
    closeSnackbar,
    handleTest,
    handleOpenModelInfo,
    handleCloseModelInfo,
  };
};
@@END_FILE@@
@@FILE: src/utils/hooks/useWorldStateViewLogic.ts
// src/utils/hooks/useWorldStateViewLogic.ts
import { useState, useMemo, useCallback } from 'react';
// IMPORT THE SELECTOR FOR PINNED KEYS
import {
    useGameStateStore,
    selectWorldStatePinnedKeys,
    selectCurrentGameState,
  } from '../../state/useGameStateStore';
import { flattenJsonObject, getNestedValue } from '../../utils/jsonUtils';
import { debugLog, errorLog } from '../../utils/debug';

interface GroupedWorldState {
    [category: string]: {
        [entity: string]: {
            [variable: string]: any;
        };
    };
}

export const useWorldStateViewLogic = () => {
    const gameState = useGameStateStore(selectCurrentGameState);
    // 1. Get necessary state and actions from the store
    const worldStatePinnedKeys = useGameStateStore(selectWorldStatePinnedKeys);
    const {
        toggleWorldStatePin, // Action to toggle pins
        renameWorldCategory, // Action to rename categories
        renameWorldEntity,   // Action to rename entities
        deleteWorldCategory, // Action to delete categories
        deleteWorldEntity,   // Action to delete entities
        editWorldKeyValue,   // Action to edit key-value pairs
        deleteWorldKey,      // Action to delete keys
    } = useGameStateStore(); // Destructure actions directly

    // 2. Declare and initialize all local UI state variables
    const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());
    const [expandedEntities, setExpandedEntities] = useState<Set<string>>(new Set());
    const [editingCategory, setEditingCategory] = useState<string | null>(null);
    const [newCategoryName, setNewCategoryName] = useState('');
    const [editingEntity, setEditingEntity] = useState<[string, string] | null>(null); // Stores [category, entity]
    const [newEntityName, setNewEntityName] = useState('');

    // --- KEEP EXISTING DEBUG LINES ---
    debugLog('%c[useWorldStateViewLogic.ts] Hook re-executed.', 'color: #B8860B; font-weight: bold;');
    debugLog('[useWorldStateViewLogic.ts] Received gameState prop from WorldStateScreen:', JSON.stringify(gameState, null, 2));
    debugLog('[useWorldStateViewLogic.ts] Extracted worldState from prop (gameState?.worldState):', JSON.stringify(gameState?.worldState, null, 2));
    debugLog('[useWorldStateViewLogic.ts] Extracted worldState keys length (gameState?.worldState):', Object.keys(gameState?.worldState || {}).length);
    debugLog('[useWorldStateViewLogic.ts] Pinned keys directly from store (in logic):', worldStatePinnedKeys);
    // --- END DEBUG LINES ---

    const worldState = gameState?.worldState || {};
    const flattenedWorld = useMemo(() => {
        const flat = flattenJsonObject(worldState);
        debugLog('[useWorldStateViewLogic.ts] Calculated flattenedWorld (inside useMemo):', JSON.stringify(flat, null, 2));
        debugLog('[useWorldStateViewLogic.ts] Flattened World keys length (inside useMemo):', Object.keys(flat).length);
        return flat;
    }, [worldState]);

    const groupedByCategory = useMemo(() => {
        const grouped: GroupedWorldState = {};
        for (const fullKey in flattenedWorld) {
            const value = flattenedWorld[fullKey];
            const parts = fullKey.split(".");
            if (parts.length < 1) continue;

            const category = parts[0];
            const entity = (parts.length > 1 && (parts[1].startsWith('#') || parts[1].startsWith('@') || parts[1].startsWith('$'))) ? parts[1] : '@@_direct';
            const variable = (entity === '@@_direct') ? parts.slice(1).join('.') : parts.slice(2).join('.');
            if (!variable) continue;

            grouped[category] = grouped[category] || {};
            grouped[category][entity] = grouped[category][entity] || {};
            grouped[category][entity][variable] = value;
        }
        for (const category in grouped) {
            if (Object.keys(grouped[category]['@@_direct'] || {}).length === 0) {
                delete grouped[category]['@@_direct'];
            }
        }
        debugLog('[useWorldStateViewLogic.ts] Grouped by Category (inside useMemo):', JSON.stringify(grouped, null, 2));
        debugLog('[useWorldStateViewLogic.ts] Grouped by Category keys length (inside useMemo):', Object.keys(grouped).length);
        return grouped;
    }, [flattenedWorld]);

    // Utility to get all variable keys under a given path (entity or category)
    const getAllChildVariableKeys = useCallback((basePath: string): string[] => {
        const nestedData = getNestedValue(worldState, basePath.split('.'));
        if (typeof nestedData !== 'object' || nestedData === null) return [];
        // Flatten the nested data starting from the basePath to get its direct children keys
        return Object.keys(flattenJsonObject(nestedData, basePath));
    }, [worldState]);

    // Memoized checks for pinning status
    const isAnyChildPinned = useCallback((parentPath: string) => {
        return getAllChildVariableKeys(parentPath).some(key => worldStatePinnedKeys.includes(key));
    }, [getAllChildVariableKeys, worldStatePinnedKeys]);

    const areAllChildrenPinned = useCallback((parentPath: string) => {
        const childKeys = getAllChildVariableKeys(parentPath);
        return childKeys.length > 0 && childKeys.every(key => worldStatePinnedKeys.includes(key));
    }, [getAllChildVariableKeys, worldStatePinnedKeys]);

    // Handlers for expanding/collapsing categories and entities
    const handleToggleCategoryExpand = useCallback((category: string) => {
        setExpandedCategories(prev => {
            const newSet = new Set(prev);
            newSet.has(category) ? newSet.delete(category) : newSet.add(category);
            return newSet;
        });
    }, []);

    const handleToggleEntityExpand = useCallback((category: string, entity: string) => {
        const key = `${category}.${entity}`;
        setExpandedEntities(prev => {
            const newSet = new Set(prev);
            newSet.has(key) ? newSet.delete(key) : newSet.add(key);
            return newSet;
        });
    }, []);

    // Handlers for pinning/unpinning
    const handleToggleCategoryPin = useCallback((category: string) => {
        toggleWorldStatePin(category, 'category');
    }, [toggleWorldStatePin]);

    const handleToggleEntityPin = useCallback((entityPath: string) => {
        toggleWorldStatePin(entityPath, 'entity');
    }, [toggleWorldStatePin]);

    // Handlers for renaming category
    const handleStartRenameCategory = useCallback((category: string) => {
        setEditingCategory(category);
        setNewCategoryName(category); // Initialize input with current name
    }, []);

    const handleConfirmRenameCategory = useCallback(async () => {
        if (editingCategory && newCategoryName.trim() && newCategoryName !== editingCategory) {
            await renameWorldCategory(editingCategory, newCategoryName.trim());
        }
        setEditingCategory(null); // Exit edit mode
        setNewCategoryName(''); // Clear input
    }, [editingCategory, newCategoryName, renameWorldCategory]);

    // Handlers for renaming entity
    const handleStartRenameEntity = useCallback((entityPathParts: [string, string]) => { // entityPathParts is [category, entity]
        setEditingEntity(entityPathParts);
        setNewEntityName(entityPathParts[1]); // Initialize input with current entity name
    }, []);

    const handleConfirmRenameEntity = useCallback(async () => {
        if (editingEntity && newEntityName.trim() && newEntityName !== editingEntity[1]) {
            await renameWorldEntity(editingEntity[0], editingEntity[1], newEntityName.trim());
        }
        setEditingEntity(null); // Exit edit mode
        setNewEntityName(''); // Clear input
    }, [editingEntity, newEntityName, renameWorldEntity]);

    // Handler to cancel any edit operation
    const cancelEdit = useCallback(() => {
        setEditingCategory(null);
        setEditingEntity(null);
        setNewCategoryName('');
        setNewEntityName('');
    }, []);

    // 5. Return the clean API
    return {
        // Derived Data
        groupedByCategory,
        worldStatePinnedKeys,
        isAnyChildPinned,
        areAllChildrenPinned,

        // Local UI State
        expandedCategories,
        expandedEntities,
        editingCategory,
        newCategoryName,
        editingEntity,
        newEntityName,

        // Handlers (from store and local)
        handleToggleCategoryExpand,
        handleToggleEntityExpand,
        handleToggleCategoryPin,
        handleToggleEntityPin,
        handleStartRenameCategory,
        handleConfirmRenameCategory,
        setNewCategoryName,
        handleStartRenameEntity,
        handleConfirmRenameEntity,
        setNewEntityName,
        cancelEdit,

        // Actions passed directly from store (for clarity)
        deleteWorldCategory,
        deleteWorldEntity,
        editWorldKeyValue,
        deleteWorldKey,
        toggleWorldStatePin, // Ensure this is correctly passed if needed elsewhere
    };
};
@@END_FILE@@
@@FILE: src/utils/jsonUtils.ts
// src/utils/jsonUtils.ts


/**
 * Flattens a nested JSON object into a single-level map with dot-separated keys.
 * @param obj The JSON object to flatten.
 * @param prefix The prefix for the current level (used in recursion).
 * @returns A map where keys are dot-separated paths and values are primitives or arrays/objects at the leaf.
 */
export function flattenJsonObject(obj: Record<string, any>, prefix: string = ""): Record<string, any> {
  const result: Record<string, any> = {};

  for (const k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      const fullKey = prefix ? `${prefix}.${k}` : k;
      const value = obj[k];

      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        Object.assign(result, flattenJsonObject(value, fullKey));
      } else {
        result[fullKey] = value;
      }
    }
  }
  return result;
}

/**
 * Attempts to parse a string into a JSON primitive (string, number, boolean, null).
 * This is a simplified version of the Android `parseJsonPrimitive` and may need robustness.
 * @param text The string to parse.
 * @returns The parsed JSON primitive or the original string if no better match.
 */
export function parseJsonPrimitive(text: string): any {
  const trimmed = text.trim();

  if (trimmed.toLowerCase() === 'true') return true;
  if (trimmed.toLowerCase() === 'false') return false;
  if (trimmed === 'null') return null;

  const num = Number(trimmed);
  if (!isNaN(num) && isFinite(num)) {
    return num;
  }

  // If it's a string that looks like a string (quoted), remove quotes
  if (trimmed.startsWith('"') && trimmed.endsWith('"') && trimmed.length >= 2) {
    return trimmed.substring(1, trimmed.length - 1);
  }

  // Fallback: if string doesn't parse cleanly, treat as raw string
  return trimmed;
}

/**
 * Safely retrieves a nested value from an object using a dot-separated path.
 * @param obj The object to traverse.
 * @param pathParts An array of strings representing the path.
 * @returns The value at the specified path, or undefined if not found.
 */
export function getNestedValue(obj: Record<string, any>, pathParts: string[]): any {
  let current: any = obj;
  for (const part of pathParts) {
    if (typeof current !== 'object' || current === null || !(part in current)) {
      return undefined;
    }
    current = current[part];
  }
  return current;
}
@@END_FILE@@
@@FILE: src/utils/types.ts
// src/utils/types.ts

export enum LogViewMode {
  USER_INPUT = 'User Input',
  NARRATOR_OUTPUT = 'Narrator Output (Parsed Prose)',
  RAW_NARRATOR_OUTPUT = 'Raw Narrator Output (Full AI Response)',
  DIGEST_LINES = 'Digest Lines',
  DELTAS = 'Deltas',
  CONTEXT_SNAPSHOT = 'Context Snapshot (Prompt)',
  TOKEN_USAGE = 'Token Usage',
  AI_SETTINGS = 'AI Settings',
  API_DETAILS = 'API Details (URL, Latency)', // This will now be for metadata only
  API_REQUEST_BODY = 'API Request Body',     // ADD THIS
  API_RESPONSE_BODY = 'API Response Body',   // ADD THIS
  MODEL_SLUG_USED = 'Model Slug Used',
  ERROR_FLAGS = 'Error Flags',
}
@@END_FILE@@
@@FILE: src/utils/uuid.ts
// src/utils/uuid.ts

import { v4 as uuidv4 } from 'uuid';

/**
 * Generates a new unique UUID (Universally Unique Identifier).
 * @returns A string representation of a UUID v4.
 */
export function generateUuid(): string {
  return uuidv4();
}
@@END_FILE@@
@@FILE: src/vite-env.d.ts
/// <reference types="vite/client" />

@@END_FILE@@
