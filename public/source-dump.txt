@@FILE: src/App.css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

@@FILE: src/App.tsx
// src/App.tsx

import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, useNavigate, useLocation } from 'react-router-dom';
import CodeIcon from '@mui/icons-material/Code';
import {
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  CssBaseline,
  Box,
  CircularProgress,
  Typography,
  Divider,
  IconButton
} from '@mui/material';
import LibraryBooksIcon from '@mui/icons-material/LibraryBooks';
import StyleIcon from '@mui/icons-material/Style';
import SettingsIcon from '@mui/icons-material/Settings';
import LogoutIcon from '@mui/icons-material/Logout';
import TravelExploreIcon from '@mui/icons-material/TravelExplore';
import HistoryIcon from '@mui/icons-material/History';
import DataObjectIcon from '@mui/icons-material/DataObject';
import LoginScreen from './ui/screens/LoginScreen';
import GameLibraryScreen from './ui/screens/GameLibraryScreen';
import PromptCardManager from './ui/screens/PromptCardManager';
import GameScreen from './ui/screens/GameScreen';
import WorldStateScreen from './ui/screens/WorldStateScreen';
import LogViewerScreen from './ui/screens/LogViewerScreen';
import SettingsScreen from './ui/screens/SettingsScreen';
import { useAuthStore } from './state/useAuthStore';
import { useTheme, ThemeProvider, createTheme } from '@mui/material/styles';
import { useSettingsStore } from './state/useSettingsStore';
import { useGameStateStore } from './state/useGameStateStore';
import SourceDump from './ui/screens/SourceDump';
import MenuIcon from '@mui/icons-material/Menu'; // NEW: Import MenuIcon


const drawerWidth = 240;
const AppContent: React.FC = () => {
  const { user, isLoading: authLoading, signOut } = useAuthStore();
  const { currentSnapshot, loadLastActiveGame, gameLoading } = useGameStateStore();
  const navigate = useNavigate();
  const location = useLocation(); // Get current location
  const [mobileOpen, setMobileOpen] = useState(false);
  const [initialLoadChecked, setInitialLoadChecked] = useState(false);

  useEffect(() => {
    const publicPaths = ['/login', '/sourcedump'];

    if (authLoading) return;

    if (!user) {
      if (!publicPaths.includes(location.pathname)) {
        navigate('/login');
      }
      return;
    }

    if (!initialLoadChecked) {
      console.log("AppContent: User logged in, attempting to load last active game...");
      loadLastActiveGame(user.uid).then((gameLoaded) => {
        setInitialLoadChecked(true);
        if (gameLoaded) {
          if (!['/game', '/world-state', '/logs', '/sourcedump'].includes(location.pathname)) {
            navigate('/game');
          }
        } else {
          // If no game was loaded and user is authenticated and not on a public path,
          // direct them to the game library to start a new game or select one.
          if (!publicPaths.includes(location.pathname)) {
            navigate('/library');
          }
        }
      });
    }
  }, [user, authLoading, navigate, initialLoadChecked, loadLastActiveGame, location.pathname]);


  const handleDrawerToggle = () => setMobileOpen(!mobileOpen);

  const handleSignOut = async () => {
    await signOut();
    navigate('/login');
  };

  const navItems = [
    { text: 'Saved Games', icon: <LibraryBooksIcon />, path: '/library', requiresAuth: true },
    { text: 'Prompt Cards', icon: <StyleIcon />, path: '/cards', requiresAuth: true },
    { text: 'Current Game', icon: <TravelExploreIcon />, path: '/game', requiresAuth: true, disabled: !currentSnapshot },
    { text: 'World State', icon: <DataObjectIcon />, path: '/world-state', requiresAuth: true, disabled: !currentSnapshot },
    { text: 'Log Viewer', icon: <HistoryIcon />, path: '/logs', requiresAuth: true, disabled: !currentSnapshot },
    { text: 'Settings', icon: <SettingsIcon />, path: '/settings', requiresAuth: true },
    { text: 'Source Dump', icon: <CodeIcon />, path: '/sourcedump', requiresAuth: false, disabled: false },
  ];

  if (authLoading || (user && !initialLoadChecked)) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Authenticating & Loading Session...</Typography>
      </Box>
    );
  }

  const drawer = (
    <Box onClick={handleDrawerToggle} sx={{ textAlign: 'center' }}>
      <Typography variant="h6" sx={{ my: 2 }}>StoryForge</Typography>
      <Divider />
      <List>
        {navItems.filter(item => user ? true : !item.requiresAuth).map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton onClick={() => navigate(item.path)} disabled={item.disabled}>
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
        {user ? (
          <ListItem disablePadding>
            <ListItemButton onClick={handleSignOut}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItemButton>
          </ListItem>
        ) : (
          <ListItem disablePadding>
            <ListItemButton onClick={() => navigate('/login')}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Login" />
            </ListItemButton>
          </ListItem>
        )}
      </List>
    </Box>
  );

  return (
    <Box sx={{ display: 'flex', height: '100vh' }}>
      <CssBaseline />
      <Drawer
        variant="temporary"
        open={mobileOpen}
        onClose={handleDrawerToggle}
        ModalProps={{ keepMounted: true }}
        sx={{ '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth }, }}
      >
        {drawer}
      </Drawer>

      {/* Main content area, now structured with its own AppBar */}
      <Box component="main" sx={{ flexGrow: 1, height: '100%', display: 'flex', flexDirection: 'column' }}>
        <IconButton
          color="inherit"
          aria-label="open drawer"
          onClick={handleDrawerToggle}
          edge="start"
          sx={{
            position: 'fixed',
            top: 16,
            right: 16,
            zIndex: (theme) => theme.zIndex.drawer + 1,
            backgroundColor: (theme) => theme.palette.background.paper,
            boxShadow: 2,
            '&:hover': {
              backgroundColor: (theme) => theme.palette.action.hover,
            },
          }}
        >
          <MenuIcon />
        </IconButton>     
          <Routes>
            {/* IMPORTANT: Remove onNavToggle from individual route elements.
                The AppContent's global AppBar now handles navigation toggling.
                The screen components should adjust their headers accordingly. */}
            <Route path="/sourcedump" element={<SourceDump onNavToggle={handleDrawerToggle} />} />
            <Route path="/login" element={<LoginScreen onNavToggle={handleDrawerToggle} />} />

            {user ? (
              <>
                {/* No `onNavToggle` prop needed on these components anymore */}
                <Route path="/library" element={<GameLibraryScreen onNavToggle={handleDrawerToggle} />} />
                <Route path="/cards" element={<PromptCardManager onNavToggle={handleDrawerToggle} />} />

                {currentSnapshot ? (
                  <>
                      <Route path="/game" element={<GameScreen onNavToggle={handleDrawerToggle} />} />
                      <Route path="/world-state" element={<WorldStateScreen onNavToggle={handleDrawerToggle} />} />
                      <Route path="/logs" element={<LogViewerScreen onNavToggle={handleDrawerToggle} />} />
                  </>
                ) : (
                  null
                )}
                <Route path="/settings" element={<SettingsScreen onNavToggle={handleDrawerToggle} />} />
                <Route path="/" element={<GameLibraryScreen onNavToggle={handleDrawerToggle} />} />
                <Route path="*" element={<GameLibraryScreen onNavToggle={handleDrawerToggle} />} />
              </>
            ) : (
              <Route path="*" element={<LoginScreen />} />
            )}
          </Routes>
        </Box>
      </Box>
  );
};

const App: React.FC = () => {
  const { themeMode } = useSettingsStore(); // Get theme mode from settings store
  const theme = React.useMemo(
    () =>
      createTheme({
        palette: {
          mode: themeMode,
          primary: {
            main: '#6200EE', // A shade of purple
          },
          secondary: {
            main: '#03DAC6', // A shade of teal
          },
          background: {
            default: themeMode === 'light' ? '#f5f5f5' : '#121212',
            paper: themeMode === 'light' ? '#ffffff' : '#1e1e1e',
          },
        },
        typography: {
            h6: {
                fontWeight: 600,
            },
        },
        components: {
            MuiPaper: {
                styleOverrides: {
                    root: ({ theme }) => ({
                        backgroundColor: theme.palette.background.paper,
                        border: `1px solid ${theme.palette.divider}`,
                    }),
                },
            },
            MuiCard: {
                styleOverrides: {
                    root: ({ theme }) => ({
                        backgroundColor: theme.palette.background.paper,
                        border: `1px solid ${theme.palette.divider}`,
                    }),
                },
            },
            MuiDialog: {
                styleOverrides: {
                    paper: ({ theme }) => ({
                        backgroundColor: theme.palette.background.paper,
                        border: `1px solid ${theme.palette.divider}`,
                    }),
                },
            },
            MuiButton: {
                styleOverrides: {
                    root: ({ theme }) => ({
                        borderRadius: '8px',
                    }),
                },
            },
            MuiSwitch: {
                styleOverrides: {
                    switchBase: ({ theme }) => ({
                        color: theme.palette.grey[500],
                    }),
                    checked: ({ theme }) => ({
                        color: theme.palette.primary.main,
                        '& + .MuiSwitch-track': {
                            backgroundColor: theme.palette.primary.main,
                        },
                    }),
                },
            },
            MuiSlider: {
                styleOverrides: {
                    thumb: ({ theme }) => ({
                        color: theme.palette.primary.main,
                    }),
                    track: ({ theme }) => ({
                        color: theme.palette.primary.main,
                    }),
                    rail: ({ theme }) => ({
                        color: theme.palette.grey[400],
                    }),
                },
            },
            MuiListItemButton: {
                styleOverrides: {
                    root: ({ theme }) => ({
                        '&.Mui-selected': {
                            backgroundColor: theme.palette.action.selected,
                        },
                        '&.Mui-selected:hover': {
                            backgroundColor: theme.palette.action.hover,
                        },
                    }),
                },
            },
            MuiAlert: {
                styleOverrides: {
                    root: ({ theme }) => ({
                        borderRadius: '8px',
                        backgroundColor: theme.palette.background.paper,
                        border: `1px solid ${theme.palette.divider}`,
                    }),
                },
            },
            MuiSnackbarContent: {
                styleOverrides: {
                    root: ({ theme }) => ({
                        backgroundColor: theme.palette.background.paper,
                        color: theme.palette.text.primary,
                        border: `1px solid ${theme.palette.divider}`,
                    }),
                },
            },
        },
      }),
    [themeMode],
  );

  return (
    <ThemeProvider theme={theme}>
      <Router>
        <AppContent />
      </Router>
    </ThemeProvider>
  );
};

export default App;
@@FOLDER: src/assets
@@FILE: src/assets/react.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
@@FOLDER: src/contexts
@@FILE: src/contexts/GameSessionContext.tsx
// src/contexts/GameSessionContext.tsx

import React, { createContext, useContext } from 'react';
import { IGameSession } from '../logic/gameSession';

// Define the context to hold the IGameSession instance
const GameSessionContext = createContext<IGameSession | undefined>(undefined);

// Provider component to wrap the application and provide the gameSession
export const GameSessionProvider: React.FC<{ children: React.ReactNode; gameSession: IGameSession }> = ({ children, gameSession }) => {
  return (
    <GameSessionContext.Provider value={gameSession}>
      {children}
    </GameSessionContext.Provider>
  );
};

// Custom hook to easily consume the gameSession from the context by React components
export const useGameSession = () => {
  const context = useContext(GameSessionContext);
  if (context === undefined) {
    throw new Error('useGameSession must be used within a GameSessionProvider');
  }
  return context;
};
@@FOLDER: src/data
@@FOLDER: src/data/config
@@FILE: src/data/config/promptCardDefaults.ts
// src/data/config/promptCardDefaults.ts

// In src/data/config/promptCardDefaults.ts
import { AiSettingsInCard } from '../../models/PromptCard'; // Corrected path
import { StackInstructions, StackMode, FilterMode } from '../../models/StackInstructions'; // Corrected path

/**
 * Default AI settings to be used for PromptCards if not specified.
 * Corresponds to AiSettings.kt's default values, now embedded in PromptCard.
 */
export const defaultAiSettingsInCard: AiSettingsInCard = {
  selectedConnectionId: "",
  temperature: 0.7,
  topP: 1.0,
  maxTokens: 2048,
  presencePenalty: 0.0,
  frequencyPenalty: 0.0,
  functionCallingEnabled: false,
};

/**
 * Default structured StackInstructions object.
 * This is the parsed object version of the default JSON string from PromptCardDefaults.kt.
 */
export const defaultStackInstructions: StackInstructions = {
  narratorProseEmission: { mode: StackMode.FIRST_N, n: 3, filtering: FilterMode.SCENE_ONLY, enabled: true }, // NEW: enabled: true
  digestPolicy: { filtering: FilterMode.TAGGED, enabled: true }, // NEW: enabled: true
  digestEmission: {
    "5": { mode: StackMode.ALWAYS },
    "4": { mode: StackMode.AFTER_N, n: 1 },
    "3": { mode: StackMode.FIRST_N, n: 6 },
    "2": { mode: StackMode.FIRST_N, n: 3 },
    "1": { mode: StackMode.NEVER },
  },
  expressionLogPolicy: { mode: StackMode.ALWAYS, filtering: FilterMode.SCENE_ONLY, enabled: true }, // NEW: enabled: true
  expressionLinesPerCharacter: 3,
  emotionWeighting: true,
  worldStatePolicy: { mode: StackMode.FILTERED, filtering: FilterMode.SCENE_ONLY, enabled: true }, // NEW: enabled: true
  knownEntitiesPolicy: { mode: StackMode.FIRST_N, n: 2, filtering: FilterMode.TAGGED, enabled: true }, // NEW: enabled: true
  // REMOVED: "outputFormat": "prose_digest_emit",
  tokenPolicy: {
    minTokens: 1000,
    maxTokens: 4096,
    fallbackPlan: [
      "drop_known_entities",
      "drop_low_importance_digest",
      "truncate_expression_logs",
    ],
  },
};

/**
 * Default content for the 'firstTurnOnlyBlock' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_FIRST_TURN_PROMPT_BLOCK: string = `The camera pans down. It's your first time in this place.
Describe the scene and how the world feels from the character's perspective.`;

/**
 * Default content for the 'emitSkeleton' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_EMIT_SKELETON_STRING: string = `
### Narrator Output Structure

**IMPORTANT:** Your response MUST follow this exact structure. Each section MUST be separated by the specified markers on their own lines.

1.  **Narrative Prose:**
    *   Begin with clear, immersive narration in freeform prose.
    *   This is the only section that should contain descriptive text. It MUST NOT contain any markers or JSON blocks.

2.  **Summary Digest Block (\`@digest\`):**
    *   After the prose, you MUST include a single newline, followed by the marker \`@digest\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing an array of 1-5 summary lines.
    *   Each line MUST have an importance score from 1 (minor) to 5 (critical).

3.  **Emit Block (\`@delta\`):**
    *   After the digest block, include a single newline, followed by the marker \`@delta\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing key-value deltas for the world state.

4.  **Scene Change Block (\`@scene\`, Optional):**
    *   If the scene has shifted, include a single newline, followed by the marker \`@scene\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block with the new scene object.

---

### **MANDATORY OUTPUT FORMAT EXAMPLE**

This is not optional. Your output must match this structure precisely.

The mist curls like spectral fingers around the ancient oaks. #Lyrielle stands rigid, her silver-threaded cloak shimmering faintly in the moonlight. You feel a sudden chill as #Brom shifts his weight, his leather armor creaking.

@digest
\`\`\`json
[
  { "text": "#Lyrielle appears tense and wary.", "importance": 3 },
  { "text": "The mist in @MoonlitVale thickens, obscuring the path.", "importance": 2 }
]
\`\`\`

@delta
\`\`\`json
{
  "=npcs.#lyrielle.status": "wary",
  "+world.environment.fog_density": 0.1
}
\`\`\`

@scene
\`\`\`json
{
  "location": "@MoonlitVale",
  "present": ["#you", "#lyrielle", "#brom"],
  "weather": "foggy"
}
\`\`\`
---

### Emit & Tagging Rules

*   **Emit Rules:** Paths are \`category.entity.field\`. Use symbolic ops: \`+\`, \`=\`, \`!\`, \`-\`. Paths must be valid.
*   **Tagging Rules:** Use \`#\` for characters, \`@\` for locations, \`$\` for items. Use tags consistently in narration and emits.

`.trim();
@@FOLDER: src/data/infrastructure
@@FILE: src/data/infrastructure/firebaseClient.ts
// src/data/infrastructure/firebaseClient.ts

import { initializeApp, getApps, getApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore'; // Removed initializeFirestore and PersistentLocalCache

// Your Firebase configuration
function getEnvVar(name: string): string {
  const value = import.meta.env[name] as string | undefined;
  if (!value) {
    throw new Error(`Missing required environment variable: ${name}`);
  }
  return value;
}

const firebaseConfig = {
  apiKey: getEnvVar('VITE_FIREBASE_API_KEY'),
  authDomain: getEnvVar('VITE_FIREBASE_AUTH_DOMAIN'),
  projectId: getEnvVar('VITE_FIREBASE_PROJECT_ID'),
  storageBucket: getEnvVar('VITE_FIREBASE_STORAGE_BUCKET'),
  messagingSenderId: getEnvVar('VITE_FIREBASE_MESSAGING_SENDER_ID'),
  appId: getEnvVar('VITE_FIREBASE_APP_ID'),
};

// Initialize Firebase App
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

// Get Firebase services (without offline persistence for MVP)
export const auth = getAuth(app);
export const db = getFirestore(app);
@@FOLDER: src/data/repositories
@@FILE: src/data/repositories/authRepository.ts
// src/data/authRepository.ts

import {
  GoogleAuthProvider,
  signInWithPopup,
  signOut,
  onAuthStateChanged,
  User,
} from 'firebase/auth';
import { auth } from '../infrastructure/firebaseClient'; // Import the auth instance from our firebaseClient

/**
 * Handles user login using Google as the authentication provider.
 * @returns A Promise that resolves with the Firebase User credential if successful, or rejects with an error.
 */
export async function signInWithGoogle(): Promise<User | null> {
  const provider = new GoogleAuthProvider();
  try {
    const result = await signInWithPopup(auth, provider);
    // The signed-in user info.
    const user = result.user;
    console.log("User logged in:", user.uid);
    return user;
  } catch (error: any) {
    // Handle Errors here.
    const errorCode = error.code;
    const errorMessage = error.message;
    // The email of the user's account used.
    const email = error.customData?.email;
    // The AuthCredential type that was used.
    const credential = GoogleAuthProvider.credentialFromError(error);
    console.error("Error signing in with Google:", errorCode, errorMessage, email, credential);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Handles user logout.
 * @returns A Promise that resolves when the user is successfully signed out.
 */
export async function signOutUser(): Promise<void> {
  try {
    await signOut(auth);
    console.log("User signed out.");
  } catch (error) {
    console.error("Error signing out:", error);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Subscribes to authentication state changes.
 * This is crucial for keeping the UI updated about the current user's login status.
 * @param callback A function to call when the auth state changes, receiving the current Firebase User or null.
 * @returns An unsubscribe function that can be called to stop listening for changes.
 */
export function subscribeToAuthChanges(callback: (user: User | null) => void): () => void {
  // onAuthStateChanged returns an unsubscribe function
  const unsubscribe = onAuthStateChanged(auth, (user) => {
    callback(user);
  });
  console.log("Auth state change listener attached.");
  return unsubscribe;
}

// Optional: You could also add a way to get the current user synchronously if needed,
// though `subscribeToAuthChanges` is generally preferred for reactivity.
export function getCurrentUser(): User | null {
  return auth.currentUser;
}
@@FILE: src/data/repositories/gameRepository.ts
// src/data/repositories/gameRepository.ts

import {
  collection,
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  query,
  getDocs,
  serverTimestamp,
  orderBy,
  Timestamp, // Import Timestamp type
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient';
import { GameSnapshot } from '../../models/GameSnapshot';
import { AiConnection } from '../../models/AiConnection';
import { generateUuid } from '../../utils/uuid'; // Import generateUuid

/**
 * Defines the contract for GameSnapshot and AiConnection data persistence operations.
 */
export interface IGameRepository {
  /**
   * Saves a new or updates an existing GameSnapshot.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshot The GameSnapshot object to save.
   * @returns A Promise that resolves when the snapshot is successfully saved.
   */
  saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void>;

  /**
   * Retrieves a single GameSnapshot by its ID for a specific user.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshotId The ID of the GameSnapshot to retrieve.
   * @returns A Promise that resolves with the GameSnapshot object or null if not found.
   */
  getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null>;

  /**
   * Retrieves all GameSnapshots for a specific user, ordered by updatedAt descending.
   * @param userId The ID of the user owning the snapshots.
   * @returns A Promise that resolves with an array of GameSnapshot objects.
   */
  getAllGameSnapshots(userId: string): Promise<GameSnapshot[]>;

  /**
   * Deletes a GameSnapshot by its ID for a specific user.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshotId The ID of the GameSnapshot to delete.
   * @returns A Promise that resolves when the snapshot is successfully deleted.
   */
  deleteGameSnapshot(userId: string, snapshotId: string): Promise<void>;

  /**
   * Retrieves all AI Connections for a user.
   * @param userId The ID of the user.
   * @returns A Promise resolving with an array of AiConnection objects.
   */
  getAiConnections(userId: string): Promise<AiConnection[]>;

  /**
   * Saves a new or updates an existing AI Connection.
   * @param userId The ID of the user.
   * @param connection The AiConnection object to save.
   * @returns A Promise that resolves when the connection is successfully saved.
   */
  saveAiConnection(userId: string, connection: AiConnection): Promise<void>;

  /**
   * Deletes an AI Connection by its ID for a specific user.
   * @param userId The ID of the user.
   * @param connectionId The ID of the AiConnection to delete.
   * @returns A Promise that resolves when the connection is successfully deleted.
   */
  deleteAiConnection(userId: string, connectionId: string): Promise<void>;
}

/**
 * Concrete implementation of IGameRepository using Firestore.
 */
class FirestoreGameRepository implements IGameRepository {

  private getSnapshotsCollectionRef(userId: string) {
    // Path: users/{userId}/gameSnapshots
    return collection(db, 'users', userId, 'gameSnapshots');
  }

  private getAiConnectionsCollectionRef(userId: string) {
    // Path: users/{userId}/aiConnections
    return collection(db, 'users', userId, 'aiConnections');
  }

  // Helper to convert Firestore Timestamp to ISO string
  private convertTimestamps<T extends { createdAt?: any; updatedAt?: any; lastUpdated?: any }>(data: any): T {
    const convertedData: any = { ...data };

    if (data.createdAt && data.createdAt instanceof Timestamp) {
      convertedData.createdAt = data.createdAt.toDate().toISOString();
    }
    if (data.updatedAt && data.updatedAt instanceof Timestamp) {
      convertedData.updatedAt = data.updatedAt.toDate().toISOString();
    }
    // This is the specific field causing the error. 
    // Only convert it if it exists on the source object.
    if (data.lastUpdated && data.lastUpdated instanceof Timestamp) {
      convertedData.lastUpdated = data.lastUpdated.toDate().toISOString();
    }
    
    return convertedData as T;
  }

  async saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshot.id);
    console.log(`FirestoreGameRepository: Attempting to setDoc for GameSnapshot ${snapshot.id} for user ${userId}.`);
    try {
      await setDoc(snapshotDocRef, {
        // Pass all snapshot data, including the new 'title'
        ...snapshot,
        updatedAt: serverTimestamp() // Always update timestamp on save
      }, { merge: true });
      console.log(`FirestoreGameRepository: Successfully setDoc for GameSnapshot ${snapshot.id}.`);
    } catch (e) {
      console.error(`FirestoreGameRepository: FAILED to setDoc for GameSnapshot ${snapshot.id}:`, e);
      throw e; // Re-throw the error for GameSession to catch
    }
  }

  async getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    const snapshotSnap = await getDoc(snapshotDocRef);

    if (snapshotSnap.exists()) {
      const data = snapshotSnap.data();
      // Ensure title is retrieved
      return this.convertTimestamps<GameSnapshot>(data) as GameSnapshot;
    } else {
      console.log(`No GameSnapshot found with ID: ${snapshotId} for user ${userId}`);
      return null;
    }
  }

  async getAllGameSnapshots(userId: string): Promise<GameSnapshot[]> {
    const q = query(
      this.getSnapshotsCollectionRef(userId),
      orderBy('updatedAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    const snapshots: GameSnapshot[] = [];
    querySnapshot.forEach((doc) => {
      // Ensure title is retrieved
      snapshots.push(this.convertTimestamps<GameSnapshot>(doc.data()) as GameSnapshot);
    });
    return snapshots;
  }

  async deleteGameSnapshot(userId: string, snapshotId: string): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    await deleteDoc(snapshotDocRef);
    console.log(`GameSnapshot ${snapshotId} deleted for user ${userId}`);
  }

  async getAiConnections(userId: string): Promise<AiConnection[]> {
    const q = query(
      this.getAiConnectionsCollectionRef(userId),
      orderBy('displayName', 'asc') // Order by display name
    );
    const querySnapshot = await getDocs(q);
    const connections: AiConnection[] = [];
    querySnapshot.forEach((docSnap) => {
      // Ensure the ID from the document is used
      connections.push(this.convertTimestamps<AiConnection>(docSnap.data()));
    });

    // Provide a default DeepSeek connection if no connections exist for the user.
    // This allows immediate testing without requiring users to manually add one.
    if (connections.length === 0) {
      console.log("No AI connections found, returning default.");
      return [
        {
          id: generateUuid(), // Use a generated UUID for the default
          displayName: 'DeepSeek Coder (Default)', // Added displayName
          modelName: 'DeepSeek Coder (Default)',
          modelSlug: 'deepseek-coder',
          apiUrl: 'https://api.deepseek.com/v1/',
          apiToken: 'YOUR_DEEPSEEK_API_KEY_HERE', // User should be able to edit this
          functionCallingEnabled: false, // Default value
          createdAt: new Date().toISOString(),
          lastUpdated: new Date().toISOString(),
          userAgent: 'StoryForge/1.0 (Default)'
        },
      ];
    }
    return connections;
  }

  async saveAiConnection(userId: string, connection: AiConnection): Promise<void> {
    const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connection.id);
    await setDoc(connectionDocRef, {
      ...connection,
      createdAt: connection.createdAt || serverTimestamp(), // Set createdAt only on initial creation
      lastUpdated: serverTimestamp(), // Always update lastUpdated
    }, { merge: true });
    console.log(`AI Connection ${connection.id} saved for user ${userId}`);
  }

  async deleteAiConnection(userId: string, connectionId: string): Promise<void> {
    const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connectionId);
    await deleteDoc(connectionDocRef);
    console.log(`AI Connection ${connectionId} deleted for user ${userId}`);
  }
}

// Export a singleton instance of the repository.
export const gameRepository = new FirestoreGameRepository();
@@FILE: src/data/repositories/promptCardRepository.ts
// src/data/repositories/promptCardRepository.ts

import {
  collection,
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  query,
  where,
  getDocs,
  serverTimestamp,
  orderBy
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient'; // Import our Firestore instance
import { PromptCard } from '../../models/PromptCard';

/**
 * Defines the contract for PromptCard data persistence operations.
 * This interface can be implemented by different concrete repositories
 * (e.g., FirestorePromptCardRepository, MockPromptCardRepository)
 * to allow for easy swapping of data sources.
 */
export interface IPromptCardRepository {
  /**
   * Saves a new or updates an existing PromptCard.
   * If the card already has an ID, it will update the existing document.
   * If not, it assumes the card object passed already has an ID generated (e.g., by cardManager).
   * @param userId The ID of the user owning the card.
   * @param card The PromptCard object to save.
   * @returns A Promise that resolves when the card is successfully saved.
   */
  savePromptCard(userId: string, card: PromptCard): Promise<void>;

  /**
   * Retrieves a single PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to retrieve.
   * @returns A Promise that resolves with the PromptCard object or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a specific user, ordered by updatedAt descending.
   * @param userId The ID of the user owning the cards.
   * @returns A Promise that resolves with an array of PromptCard objects.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Deletes a PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to delete.
   * @returns A Promise that resolves when the card is successfully deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Imports a collection of PromptCards. This method will likely involve
   * generating new IDs/hashes and setting ownerId upon import.
   * The actual logic for generating IDs/hashes and setting ownerId should be in cardManager.ts,
   * this repository method merely handles the bulk persistence.
   * @param userId The ID of the user importing the cards.
   * @param cards The array of PromptCard objects to import.
   * @returns A Promise that resolves when all cards are imported.
   */
  importPromptCards(userId: string, cards: PromptCard[]): Promise<void>;
}

/**
 * Concrete implementation of IPromptCardRepository using Firestore.
 */
export class FirestorePromptCardRepository implements IPromptCardRepository {

  private getCollectionRef(userId: string) {
    // Path: users/{userId}/promptCards
    return collection(db, 'users', userId, 'promptCards');
  }

  async savePromptCard(userId: string, card: PromptCard): Promise<void> {
    if (!card.id) {
      // This case should ideally be prevented by logic in cardManager or wherever cards are created
      // as PromptCard should always have an ID before reaching the repository.
      throw new Error("PromptCard must have an ID to be saved.");
    }
    const cardDocRef = doc(this.getCollectionRef(userId), card.id);
    await setDoc(cardDocRef, {
      ...card,
      updatedAt: serverTimestamp() // Firestore special value for server timestamp
    }, { merge: true }); // Use merge: true to update existing fields and add new ones without overwriting entire doc
    // Note: createdAt should only be set on initial creation, not on every update.
    // We'll manage createdAt in cardManager.ts before passing to repository.
    console.log(`PromptCard ${card.id} saved for user ${userId}`);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    const cardSnap = await getDoc(cardDocRef);

    if (cardSnap.exists()) {
      // Firestore `data()` method returns `any`. We cast it to PromptCard.
      // Note: serverTimestamp() will be an object like { seconds: ..., nanoseconds: ... }
      // when retrieved, not an ISO string. We might need a conversion layer if UI strictly expects ISO string.
      // However, Firestore handles this transparently for objects if saving back.
      // For display, formatIsoDateForDisplay will handle it correctly if it's Date or Timestamp object.
      const data = cardSnap.data() as PromptCard;

      // Firestore's serverTimestamp() retrieves as a Timestamp object.
      // To ensure our PromptCard interface holds string (ISO 8601), we convert it here.
      // This is a common pattern: store one way, retrieve/convert to match app's type.
      return {
        ...data,
        createdAt: data.createdAt instanceof Object && 'toDate' in data.createdAt
          ? (data.createdAt as any).toDate().toISOString()
          : data.createdAt,
        updatedAt: data.updatedAt instanceof Object && 'toDate' in data.updatedAt
          ? (data.updatedAt as any).toDate().toISOString()
          : data.updatedAt,
      };
    } else {
      console.log(`No PromptCard found with ID: ${cardId} for user ${userId}`);
      return null;
    }
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    const q = query(
      this.getCollectionRef(userId),
      orderBy('updatedAt', 'desc') // Order by last updated, newest first
    );
    const querySnapshot = await getDocs(q);
    const cards: PromptCard[] = [];
    querySnapshot.forEach((doc) => {
      // Same conversion for Timestamp objects as in getPromptCard
      const data = doc.data() as PromptCard;
      cards.push({
        ...data,
        createdAt: data.createdAt instanceof Object && 'toDate' in data.createdAt
          ? (data.createdAt as any).toDate().toISOString()
          : data.createdAt,
        updatedAt: data.updatedAt instanceof Object && 'toDate' in data.updatedAt
          ? (data.updatedAt as any).toDate().toISOString()
          : data.updatedAt,
      });
    });
    console.log(`Retrieved ${cards.length} prompt cards for user ${userId}`);
    return cards;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    await deleteDoc(cardDocRef);
    console.log(`PromptCard ${cardId} deleted for user ${userId}`);
  }

  async importPromptCards(userId: string, cards: PromptCard[]): Promise<void> {
    // Firestore transactions/batch writes are ideal for bulk operations.
    // For simplicity in MVP, we'll do individual setDoc calls in parallel.
    // A more robust solution might use writeBatch for atomicity.
    const importPromises = cards.map(async (card) => {
      // Assume cardManager has already processed these cards for import (new IDs, hashes, ownerId).
      const cardDocRef = doc(this.getCollectionRef(userId), card.id);
      await setDoc(cardDocRef, {
        ...card,
        // Ensure timestamps are correctly handled for imported cards.
        // If the imported card already has createdAt/updatedAt, use them.
        // Otherwise, serverTimestamp() is an option, but for imports,
        // it's often preferred to preserve original times or set a specific import time.
        // For now, assume the card object already has string ISO timestamps set by cardManager.
      });
    });
    await Promise.all(importPromises);
    console.log(`Successfully imported ${cards.length} prompt cards for user ${userId}`);
  }
}

// Export a singleton instance of the repository for use throughout the application
export const promptCardRepository = new FirestorePromptCardRepository();
@@FILE: src/index.css
/* Reset and base styles */
* {
  box-sizing: border-box;
}

html, body, #root {
  margin: 0;
  padding: 0;
  height: 100%;
  background-color: #121212;
  color: #e0e0e0;
  font-family: Roboto, Arial, sans-serif;
}

/* Prevent default link styles from clashing */
a {
  color: inherit;
  text-decoration: none;
}

/* Smooth scrolling */
html {
  scroll-behavior: smooth;
}

@@FOLDER: src/logic
@@FILE: src/logic/aiClient.ts
// src/logic/aiClient.ts

import type { Message } from '../models/Message';
import type { AiSettings } from '../models/PromptCard';
import type { AiConnection } from '../models/AiConnection';

/**
 * Interface defining the contract for an AI client.
 */
export interface IAiClient {
  /**
   * Sends a completion request to the AI API.
   * @param connection The AiConnection details (URL, API key).
   * @param messages The array of messages forming the conversation context.
   * @param settings The AI settings for this specific call (temperature, etc.).
   * @returns A Promise that resolves with the raw text content of the AI's response (or stringified JSON if full response).
   */
  generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string>; // Changed return type to string to hold raw JSON or content

  /**
   * Tests an AI connection by making a minimal API call.
   * @param connection The AiConnection details to test.
   * @returns A Promise that resolves to true if the connection is successful, false otherwise.
   */
  testConnection(connection: AiConnection): Promise<boolean>;
}

/**
 * Concrete implementation of IAiClient using the browser's fetch API.
 * This directly replaces the Retrofit/OkHttp logic from AINarrator.kt.
 */
class AiClient implements IAiClient {
  async generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string> { // Now returns raw string, expecting JSON from most APIs
    if (!connection.apiToken || connection.apiToken === "YOUR_DEEPSEEK_API_KEY_HERE" || connection.apiToken === "MISSING_API_KEY") {
      throw new Error("AI API key is missing or not configured. Please set it in Settings.");
    }

    const apiUrl = new URL("chat/completions", connection.apiUrl).href;

    const requestBody = {
      model: connection.modelSlug,
      messages: messages,
      temperature: settings.temperature,
      top_p: settings.topP,
      max_tokens: settings.maxTokens,
      presence_penalty: settings.presencePenalty,
      frequency_penalty: settings.frequencyPenalty,
      stream: false, // For now, we're not streaming
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.apiToken}`,
          // User-Agent if provided
          ...(connection.userAgent && { 'User-Agent': connection.userAgent }),
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        console.error("AI API Error Response:", errorBody);
        throw new Error(`AI API request failed with status ${response.status}: ${response.statusText}. Details: ${errorBody.substring(0, 200)}...`);
      }

      const responseJson = await response.json();
      // Return the full stringified JSON response for gameSession to parse token usage etc.
      return JSON.stringify(responseJson);
    } catch (error: unknown) {
        let errorMessage = "An unknown error occurred";
        if (error instanceof Error) {
            errorMessage = error.message;
        }
        console.error("Failed to make AI API call:", error);
        throw new Error(`Network error or AI API failure: ${errorMessage}`);
    }
  }

  async testConnection(connection: AiConnection): Promise<boolean> {
    if (!connection.apiToken || connection.apiToken === "YOUR_DEEPSEEK_API_KEY_HERE" || connection.apiToken === "MISSING_API_KEY") {
      return false; // Cannot test without a valid key
    }

    const apiUrl = new URL("chat/completions", connection.apiUrl).href;
    const testMessage: Message[] = [{ role: 'user', content: 'hello' }];

    const requestBody = {
      model: connection.modelSlug,
      messages: testMessage,
      max_tokens: 10, // Smallest possible request
      temperature: 0.1,
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.apiToken}`,
          ...(connection.userAgent && { 'User-Agent': connection.userAgent }),
        },
        body: JSON.stringify(requestBody),
      });

      // A 2xx status code indicates success, even if the response content is minimal
      if (response.ok) {
        const responseJson = await response.json();
        // Optionally, check for expected content in the response.
        // For a basic test, just success status is enough.
        console.log("AI Connection Test Success:", responseJson);
        return true;
      } else {
        const errorBody = await response.text();
        console.warn(`AI Connection Test Failed (Status: ${response.status}):`, errorBody);
        return false;
      }
    } catch (error) {
      console.error("AI Connection Test Network Error:", error);
      return false;
    }
  }
}

// Export a singleton instance of the AI client.
export const aiClient = new AiClient();
@@FILE: src/logic/cardManager.ts
// src/logic/cardManager.ts

import { PromptCard, NewPromptCardData } from '../models/PromptCard';
import { generateUuid } from '../utils/uuid';
import { generateContentHash, getPromptCardContentForHash } from '../utils/hash';
import { promptCardRepository, IPromptCardRepository } from '../data/repositories/promptCardRepository';
import {
  defaultAiSettingsInCard,
  defaultStackInstructions,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../data/config/promptCardDefaults';

/**
 * Interface defining the contract for the Card Manager.
 * This can be useful for testing or providing different implementations (e.g., a mock manager).
 */
export interface ICardManager {
  /**
   * Creates a brand new PromptCard with default values for unspecified fields.
   * Generates new IDs and hash, sets creation/update timestamps.
   * @param userId The ID of the user creating the card.
   * @param data The initial data for the new card.
   * @returns A Promise resolving with the newly created PromptCard.
   */
  createNewPromptCard(userId: string, data: NewPromptCardData): Promise<PromptCard>;

  /**
   * Updates an existing PromptCard. Recalculates the content hash and updates the timestamp.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the card to update.
   * @param updates The partial PromptCard data to apply.
   * @returns A Promise resolving with the updated PromptCard or null if not found.
   */
  updatePromptCard(userId: string, cardId: string, updates: Partial<PromptCard>): Promise<PromptCard | null>;

  /**
   * Duplicates an existing PromptCard, creating a new card with a new ID
   * but linking it to the original's lineage (parentId, rootId).
   * @param userId The ID of the user performing the duplication.
   * @param sourceCardId The ID of the card to duplicate.
   * @returns A Promise resolving with the new, duplicated PromptCard or null if source not found.
   */
  duplicatePromptCard(userId: string, sourceCardId: string): Promise<PromptCard | null>;

  /**
   * Deletes a PromptCard.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the card to delete.
   * @returns A Promise resolving when the card is deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Retrieves a single PromptCard.
   * @param userId The ID of the user.
   * @param cardId The ID of the card.
   * @returns A Promise resolving with the PromptCard or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a user.
   * @param userId The ID of the user.
   * @returns A Promise resolving with an array of PromptCards.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Exports a single PromptCard for sharing/download.
   * This might involve stripping user-specific metadata like ownerId for public sharing.
   * For now, it simply returns the card, but can be extended.
   * @param userId The ID of the user exporting.
   * @param cardId The ID of the card to export.
   * @returns A Promise resolving with the PromptCard or null.
   */
  exportPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Imports PromptCards from a provided list (e.g., from a JSON file).
   * This involves generating new IDs, re-calculating hashes, setting ownerId,
   * and linking lineage appropriately.
   * @param userId The ID of the user importing.
   * @param importedCardsData An array of NewPromptCardData (or similar) from the import source.
   * @returns A Promise resolving with an array of the newly imported PromptCards.
   */
  importPromptCards(userId: string, importedCardsData: NewPromptCardData[]): Promise<PromptCard[]>;
}

/**
 * Concrete implementation of ICardManager.
 */
export class PromptCardManager implements ICardManager {
  constructor(private repo: IPromptCardRepository) {}

  private async buildPromptCard(userId: string, data: NewPromptCardData, existingCard?: PromptCard): Promise<PromptCard> {
    const now = new Date().toISOString();
    let cardId: string;
    let rootId: string;
    let parentId: string | null;
    let createdAt: string;

    if (existingCard) {
      // This path is for updates, or duplicating where we are basing off an existing structure
      cardId = existingCard.id;
      rootId = existingCard.rootId;
      parentId = existingCard.parentId; // Parent ID remains the same for updates
      createdAt = existingCard.createdAt;
    } else {
      // This path is for new creations or imports that need new IDs
      cardId = generateUuid();
      rootId = cardId; // For brand new cards, rootId is its own ID
      parentId = null; // No parent for brand new cards
      createdAt = now;
    }

    // Handle stackInstructions: if provided as string, parse it; otherwise use object or default.
    let parsedStackInstructions: StackInstructions;
    if (typeof data.stackInstructions === 'string') {
      try {
        parsedStackInstructions = JSON.parse(data.stackInstructions);
      } catch (e) {
        console.error("Error parsing stackInstructions string for new card, falling back to default:", e);
        parsedStackInstructions = defaultStackInstructions;
      }
    } else if (data.stackInstructions) {
      parsedStackInstructions = data.stackInstructions;
    } else {
      parsedStackInstructions = defaultStackInstructions;
    }

    // Construct the card with defaults applied where data is missing
    const tempCard: PromptCard = {
      id: cardId,
      rootId: rootId,
      parentId: parentId,
      ownerId: userId,
      createdAt: createdAt,
      updatedAt: now, // Always update timestamp on creation/modification
      title: data.title,
      prompt: data.prompt,
      description: data.description ?? null,
      firstTurnOnlyBlock: data.firstTurnOnlyBlock ?? DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: parsedStackInstructions,
      emitSkeleton: data.emitSkeleton ?? DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: data.worldStateInit ?? "",
      gameRules: data.gameRules ?? "",
      aiSettings: { ...defaultAiSettingsInCard, ...data.aiSettings },
      helperAiSettings: { ...defaultAiSettingsInCard, ...data.helperAiSettings },
      isHelperAiEnabled: data.isHelperAiEnabled ?? false, // NEW: Initialize with default false
      tags: data.tags ?? [],
      isExample: data.isExample ?? false,
      functionDefs: data.functionDefs ?? "",
      isPublic: data.isPublic ?? false, // Default to private for new user-created cards
      contentHash: '', // Will be calculated below
    };

    // Calculate content hash AFTER all content fields are finalized
    tempCard.contentHash = generateContentHash(getPromptCardContentForHash(tempCard));

    return tempCard;
  }

  async createNewPromptCard(userId: string, data: NewPromptCardData): Promise<PromptCard> {
    const newCard = await this.buildPromptCard(userId, data);
    await this.repo.savePromptCard(userId, newCard);
    return newCard;
  }

  async updatePromptCard(userId: string, cardId: string, updates: Partial<PromptCard>): Promise<PromptCard | null> {
    const existingCard = await this.repo.getPromptCard(userId, cardId);
    if (!existingCard) {
      return null;
    }

    // Apply updates
    const updatedCardData = { ...existingCard, ...updates };

    // Re-calculate hash based on potentially changed content fields
    const newContentHash = generateContentHash(getPromptCardContentForHash(updatedCardData));
    updatedCardData.contentHash = newContentHash;
    updatedCardData.updatedAt = new Date().toISOString(); // Update timestamp on modification

    await this.repo.savePromptCard(userId, updatedCardData);
    return updatedCardData;
  }

  async duplicatePromptCard(userId: string, sourceCardId: string): Promise<PromptCard | null> {
    const sourceCard = await this.repo.getPromptCard(userId, sourceCardId);
    if (!sourceCard) {
      console.warn(`Source card with ID ${sourceCardId} not found for duplication.`);
      return null;
    }

    const newId = generateUuid();
    const now = new Date().toISOString();

    const duplicatedCard: PromptCard = {
      ...sourceCard, // Copy all existing fields
      id: newId, // Assign new ID
      rootId: sourceCard.rootId, // Root remains the same
      parentId: sourceCard.id, // New parent is the source card
      ownerId: userId, // Ensure new owner is current user
      createdAt: now, // New creation timestamp for the duplicate
      updatedAt: now, // New update timestamp
      isExample: false, // Duplicates are user-owned, not examples
      isPublic: false, // Duplicates are private by default
      // isHelperAiEnabled will be copied correctly from sourceCard by the spread operator
    };

    // Recalculate hash for the duplicated card in case any content fields were implicitly changed
    // (e.g., if a previous source card had an older version of stack instructions that parsed differently).
    // Or just for robustness.
    duplicatedCard.contentHash = generateContentHash(getPromptCardContentForHash(duplicatedCard));

    await this.repo.savePromptCard(userId, duplicatedCard);
    console.log(`Card ${sourceCardId} duplicated to ${newId}`);
    return duplicatedCard;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    await this.repo.deletePromptCard(userId, cardId);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    return this.repo.getPromptCard(userId, cardId);
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    return this.repo.getAllPromptCards(userId);
  }

  async exportPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const card = await this.repo.getPromptCard(userId, cardId);
    if (card) {
      // For export, you might want to strip or transform sensitive/user-specific fields.
      // For MVP, we return the full card.
      // E.g., delete card.ownerId; // if it's meant for public template export
    }
    return card;
  }

  async importPromptCards(userId: string, importedCardsData: NewPromptCardData[]): Promise<PromptCard[]> {
    const importedAndProcessedCards: PromptCard[] = [];
    for (const data of importedCardsData) {
      // For imported cards, we generate a new UUID.
      // The parentId and rootId logic for imports needs careful consideration:
      // If the imported card explicitly defines a lineage, we might keep it.
      // If it's a "fresh" import, its rootId becomes its own new ID, parentId is null.
      // For now, let's treat all imports as new roots by default for simplicity,
      // and re-establish lineage if a more complex import format is defined later.
      // OR, if `NewPromptCardData` from import includes original IDs, we could preserve root/parent
      // For MVP, let's assume they are new root cards.
      const newCard = await this.buildPromptCard(userId, data);
      importedAndProcessedCards.push(newCard);
    }
    await this.repo.importPromptCards(userId, importedAndProcessedCards);
    console.log(`Imported ${importedAndProcessedCards.length} cards.`);
    return importedAndProcessedCards;
  }
}

// Export a singleton instance of the manager
export const promptCardManager = new PromptCardManager(promptCardRepository);
@@FILE: src/logic/deltaParser.ts
// src/logic/deltaParser.ts

import type { DeltaInstruction, DeltaMap } from '../models/DeltaInstruction.ts';
import type { DigestLine } from '../models/LogEntryElements.ts';
import type { ParsedNarrationOutput } from '../models/ParsedNarrationOutput.ts';

// Exported Marker constants
export const DELTA_MARKER = "@delta";
export const DIGEST_MARKER = "@digest";
export const SCENE_MARKER = "@scene";

/**
 * Extracts a JSON object from a list of lines, handling potential parsing errors.
 * @param lines The lines of text containing the JSON.
 * @returns A JSON object, or an empty object on error.
 */
function extractJsonObject(lines: string[]): Record<string, unknown> {
  const text = lines.join('\n').trim();
  if (!text) return {};
  try {
    const parsed = JSON.parse(text);
    return typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed) ? parsed : {};
  } catch (e: unknown) {
    console.error("Failed to parse JSON object:", e, "\nText:", text);
    return {};
  }
}

/**
 * Extracts a JSON array from a list of lines, handling potential parsing errors.
 * @param lines The lines of text containing the JSON array.
 * @returns A JSON array, or an empty array on error.
 */
function extractJsonArray(lines: string[]): unknown[] {
  const text = lines.join('\n').trim();
  if (!text) return [];
  try {
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : [];
  } catch (e: unknown) {
    console.error("Failed to parse JSON array:", e, "\nText:", text);
    return [];
  }
}

/**
 * Parses a key-value pair from the AI's delta JSON into a DeltaInstruction.
 * Corresponds to `DeltaInstruction.fromJsonElement` from the old project.
 * The raw key is expected to be in the format `+player.gold` or `=npcs.goblin.hp`.
 * @param rawKey The raw key from the JSON, e.g., "+player.gold".
 * @param value The JSON value associated with the key.
 * @returns A DeltaInstruction object or null if parsing fails.
 */
function parseSingleDelta(rawKey: string, value: unknown): DeltaInstruction | null {
  const op = rawKey.charAt(0);
  const path = rawKey.substring(1); // The rest of the key, e.g., "player.gold"

  switch (op) {
    case '+':
      return { op: 'add', key: path, value: value };
    case '=':
      return { op: 'assign', key: path, value: value };
    case '!':
      return { op: 'declare', key: path, value: value };
    case '-':
      return { op: 'delete', key: path };
    default:
      console.warn(`Invalid delta operation character '${op}' in key '${rawKey}'`);
      return null;
  }
}

/**
 * Parses the raw AI response string into a structured ParsedNarrationOutput object.
 * This function replicates the logic of `NarrationParser.extractJsonAndCleanNarration`.
 * @param rawAiOutput The full, raw string from the AI model.
 * @returns A ParsedNarrationOutput object.
 */
export function parseNarratorOutput(rawAiOutput: string): ParsedNarrationOutput {
  const lines = rawAiOutput.split('\n');

  const deltaIndex = lines.findIndex(line => line.trim() === DELTA_MARKER);
  const digestIndex = lines.findIndex(line => line.trim() === DIGEST_MARKER);
  const sceneIndex = lines.findIndex(line => line.trim() === SCENE_MARKER);

  const proseEndIndex = [deltaIndex, digestIndex, sceneIndex]
    .filter(index => index !== -1)
    .reduce((min, current) => Math.min(min, current), lines.length);

  const prose = lines.slice(0, proseEndIndex).join('\n').trim();

  const deltaLines = deltaIndex !== -1 ? lines.slice(deltaIndex + 1, digestIndex > deltaIndex ? digestIndex : (sceneIndex > deltaIndex ? sceneIndex : lines.length)) : [];
  const digestLinesRaw = digestIndex !== -1 ? lines.slice(digestIndex + 1, sceneIndex > digestIndex ? sceneIndex : lines.length) : [];
  const sceneLines = sceneIndex !== -1 ? lines.slice(sceneIndex + 1) : [];

  const deltaJson = extractJsonObject(deltaLines);
  const digestJson = extractJsonArray(digestLinesRaw);
  const sceneJson = extractJsonObject(sceneLines);

  // --- Parse Deltas ---
  const deltas: DeltaMap = {};
  for (const key in deltaJson) {
    const instruction = parseSingleDelta(key, deltaJson[key]);
    if (instruction) {
      deltas[key] = instruction;
    }
  }

  // --- Parse Digest Lines ---
  const digestLines: DigestLine[] = digestJson.map((item) => {
    const { text = '', importance } = item as { text?: string; importance?: number };
    const finalImportance = typeof importance === 'number' ? importance : 3;
    // Extract tags from text using regex, as in original NarrationParser
    const tagPattern = /[#@$][a-zA-Z0-9_]+/g;
    const tags = text.match(tagPattern) || [];
    return { text, importance: finalImportance, tags };
  }).filter(line => line.text); // Filter out empty lines

  return {
    prose,
    deltas,
    digestLines,
    scene: sceneJson,
  };
}
@@FILE: src/logic/gameSession.ts
// src/logic/gameSession.ts

// Updated import paths for interfaces as well for clarity.
import { PromptCard } from '../models/PromptCard';
import { GameSnapshot } from '../models/GameSnapshot';
import { LogEntry } from '../models/LogEntry';
import { GameState, SceneState } from '../models/GameState';
import { Message } from '../models/Message';
import { DeltaInstruction, DeltaMap } from '../models/DeltaInstruction';
import { AiSettings } from '../models/PromptCard'; // For DummyAiClient
import { AiConnection } from '../models/AiConnection'; // For DummyAiClient

import { IPromptBuilder } from './promptBuilder';
import { IAiClient } from './aiClient';
import { ILogManager } from './logManager';
import { IPromptCardRepository } from '../data/repositories/promptCardRepository';
import { IGameRepository } from '../data/repositories/gameRepository';
import { generateUuid } from '../utils/uuid'; // Import generateUuid
import { formatIsoDateForDisplay } from '../utils/formatDate'; // Import for consistent date formatting in title
import { IPromptCardRepository } from './../data/repositories/promptCardRepository'; // Ensure this import is correct
import { IGameRepository } from './../data/repositories/gameRepository'; // Import IGameRepository

// Define a simple DummyAiClient for testing and dev
class DummyAiClient implements IAiClient {
  async generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string> {
    console.log("Dummy Narrator: Simulating AI response...");
    const lastUserMessage = messages.find(m => m.role === 'user')?.content || 'No user input.';
    const dummyResponse = {
      choices: [{
        message: {
          content: `@delta
{"=player.hp": 99, "+player.gold": 1}
@digest
[
  {"text": "A dummy event occurred.", "importance": 3},
  {"text": "Your input was: '${lastUserMessage}'.", "importance": 1}
]
@scene
{"location": "dummy_location", "present": []}

The dummy narrator responds to your action: "${lastUserMessage}". A gentle breeze rustles through the imaginary trees, and you feel slightly less real. Your health is now 99, and you found 1 gold coin.`
        }
      }],
      usage: {
        prompt_tokens: 10,
        completion_tokens: 50,
        total_tokens: 60,
      }
    };
    return Promise.resolve(JSON.stringify(dummyResponse)); // Return as stringified JSON
  }

  async testConnection(connection: AiConnection): Promise<boolean> {
    return Promise.resolve(true); // Dummy always passes test
  }
}

/**
 * Interface defining the contract for the Game Session manager.
 * Orchestrates the turn flow, handles player actions, calls AI, updates logs & saves.
 */
export interface IGameSession {
  /**
   * Initializes a new game session or loads an existing one.
   * @param userId The ID of the current user.
   * @param cardId The ID of the PromptCard to use for the game.
   * @param existingSnapshotId Optional ID of an existing game snapshot to load.
   * @returns A Promise resolving with the initialized GameSession instance.
   */
  initializeGame(userId: string, cardId: string, existingSnapshotId?: string, useDummyNarrator?: boolean): Promise<void>;

  /**
   * Processes a player's action, generates an AI response, and updates the game state.
   * @param action The player's input string.
   * @param useDummyNarrator Flag to indicate if dummy AI should be used.
   * @returns A Promise resolving with the AI's response and any state changes.
   */
  processPlayerAction(action: string, useDummyNarrator: boolean): Promise<{ aiProse: string; newLogEntries: LogEntry[]; updatedSnapshot: GameSnapshot }>;

  /**
   * Retrieves the current game state.
   * @returns The current GameSnapshot or null if not initialized.
   */
  getCurrentGameSnapshot(): GameSnapshot | null;

  /**
   * Saves the current game state.
   * @param snapshot The GameSnapshot object to save. // MODIFIED: Add parameter
   * @returns A Promise resolving when the game is saved.
   */
  saveGame(snapshot: GameSnapshot): Promise<void>;

  /**
   * Loads a game snapshot.
   * @param snapshotId The ID of the snapshot to load.
   * @returns A Promise resolving when the game is loaded.
   */
  loadGame(userId: string, snapshotId: string): Promise<void>;

  /**
   * Provides access to the current PromptCard for UI purposes.
   */
  getCurrentPromptCard(): PromptCard | null;

  /**
   * Provides access to the current GameState for UI purposes.
   */
  getCurrentGameState(): GameState | null;

  /**
   * Provides access to the current LogEntries for UI purposes.
   */
  getGameLogs(): LogEntry[];

  // NEW: Expose gameRepo for use by stores that need to query game data outside of turn processing.
  gameRepo: IGameRepository;
}

/**
 * Concrete implementation of IGameSession.
 */
export class GameSession implements IGameSession { // Export the class
  private currentUserId: string | null = null;
  private currentSnapshot: GameSnapshot | null = null;
  private currentPromptCard: PromptCard | null = null;
  private realAiClient: IAiClient;
  private dummyAiClient: IAiClient = new DummyAiClient();

  // Make gameRepo a public property on the class to satisfy the interface
  public gameRepo: IGameRepository;

  constructor(
    private cardRepo: IPromptCardRepository,
    gameRepoInstance: IGameRepository, // Accept the gameRepo instance
    private builder: IPromptBuilder,
    aiClientInstance: IAiClient,
    private logManager: ILogManager,
  ) {
    this.gameRepo = gameRepoInstance; // Assign the injected instance to the public property
    this.realAiClient = aiClientInstance;
  }

  public async initializeGame(userId: string, cardId: string, existingSnapshotId?: string, useDummyNarrator: boolean = false): Promise<void> {
    console.log(`GameSession: Initializing game. User: ${userId}, Card: ${cardId}, Snapshot: ${existingSnapshotId}`);
    this.currentUserId = userId;

    if (existingSnapshotId) {
      // If loading an existing game, just load it. The turn is already processed.
      await this.loadGame(userId, existingSnapshotId);
      return;
    }

    // Logic for creating a NEW game
    const card = await this.cardRepo.getPromptCard(userId, cardId);
    if (!card) {
      throw new Error(`PromptCard with ID ${cardId} not found for user ${userId}.`);
    }
    this.currentPromptCard = card;

    const now = new Date().toISOString();
    const newSnapshotId = generateUuid();

    // Initialize GameState from PromptCard
    let initialWorldState = {};
    try {
      if (card.worldStateInit) {
        initialWorldState = JSON.parse(card.worldStateInit);
      }
    } catch (e) {
      console.error("Failed to parse worldStateInit JSON:", e);
    }

    const firstTurnProse = card.firstTurnOnlyBlock || "The story begins...";

    const initialGameState: GameState = {
      narration: firstTurnProse, // The initial scene text
      worldState: initialWorldState,
      scene: { location: null, present: [] },
    };

    const initialSnapshot: GameSnapshot = {
      id: newSnapshotId,
      userId: userId,
      promptCardId: cardId,
      title: `Game with ${card.title} - ${formatIsoDateForDisplay(now)}`,
      createdAt: now,
      updatedAt: now,
      currentTurn: 0, // This is the start of turn 0
      gameState: initialGameState,
      conversationHistory: [{ role: 'assistant', content: firstTurnProse }],
      logs: [],
      worldStatePinnedKeys: [],
    };

    this.currentSnapshot = initialSnapshot;
    await this.saveGame(this.currentSnapshot);
    console.log(`GameSession: New game initialized with ID ${newSnapshotId}. Ready for narrator's first response.`);
  }

  public async processPlayerAction(action: string, useDummyNarrator: boolean): Promise<{ aiProse: string; newLogEntries: LogEntry[]; updatedSnapshot: GameSnapshot; }> {
    if (!this.currentSnapshot || !this.currentUserId || !this.currentPromptCard) {
      throw new Error("Cannot process player action: Game not initialized correctly.");
    }
    console.log(`GameSession: Processing player action for turn ${this.currentSnapshot.currentTurn}...`);

    const snapshot = this.currentSnapshot;
    const card = this.currentPromptCard;
    const userId = this.currentUserId;
    const turnNumber = snapshot.currentTurn;

    // 1. Add player action to conversation history
    snapshot.conversationHistory.push({ role: 'user', content: action });

    // 2. Build the prompt for this turn
    const messagesToSend = this.builder.buildEveryTurnPrompt(
        card,
        snapshot.gameState,
        snapshot.logs,
        snapshot.conversationHistory,
        action,
        turnNumber
    );
    const contextSnapshotForLog = JSON.stringify(messagesToSend, null, 2);

    // 3. Execute AI call (similar to processFirstTurn)
    let aiRawOutput: string = "";
    let aiResponseLatencyMs: number | null = null;
    let aiModelSlugUsed: string = "";
    let aiApiUrl: string | null = null;
    let aiApiRequestBody: string | null = null;
    let aiApiResponseBody: string | null = null;
    let aiTokenUsage: any = null;

    try {
        const activeAiClient = useDummyNarrator ? this.dummyAiClient : this.realAiClient;
        let connection: AiConnection | undefined;

        if (!useDummyNarrator) {
            const connections = await this.gameRepo.getAiConnections(userId);
            connection = connections.find(c => c.id === card.aiSettings.selectedConnectionId);
            if (!connection) throw new Error(`AI connection ${card.aiSettings.selectedConnectionId} not found.`);
            aiModelSlugUsed = connection.modelSlug;
            aiApiUrl = new URL("chat/completions", connection.apiUrl).href;
        } else {
            connection = { id: 'dummy', displayName: 'Dummy Narrator', modelName: 'Dummy', modelSlug: 'dummy-narrator', apiUrl: 'n/a', apiToken: 'n/a', functionCallingEnabled: false, createdAt: '', lastUpdated: '' };
            aiModelSlugUsed = 'dummy-narrator';
            aiApiUrl = 'local-dummy-url';
        }
        
        aiApiRequestBody = JSON.stringify({ model: connection.modelSlug, messages: "..." }, null, 2); // Simplified request body for log
        
        const startTime = performance.now();
        const fullAiResponse = await activeAiClient.generateCompletion(connection, messagesToSend, card.aiSettings);
        aiResponseLatencyMs = Math.round(performance.now() - startTime);
        
        let parsedAiJson;
        try {
            parsedAiJson = JSON.parse(fullAiResponse);
            aiRawOutput = parsedAiJson.choices?.[0]?.message?.content?.trim() || "";
            aiTokenUsage = parsedAiJson.usage ? { inputTokens: parsedAiJson.usage.prompt_tokens || 0, outputTokens: parsedAiJson.usage.completion_tokens || 0, totalTokens: parsedAiJson.usage.total_tokens || 0 } : null;
            aiApiResponseBody = fullAiResponse;
        } catch (parseError) {
            aiRawOutput = fullAiResponse;
            aiApiResponseBody = fullAiResponse;
        }

    } catch (e: any) {
        console.error("Player action AI call failed:", e);
        aiRawOutput = `AI system error during turn ${turnNumber}: ${e.message}. The story cannot continue. Please check your AI settings and try again.`;
    }

    // 4. Process AI output
    const parsedAiOutput = this.builder.parseNarratorOutput(aiRawOutput);

    // 5. Update Game State
    snapshot.conversationHistory.push({ role: 'assistant', content: parsedAiOutput.prose });
    snapshot.gameState.narration = parsedAiOutput.prose;
    if (parsedAiOutput.deltas) {
      this.applyDeltasToGameState(snapshot.gameState, parsedAiOutput.deltas);
    }
    this.updateSceneState(snapshot.gameState.scene, parsedAiOutput.scene, parsedAiOutput.deltas, snapshot.gameState.worldState);

    // 6. Create LogEntry
    const newLogEntry = this.logManager.assembleTurnLogEntry({
      turnNumber: turnNumber,
      userInput: action,
      rawNarratorOutput: aiRawOutput,
      parsedOutput: parsedAiOutput,
      contextSnapshot: contextSnapshotForLog,
      tokenUsage: aiTokenUsage,
      aiSettings: card.aiSettings,
      apiRequestBody: aiApiRequestBody,
      apiResponseBody: aiApiResponseBody,
      apiUrl: aiApiUrl,
      latencyMs: aiResponseLatencyMs,
      modelSlugUsed: aiModelSlugUsed,
    });
    snapshot.logs.push(newLogEntry);

    // 7. Update snapshot metadata
    snapshot.currentTurn = turnNumber + 1; // Increment the turn counter
    snapshot.updatedAt = new Date().toISOString();

    // 8. Save the updated snapshot
    await this.saveGame(snapshot);

    // 9. Return results to the store
    return {
        aiProse: parsedAiOutput.prose,
        newLogEntries: snapshot.logs,
        updatedSnapshot: snapshot,
    };
}


  public async processFirstTurn(useDummyNarrator: boolean): Promise<void> {
    if (!this.currentSnapshot || !this.currentUserId || !this.currentPromptCard) {
      throw new Error("Cannot process first turn: Game not initialized correctly.");
    }
    console.log("GameSession: Processing first turn (Turn 0)...");

    const snapshot = this.currentSnapshot;
    const card = this.currentPromptCard;
    const userId = this.currentUserId;
    const turnNumber = 0;
    const userInputForLog = card.firstTurnOnlyBlock || "Begin the story."; // The "input" for this turn.

    // 1. Build the special first-turn prompt
    const messagesToSend = this.builder.buildFirstTurnPrompt(card);
    const contextSnapshotForLog = JSON.stringify(messagesToSend, null, 2);

    // 2. Execute AI call and get response (logic is similar to processPlayerAction)
    let aiRawOutput: string = "";
    let aiResponseLatencyMs: number | null = null;
    let aiModelSlugUsed: string = "";
    let aiApiUrl: string | null = null;
    let aiApiRequestBody: string | null = JSON.stringify({ model: card.aiSettings.selectedConnectionId, messages: "..." }, null, 2); // Placeholder for request body
    let aiApiResponseBody: string | null = null; // Placeholder for response body
    let aiTokenUsage: any = null;

    try {
      const activeAiClient = useDummyNarrator ? this.dummyAiClient : this.realAiClient;

      let connection: AiConnection | undefined;
      if (!useDummyNarrator) {
        const connections = await this.gameRepo.getAiConnections(userId);
        connection = connections.find(c => c.id === card.aiSettings.selectedConnectionId);
        if (!connection) {
          throw new Error(`AI connection ${card.aiSettings.selectedConnectionId} not found.`);
        }
        aiModelSlugUsed = connection.modelSlug;
        aiApiUrl = new URL("chat/completions", connection.apiUrl).href;
      } else {
        connection = {
          id: 'dummy', displayName: 'Dummy Narrator', modelName: 'Dummy', modelSlug: 'dummy-narrator',
          apiUrl: 'n/a', apiToken: 'n/a', functionCallingEnabled: false, createdAt: '', lastUpdated: ''
        };
        aiModelSlugUsed = 'dummy-narrator';
        aiApiUrl = 'local-dummy-url';
      }

      const startTime = performance.now();
      const fullAiResponse = await activeAiClient.generateCompletion(connection, messagesToSend, card.aiSettings);
      aiResponseLatencyMs = Math.round(performance.now() - startTime);

      let parsedAiJson;
      try {
        parsedAiJson = JSON.parse(fullAiResponse);
        aiRawOutput = parsedAiJson.choices?.[0]?.message?.content?.trim() || "";
        aiTokenUsage = parsedAiJson.usage ? {
          inputTokens: parsedAiJson.usage.prompt_tokens || 0,
          outputTokens: parsedAiJson.usage.completion_tokens || 0,
          totalTokens: parsedAiJson.usage.total_tokens || 0,
        } : null;
        aiApiResponseBody = fullAiResponse; // Assign the full response to the variable
      } catch (parseError) {
        aiRawOutput = fullAiResponse;
        aiApiResponseBody = fullAiResponse; // Assign the full response if parsing fails
      }
    } catch (e: any) {
      console.error("First turn AI call failed:", e);
      aiRawOutput = `AI system error during initialization: ${e.message}. The story cannot begin. Please check your AI settings and try again.`;
      // The error will be logged and shown to the user.
    }

    // 3. Process AI output
    const parsedAiOutput = this.builder.parseNarratorOutput(aiRawOutput);

    // 4. Update Game State
    snapshot.conversationHistory.push({ role: 'assistant', content: parsedAiOutput.prose });
    snapshot.gameState.narration = parsedAiOutput.prose;

    if (parsedAiOutput.deltas) {
      this.applyDeltasToGameState(snapshot.gameState, parsedAiOutput.deltas);
    }
    this.updateSceneState(snapshot.gameState.scene, parsedAiOutput.scene, parsedAiOutput.deltas, snapshot.gameState.worldState);

    // 5. Create LogEntry
    const newLogEntry = this.logManager.assembleTurnLogEntry({
      turnNumber: turnNumber,
      userInput: userInputForLog,
      rawNarratorOutput: aiRawOutput,
      parsedOutput: parsedAiOutput,
      contextSnapshot: contextSnapshotForLog,
      tokenUsage: aiTokenUsage,
      aiSettings: card.aiSettings,
      apiRequestBody: aiApiRequestBody, // Corrected variable name
      apiResponseBody: aiApiResponseBody, // Corrected variable name
      apiUrl: aiApiUrl,
      latencyMs: aiResponseLatencyMs,
      modelSlugUsed: aiModelSlugUsed,
    });
    snapshot.logs.push(newLogEntry);

    // 6. Update snapshot metadata
    snapshot.currentTurn = turnNumber + 1;
    snapshot.updatedAt = new Date().toISOString();

    // 7. Save the fully initialized snapshot
    await this.saveGame(snapshot);
    console.log("GameSession: First turn processed and saved. Snapshot ID:", snapshot.id);
  }

  
  public async loadGame(userId: string, snapshotId: string): Promise<void> {
    console.log(`GameSession: Loading game snapshot ID ${snapshotId} for user ${userId}.`);

    // 1. Fetch the game snapshot from the repository.
    const snapshot = await this.gameRepo.getGameSnapshot(userId, snapshotId);
    if (!snapshot) {
      throw new Error(`Game snapshot with ID ${snapshotId} not found for user ${userId}.`);
    }

    // 2. Fetch the associated prompt card.
    const card = await this.cardRepo.getPromptCard(userId, snapshot.promptCardId);
    if (!card) {
      throw new Error(`Associated PromptCard with ID ${snapshot.promptCardId} not found for snapshot ${snapshotId}.`);
    }

    // 3. Set the internal state of the session.
    this.currentUserId = userId;
    this.currentSnapshot = snapshot;
    this.currentPromptCard = card;

    console.log(`GameSession: Successfully loaded game "${snapshot.title}" and card "${card.title}".`);
  }

  /**
 * Retrieves the current game state snapshot held by the session.
 * @returns The current GameSnapshot or null if not initialized.
 */
public getCurrentGameSnapshot(): GameSnapshot | null {
    return this.currentSnapshot;
}


  /**
 * Saves the current game state to the repository.
 * @param snapshot The GameSnapshot object to save.
 * @returns A Promise resolving when the game is saved.
 */
public async saveGame(snapshot: GameSnapshot): Promise<void> {
    if (!this.currentUserId) {
        console.error("GameSession: Cannot save game because userId is not set.");
        throw new Error("User is not initialized in the game session.");
    }
    if (!snapshot) {
        console.warn("GameSession: saveGame was called with an empty snapshot.");
        return;
    }

    try {
        // Use the game repository to persist the snapshot
        await this.gameRepo.saveGameSnapshot(this.currentUserId, snapshot);
        console.log(`GameSession: Successfully saved snapshot ${snapshot.id}.`);
    } catch (e) {
        console.error(`GameSession: An error occurred while saving snapshot ${snapshot.id}.`, e);
        // Re-throw the error to be caught by the caller (e.g., the UI layer)
        throw e;
    }
}



  /**
   * Applies DeltaInstruction objects to the game's worldState.
   * This is a direct translation and simplification of GameState.applyDeltas.
   * Assumes 'player' fields like hp/gold/narration are now part of worldState.
   * This logic now lives here, or could be a private helper in deltaParser if desired.
   */
  private applyDeltasToGameState(gameState: GameState, deltas: DeltaMap): void {
    const updatedWorld = { ...gameState.worldState }; // Create a mutable copy of worldState
    console.log('GameSession: Applying deltas to worldState. Initial state:', JSON.stringify(updatedWorld));

    for (const fullKey in deltas) {
      const instruction = deltas[fullKey];
      const parts = instruction.key.split('.'); // instruction.key now holds the path like "player.hp"

      // Traverse or create path
      let currentLevel: Record<string, any> = updatedWorld;
      for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!currentLevel[part] || typeof currentLevel[part] !== 'object' || Array.isArray(currentLevel[part])) {
          currentLevel[part] = {}; // Create if non-existent or not an object
          console.log(`GameSession: Created nested object at path: ${parts.slice(0, i + 1).join('.')}`);
        }
        currentLevel = currentLevel[part];
      }

      const lastPart = parts[parts.length - 1];

      switch (instruction.op) {
        case 'add':
          // Assuming 'add' is primarily for numbers or arrays
          const prevAddValue = typeof currentLevel[lastPart] === 'number' ? currentLevel[lastPart] : 0;
          const addValue = typeof instruction.value === 'number' ? instruction.value : 0;
          currentLevel[lastPart] = prevAddValue + addValue;
          console.log(`GameSession: Delta ADD: ${instruction.key} from ${prevAddValue} to ${currentLevel[lastPart]}`);
          break;
        case 'assign':
          currentLevel[lastPart] = instruction.value;
          console.log(`GameSession: Delta ASSIGN: ${instruction.key} = ${JSON.stringify(instruction.value)}`);
          break;
        case 'declare':
          if (!(lastPart in currentLevel)) { // Only declare if not already present
            currentLevel[lastPart] = instruction.value;
            console.log(`GameSession: Delta DECLARE: ${instruction.key} = ${JSON.stringify(instruction.value)} (new)`);
          } else {
            console.log(`GameSession: Delta DECLARE: ${instruction.key} already exists, not declared.`);
          }
          break;
        case 'delete':
          delete currentLevel[lastPart];
          console.log(`GameSession: Delta DELETE: ${instruction.key}`);
          break;
      }
    }
    gameState.worldState = updatedWorld; // Assign the updated worldState back
    console.log('GameSession: Deltas applied. Final worldState:', JSON.stringify(gameState.worldState));
  }

  /**
   * Updates the SceneState based on parsed AI output or infers from deltas.
   * Replicates logic from SceneManager.
   */
  private updateSceneState(currentScene: SceneState, parsedScene: Record<string, any> | null | undefined, deltas: DeltaMap, worldState: Record<string, any>): void {
    console.log('GameSession: Updating scene state. Current:', currentScene);
    let newLocation: string | null = currentScene.location;
    let newPresent: string[] = [...currentScene.present];

    // Prioritize explicit @scene block
    if (parsedScene) {
      if (parsedScene.location !== undefined) {
        newLocation = typeof parsedScene.location === 'string' ? parsedScene.location : null;
        console.log(`GameSession: Scene updated by @scene block: location = ${newLocation}`);
      }
      if (Array.isArray(parsedScene.present)) {
        newPresent = parsedScene.present.filter((item: any) => typeof item === 'string');
        console.log(`GameSession: Scene updated by @scene block: present = ${JSON.stringify(newPresent)}`);
      }
    } else {
      // Fallback: Infer from deltas if scene was not explicitly provided by AI
      // Only infer if current scene is empty or not yet set
      if ((!newLocation && newPresent.length === 0) && deltas) {
        console.log('GameSession: Inferring scene from deltas (no explicit @scene block found).');
        const inferredPresent = new Set<string>();
        for (const fullKey in deltas) {
          const instruction = deltas[fullKey];
          if (instruction.op === 'declare') { // Only 'declare' deltas suggest new entities
            const parts = instruction.key.split('.');
            if (parts.length >= 2) {
              const category = parts[0];
              const entity = parts[1];
              // Check if the declared value has a 'tag' property indicative of character/location
              const valueObj = instruction.value as Record<string, any>;
              if (valueObj && (valueObj.tag === "character" || valueObj.tag === "location")) {
                inferredPresent.add(`${category}.${entity}`);
                console.log(`GameSession: Inferred present entity from delta: ${category}.${entity}`);
              }
            }
            if (instruction.key === "world.location" && typeof instruction.value === 'string') {
              newLocation = instruction.value;
              console.log(`GameSession: Inferred location from delta: ${newLocation}`);
            }
          }
        }
        newPresent = Array.from(inferredPresent);
      }
    }

    currentScene.location = newLocation;
    currentScene.present = newPresent;
    console.log('GameSession: Final scene state after update:', currentScene);
  }
}

// Export the GameSession class to be instantiated in main.tsx
@@FILE: src/logic/logManager.ts
// src/logic/logManager.ts

import type{ LogEntry } from '../models/LogEntry';
import type{ ParsedNarrationOutput } from '../models/ParsedNarrationOutput';
import type{ AiSettings, PromptCard } from '../models/PromptCard'; // For AI settings from the card
import type{ DeltaInstruction, DeltaMap } from '../models/DeltaInstruction'; // For the DeltaMap type
import type{ DigestLine, TokenSummary, LogErrorFlag } from '../models/LogEntryElements'; // For related types
import { DELTA_MARKER } from './deltaParser'; // Import DELTA_MARKER

/**
 * Interface defining the contract for the Log Manager.
 */
export interface ILogManager {
 /**
  * Assembles a complete LogEntry for a single turn of the game.
  * This centralizes the logic from TurnLogAssembler and DigestManager.addParsedLines.
  * @param params An object containing all necessary data for the log entry.
  * @returns A fully constructed LogEntry object.
  */
 assembleTurnLogEntry(params: {
  turnNumber: number;
  userInput: string;
  rawNarratorOutput: string;
  parsedOutput: ParsedNarrationOutput; // Output from deltaParser.ts
  contextSnapshot: string; // The full prompt string sent to AI
  tokenUsage: TokenSummary | null;
  aiSettings: AiSettings; // The AI settings used for this turn
  apiRequestBody: string | null;
  apiResponseBody: string | null;
  apiUrl: string | null;
  latencyMs: number | null;
  modelSlugUsed: string;
 }): LogEntry;

 /**
  * Infers digest lines from deltas if no explicit digest was provided by the AI.
  * Replicates logic from DigestManager.addParsedLines.
  * @param deltas The map of DeltaInstruction objects.
  * @param prose Optional: the prose of the turn, for extracting first line as digest.
  * @returns An array of inferred DigestLine objects.
  */
 inferDigestLinesFromDeltas(deltas: DeltaMap, prose?: string): DigestLine[];
}

/**
 * Concrete implementation of ILogManager.
 */
class LogManager implements ILogManager {

 inferDigestLinesFromDeltas(deltas: DeltaMap, prose?: string): DigestLine[] {
  const inferredDigests: DigestLine[] = [];

  if (Object.keys(deltas).length === 0) {
   return inferredDigests;
  }

  for (const rawKey in deltas) {
   const instruction = deltas[rawKey];
   let score = 1; // Default low importance

   // Logic from DigestManager.addParsedLines to infer importance
   if (rawKey.startsWith("player.")) {
    score = 5; // Player-related changes are critical
   } else if (rawKey.startsWith("world.")) {
    score = 5; // World-related changes are critical
   } else if (rawKey.includes(".flags.")) {
    score = 4;
   } else if (rawKey.includes(".status")) {
    score = 3;
   } else if (rawKey.startsWith("+") || rawKey.startsWith("!")) {
    score = 2; // Add or Declare operations
   }

   // Logic from DeltaInstruction.toLogValue() for summary text
   let summaryText = `Unknown delta operation: ${rawKey}`;
   if (instruction.op === 'assign') {
    summaryText = `Set ${instruction.key} = ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'add') {
    summaryText = `Added to ${instruction.key}: ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'declare') {
    // Inferred tag logic, similar to DigestManager
    let taggableKey = instruction.key;
    const pathParts = instruction.key.split(".");
    if (pathParts.length >= 2) {
      const category = pathParts[0];
      const entity = pathParts[1];
      // Infer if this is a character or location declaration for a summary
      const valueAsObject = instruction.value as Record<string, any>;
      if (valueAsObject && (valueAsObject.tag === "character" || valueAsObject.tag === "location")) {
        taggableKey = (valueAsObject.tag === "character" ? "#" : "@") + entity;
      }
    }
    summaryText = `Declared ${taggableKey} as ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'delete') {
    summaryText = `Removed ${instruction.key}`;
   }

  const tags = this.extractTags(summaryText); // Extract tags from the generated summary
    // MODIFIED: Use `importance: score` to match the DigestLine model
   inferredDigests.push({ text: summaryText, importance: score, tags });
  }

  // Optional prose line extraction from DigestManager.addParsedLines
  if (prose && prose.trim().length > 10) {
   const firstLine = prose.trim().split(/[.!?\n]/).find(line => line.trim().length > 10)?.trim();
   if (firstLine) {
    const tags = this.extractTags(firstLine);
      // MODIFIED: Use `importance: 3`
    inferredDigests.push({ text: firstLine, importance: 3, tags });
   }
  }

  // Assign consistent turn number AFTER all are collected
  // MODIFIED: Remove turn property, as it's not in the DigestLine model. It's part of the parent LogEntry.
  return inferredDigests;
}

 private extractTags(text: string): string[] {
  const tagPattern = /[#@$][a-zA-Z0-9_]+/g; // Global flag to find all matches
  const matches = text.match(tagPattern);
  return matches || [];
 }

 assembleTurnLogEntry(params: {
  turnNumber: number;
  userInput: string;
  rawNarratorOutput: string;
  parsedOutput: ParsedNarrationOutput;
  contextSnapshot: string;
  tokenUsage: TokenSummary | null;
  aiSettings: AiSettings;
  apiRequestBody: string | null;
  apiResponseBody: string | null;
  apiUrl: string | null;
  latencyMs: number | null;
  modelSlugUsed: string;
 }): LogEntry {
  const now = new Date().toISOString();
  const {
   turnNumber, userInput, rawNarratorOutput, parsedOutput,
   contextSnapshot, tokenUsage, aiSettings, apiRequestBody,
   apiResponseBody, apiUrl, latencyMs, modelSlugUsed
  } = params;

  let digestLines: DigestLine[] = parsedOutput.digestLines || [];
  if (digestLines.length === 0 && parsedOutput.deltas) {
   // If AI didn't provide digest, infer from deltas
   digestLines = this.inferDigestLinesFromDeltas(parsedOutput.deltas, parsedOutput.prose);
  }
  // Ensure correct turn number for inferred digests
  digestLines = digestLines.map(d => ({ ...d, turn: turnNumber }));


  const errorFlags: LogErrorFlag[] = [];
  // Basic error checking (can be expanded)
  if (!parsedOutput.prose) {
   errorFlags.push('MISSING_PROSE');
  }
  // Now using DELTA_MARKER imported from deltaParser
  if (parsedOutput.deltas && Object.keys(parsedOutput.deltas).length === 0 && rawNarratorOutput.includes(DELTA_MARKER)) {
    // If the delta marker was present but no deltas were parsed
    errorFlags.push('INVALID_JSON_DELTA');
  }
  if (!tokenUsage || tokenUsage.totalTokens <= 0) {
   errorFlags.push('INVALID_TOKEN_USAGE');
  }
  // Add more validation based on your `LogErrorFlag` enum/sealed class
  // e.g., if (rawNarratorOutput.length < 50) { errorFlags.push('AI_RESPONSE_TOO_SHORT'); }


  return {
   turnNumber: turnNumber,
   timestamp: now,
   userInput: userInput,
   narratorOutput: rawNarratorOutput,
   prose: parsedOutput.prose, // ADDED: Save the clean prose here
   digestLines: digestLines, // Now an array
   deltas: parsedOutput.deltas,
   contextSnapshot: contextSnapshot,
   tokenUsage: tokenUsage,
   apiRequestBody: apiRequestBody,
   apiResponseBody: apiResponseBody,
   apiUrl: apiUrl,
   latencyMs: latencyMs,
   aiSettings: aiSettings,
   errorFlags: errorFlags,
   modelSlugUsed: modelSlugUsed,
  };
 }
}

export const logManager = new LogManager();
@@FILE: src/logic/promptBuilder.ts

// src/logic/promptBuilder.ts

import type { PromptCard, AiSettings } from '../models/PromptCard';
import type { GameState, SceneState } from '../models/GameState';
import type { LogEntry } from '../models/LogEntry';
import type { Message } from '../models/Message';
import { StackMode, FilterMode, StackInstructions, EmissionRule, ProsePolicy, DigestFilterPolicy } from '../models/StackInstructions';
import type { DeltaMap, DeltaInstruction } from '../models/DeltaInstruction';
import type { DigestLine } from '../models/LogEntryElements';
import type { ParsedNarrationOutput } from '../models/ParsedNarrationOutput';

// Marker constants for parsing AI output
const DELTA_MARKER = "@delta";
const DIGEST_MARKER = "@digest";
const SCENE_MARKER = "@scene";

// ... (Interface definition remains the same) ...

export class PromptBuilder implements IPromptBuilder {

    // ... (buildFirstTurnPrompt and buildEveryTurnPrompt remain the same) ...

    private extractTags(text: string): string[] {
        const tagPattern = /[#@$][a-zA-Z0-9_]+/g;
        const matches = text.match(tagPattern);
        return matches || [];
    }

    private extractJsonObject(jsonString: string): Record<string, any> {
        if (!jsonString) return {};
        try {
            const parsed = JSON.parse(jsonString);
            return typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed) ? parsed : {};
        } catch (e) {
            console.error("Failed to parse JSON object:", e, "\nText:", jsonString);
            return {};
        }
    }

    private extractJsonArray(jsonString: string): any[] {
        if (!jsonString) return [];
        try {
            const parsed = JSON.parse(jsonString);
            return Array.isArray(parsed) ? parsed : [];
        } catch (e) {
            console.error("Failed to parse JSON array:", e, "\nText:", jsonString);
            return [];
        }
    }

    private extractFencedJsonBlock(lines: string[], startIndex: number): string {
        if (startIndex < 0 || startIndex >= lines.length) {
            return "";
        }
    
        let jsonLines: string[] = [];
        let inJsonBlock = false;
    
        // Start searching from the line *after* the marker
        for (let i = startIndex + 1; i < lines.length; i++) {
            const line = lines[i].trim();
    
            if (line.startsWith("```")) {
                if (!inJsonBlock) {
                    inJsonBlock = true;
                    // Handle content on the same line as the opening fence (e.g., ```json { ... )
                    const contentAfterFence = line.substring(line.indexOf('{'));
                    if(contentAfterFence.startsWith('{')) {
                        jsonLines.push(contentAfterFence);
                    }
                    continue;
                } else {
                    // Found the closing fence, we are done.
                    break;
                }
            }
    
            if (inJsonBlock) {
                jsonLines.push(lines[i]);
            } else if (line.startsWith("{") || line.startsWith("[")) {
                // If we find a JSON start without a fence, assume it's an unfenced block
                inJsonBlock = true;
                jsonLines.push(line);
            }
        }
    
        return jsonLines.join('\n');
    }
    
    private parseSingleDelta(rawKey: string, value: any): DeltaInstruction | null {
        const op = rawKey.charAt(0);
        const path = rawKey.substring(1);

        switch (op) {
            case '+': return { op: 'add', key: path, value: value };
            case '=': return { op: 'assign', key: path, value: value };
            case '!': return { op: 'declare', key: path, value: value };
            case '-': return { op: 'delete', key: path };
            default:
                console.warn(`Invalid delta operation character '${op}' in key '${rawKey}'`);
                return null;
        }
    }

    parseNarratorOutput(rawAiOutput: string): ParsedNarrationOutput {
        const lines = rawAiOutput.split('\n');

        const deltaIndex = lines.findIndex(line => line.trim().startsWith(DELTA_MARKER));
        const digestIndex = lines.findIndex(line => line.trim().startsWith(DIGEST_MARKER));
        const sceneIndex = lines.findIndex(line => line.trim().startsWith(SCENE_MARKER));

        const firstMarkerIndex = [deltaIndex, digestIndex, sceneIndex]
            .filter(index => index !== -1)
            .reduce((min, current) => Math.min(min, current), lines.length);

        const prose = lines.slice(0, firstMarkerIndex).join('\n').trim();

        const digestJsonString = this.extractFencedJsonBlock(lines, digestIndex);
        const deltaJsonString = this.extractFencedJsonBlock(lines, deltaIndex);
        const sceneJsonString = this.extractFencedJsonBlock(lines, sceneIndex);

        const deltaJson = this.extractJsonObject(deltaJsonString);
        const digestJson = this.extractJsonArray(digestJsonString);
        const sceneJson = this.extractJsonObject(sceneJsonString);

        const deltas: DeltaMap = {};
        for (const key in deltaJson) {
            const instruction = this.parseSingleDelta(key, deltaJson[key]);
            if (instruction) {
                deltas[key] = instruction;
            }
        }

        const digestLines: DigestLine[] = digestJson.map((item: any) => {
            const text = item.text || '';
            const importance = typeof item.importance === 'number' ? item.importance : 3;
            const tags = this.extractTags(text);
            return { turn: 0, tags, score: importance, text };
        }).filter(line => line.text);

        return {
            prose,
            deltas,
            digestLines,
            scene: sceneJson,
        };
    }
  // --- Context Stack Assembly Methods (from StoryForgeViewModel & StackAssembler.kt) ---

  /**
   * Helper to build common prompt structure (similar to private buildBasePrompt in old impl).
   */
  private buildCommonPromptParts(card: PromptCard): Message[] {
    const messages: Message[] = [];

    // NEW: System message about stack order
    messages.push({ role: "system", content: `## Context Stack Order Guidance
The following information is provided to you in a specific order to help you prioritize and integrate details. Focus on the most critical and structured information first, then dynamic elements, and finally conversational history. Adhere to this structure for optimal performance.` });

    messages.push({ role: "system", content: `## Core Scenario / Persona\n${card.prompt}` });

    if (card.gameRules) {
      messages.push({ role: "system", content: `\n## Game Rules\n${card.gameRules}` });
    }

    // AI Output Structure Rules (Emit Skeleton)
    if (card.emitSkeleton) {
      messages.push({ role: "system", content: `\n## AI Output Structure Rules\n${card.emitSkeleton}` });
    }

    // Function Definitions
    if (card.functionDefs) {
      messages.push({ role: "system", content: `\n## Available Functions (JSON)\n\`\`\`json\n${card.functionDefs}\n\`\`\`` });
    }

    // AI Settings Guidance (for context, not direct API params)
    messages.push({ role: "system", content: `\n## AI Configuration Guidance\nTemperature: ${card.aiSettings.temperature}\nMax Tokens: ${card.aiSettings.maxTokens}` });

    return messages;
  }

  buildFirstTurnPrompt(card: PromptCard): Message[] {
    const messages = this.buildCommonPromptParts(card);

    if (card.worldStateInit) {
      messages.push({ role: "system", content: `\n## Initial World State (JSON)\n\`\`\`json\n${card.worldStateInit}\n\`\`\`` });
    }

    // First Turn Specifics (if any)
    if (card.firstTurnOnlyBlock) {
      messages.push({ role: "system", content: `\n## First Turn Specifics\n${card.firstTurnOnlyBlock}` });
    }

    return messages;
  }

  buildEveryTurnPrompt(
    card: PromptCard,
    currentGameState: GameState,
    logEntries: LogEntry[],
    conversationHistory: Message[],
    currentUserAction: string,
    turnNumber: number
  ): Message[] {
    const messages = this.buildCommonPromptParts(card);
    const stackInstructions = card.stackInstructions;

    // === Dynamic Context Stack Assembly (Replicates StackAssembler.kt logic) ===

    // 1. World State Context (from worldStatePolicy)
    if (stackInstructions.worldStatePolicy.enabled && stackInstructions.worldStatePolicy.mode !== StackMode.NEVER) { // NEW: Check enabled flag
      const worldStateJson = JSON.stringify(currentGameState.worldState, null, 2); // Pretty print for readability
      messages.push({ role: "system", content: `\n## Current World State\n\`\`\`json\n${worldStateJson}\n\`\`\`` });
    }

    // 2. Known Entities (from knownEntitiesPolicy)
    if (stackInstructions.knownEntitiesPolicy.enabled && stackInstructions.knownEntitiesPolicy.mode !== StackMode.NEVER) { // NEW: Check enabled flag
        const knownEntitiesList: string[] = this.extractKnownEntities(
            currentGameState.worldState,
            stackInstructions.knownEntitiesPolicy.filtering,
            stackInstructions.knownEntitiesPolicy.n
        );

        if (knownEntitiesList.length > 0) {
            messages.push({ role: "system", content: `\n## Known Entities\n${knownEntitiesList.join('\n')}` });
        }
    }

    // 3. Digest Context (from digestEmission and digestPolicy)
    if (stackInstructions.digestPolicy.enabled && ( // NEW: Check enabled flag for digestPolicy
        stackInstructions.digestEmission[5]?.mode !== StackMode.NEVER ||
        stackInstructions.digestEmission[4]?.mode !== StackMode.NEVER ||
        stackInstructions.digestEmission[3]?.mode !== StackMode.NEVER ||
        stackInstructions.digestEmission[2]?.mode !== StackMode.NEVER ||
        stackInstructions.digestEmission[1]?.mode !== StackMode.NEVER
    )) {
      const relevantDigests: DigestLine[] = [];
      const eligibleLogs = logEntries.filter(log => log.digestLines && log.digestLines.length > 0);
      const sceneTags = this.getSceneTagsFromState(currentGameState.scene, currentGameState.worldState);


      eligibleLogs.forEach(log => {
        log.digestLines.forEach(digestLine => {
          const rule = stackInstructions.digestEmission[digestLine.score];
          if (rule && rule.mode !== StackMode.NEVER) {
            const meetsCondition =
              (rule.mode === StackMode.ALWAYS) ||
              (rule.mode === StackMode.AFTER_N && log.turnNumber >= rule.n) ||
              (rule.mode === StackMode.FIRST_N && log.turnNumber <= rule.n);

            if (meetsCondition) {
              let includeDigest = true;
              if (stackInstructions.digestPolicy.filtering === FilterMode.SCENE_ONLY) {
                if (!digestLine.tags || digestLine.tags.length === 0 || !digestLine.tags.some(tag => sceneTags.includes(tag))) {
                  includeDigest = false;
                }
              } else if (stackInstructions.digestPolicy.filtering === FilterMode.TAGGED) {
                if (!digestLine.tags || digestLine.tags.length === 0) {
                    includeDigest = false;
                }
              }

              if (includeDigest) {
                relevantDigests.push(digestLine);
              }
            }
          }
        });
      });

      relevantDigests.sort((a, b) => a.turnNumber - b.turnNumber);

      if (relevantDigests.length > 0) {
        messages.push({ role: "system", content: `\n## Game Summary Digest\n${relevantDigests.map(d => d.text).join('\n')}` });
      }
    }

    // 4. Expression Log (from expressionLogPolicy)
    if (stackInstructions.expressionLogPolicy.enabled && stackInstructions.expressionLogPolicy.mode !== StackMode.NEVER) { // NEW: Check enabled flag
        const expressionLogContent: string[] = [];
        const filteredLogs = logEntries.filter(log => {
            if (stackInstructions.expressionLogPolicy.filtering === FilterMode.SCENE_ONLY) {
                const tagsInNarratorOutput = this.extractTags(log.narratorOutput);
                const sceneTags = this.getSceneTagsFromState(currentGameState.scene, currentGameState.worldState);
                return tagsInNarratorOutput.some(tag => sceneTags.includes(tag));
            } else if (stackInstructions.expressionLogPolicy.filtering === FilterMode.TAGGED) {
                return this.extractTags(log.narratorOutput).length > 0;
            }
            return true;
        });

        let eligibleExpressionLogs = filteredLogs;
        if (stackInstructions.expressionLogPolicy.mode === StackMode.FIRST_N) {
            eligibleExpressionLogs = eligibleExpressionLogs.filter(log => log.turnNumber <= stackInstructions.expressionLogPolicy.n);
        } else if (stackInstructions.expressionLogPolicy.mode === StackMode.AFTER_N) {
            eligibleExpressionLogs = eligibleExpressionLogs.filter(log => log.turnNumber >= stackInstructions.expressionLogPolicy.n);
        }

        eligibleExpressionLogs.forEach(log => {
            const lines = log.narratorOutput.split('\n').filter(line => line.trim().length > 0);
            const numLines = Math.min(lines.length, stackInstructions.expressionLinesPerCharacter || 3);
            if (numLines > 0) {
                expressionLogContent.push(`Turn ${log.turnNumber} Expression: ${lines.slice(0, numLines).join(' ')}`);
            }
        });

        if (expressionLogContent.length > 0) {
            messages.push({ role: "system", content: `\n## Character Expressions Log\n${expressionLogContent.join('\n')}` });
        }
    }

    // --- End Dynamic Context Assembly ---

    // Append the conversation history *before* the current user action
    // This ensures the AI sees the full history leading up to the current turn.
    messages.push(...conversationHistory);

    // Add the current user's action
    messages.push({ role: "user", content: currentUserAction });

    return messages;
  }

  // Helper function to extract tags from world state for scene/known entities (similar to SceneManager.getSceneTags)
  private getSceneTagsFromState(scene: SceneState, worldState: Record<string, any>): string[] {
    const tags = new Set<string>();

    // Add tags from present entities in scene state
    for (const path of scene.present) {
        const parts = path.split(".");
        if (parts.length >= 2) {
            const category = parts[0];
            const entityKey = parts[1];
            // Access nested tag from worldState (e.g., worldState.npcs.goblin_1.tag)
            const entity = worldState[category]?.[entityKey];
            if (entity && typeof entity === 'object' && entity.tag && typeof entity.tag === 'string') {
                if (entity.tag.startsWith("#") || entity.tag.startsWith("@") || entity.tag.startsWith("$")) {
                    tags.add(entity.tag);
                }
            }
        }
    }

    // Add tag from scene location if it's a symbolic tag
    if (scene.location && (scene.location.startsWith("@") || scene.location.startsWith("#") || scene.location.startsWith("$"))) {
        tags.add(scene.location);
    }

    return Array.from(tags);
  }

  // Helper to extract known entities from world state based on policy
  private extractKnownEntities(
    worldState: Record<string, any>,
    filterMode: FilterMode,
    limit: number
  ): string[] {
    const knownEntities: { tag: string; path: string; fullObject: any }[] = [];

    const traverse = (obj: any, currentPath: string) => {
      if (typeof obj !== 'object' || obj === null) return;

      if (obj.tag && typeof obj.tag === 'string' && (obj.tag.startsWith('#') || obj.tag.startsWith('@') || obj.tag.startsWith('$'))) {
        knownEntities.push({ tag: obj.tag, path: currentPath, fullObject: obj });
      }

      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          traverse(obj[key], currentPath ? `${currentPath}.${key}` : key);
        }
      }
    };

    traverse(worldState, '');

    let filteredEntities = knownEntities;

    if (filterMode === FilterMode.SCENE_ONLY) {
        const sceneTags = this.getSceneTagsFromState(
            { location: null, present: [] },
            worldState
        );

        const currentPresentEntities = new Set(this.getCurrentGameState()?.scene.present || []);

        filteredEntities = filteredEntities.filter(entity => {
            if (currentPresentEntities.has(entity.path)) {
                return true;
            }
            if (entity.tag && sceneTags.includes(entity.tag)) {
                return true;
            }
            return false;
        });
    } else if (filterMode === FilterMode.TAGGED) {
      filteredEntities = filteredEntities.filter(entity => entity.tag && (entity.tag.startsWith('#') || entity.tag.startsWith('@') || entity.tag.startsWith('$')));
    }

    if (limit > 0) {
      filteredEntities = filteredEntities.slice(0, limit);
    }

    return filteredEntities.map(entity => {
        const parts = entity.path.split('.');
        const entityDisplayName = parts[parts.length - 1].replace(/^[#@$]/, '');
        const parentCategory = parts.length > 1 ? parts[parts.length - 2] : null;

        return `${parentCategory ? `${parentCategory}.` : ''}${entityDisplayName} (tag: ${entity.tag})`;
    });
  }
}

export const promptBuilder = new PromptBuilder();
@@FILE: src/main.tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css';

// Import the new provider that encapsulates GameSession creation and store initialization
import { GameSessionAndStoreProvider } from './providers/GameSessionAndStoreProvider.tsx';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    {/* Wrap App with the provider */}
    <GameSessionAndStoreProvider>
      <App />
    </GameSessionAndStoreProvider>
  </React.StrictMode>,
);
@@FOLDER: src/models
@@FILE: src/models/AiConnection.ts
// src/models/AiConnection.ts

/**
 * Represents the configuration for a connection to an AI service.
 * Aligns with Android's AiConnection class.
 */
export interface AiConnection {
  id: string; // Unique ID for this connection
  displayName: string; // User-friendly name for the connection (e.g., "My OpenAI Key")
  modelName: string; // The full name of the model (e.g., "GPT-4 Turbo")
  modelSlug: string; // The API identifier for the model (e.g., "gpt-4-turbo", "deepseek-coder")
  apiUrl: string; // The base URL for the API (e.g., "https://api.openai.com/v1/")
  apiToken: string; // The user's API key (sensitive)
  functionCallingEnabled: boolean; // Whether this connection supports/uses function calling
  userAgent?: string | null; // Optional: User-Agent string for API calls (from Android)

  // Metadata
  createdAt: string; // ISO 8601 string
  lastUpdated: string; // ISO 8601 string
}
@@FILE: src/models/DeltaInstruction.ts
// src/models/DeltaInstruction.ts

/**
 * Represents a single instruction to modify the game world state, as per DeltaInstruction.kt.
 * This is a pure data definition, without logic or companion methods.
 * Corresponds to a discriminated union in TypeScript for Kotlin's sealed class.
 *
 * `value: any` corresponds to Kotlin's `JsonElement`, allowing any valid JSON value (string, number, boolean, object, array, null).
 */

export type DeltaInstruction =
  | { op: 'add'; key: string; value: any }      // Corresponds to Add data class
  | { op: 'assign'; key: string; value: any }   // Corresponds to Assign data class
  | { op: 'declare'; key: string; value: any }  // Corresponds to Declare data class
  | { op: 'delete'; key: string };              // Corresponds to Delete data class (no value)

// Helper type for the map of deltas
export type DeltaMap = { [fullKey: string]: DeltaInstruction };
@@FILE: src/models/GameSnapshot.ts
// src/models/GameSnapshot.ts

import { GameState } from './GameState';
import { LogEntry } from './LogEntry';
import { PromptCard } from './PromptCard';
import { Message } from './Message'; // For conversation history

/**
 * Represents a full, self-contained snapshot of a game session.
 * This is the primary object for saving and loading games.
 * Based on `StoryForgeViewModel.buildSnapshot()`.
 */
export interface GameSnapshot {
  // --- Core Identifiers ---
  id: string; // Unique ID for this snapshot/game session
  userId: string;
  promptCardId: string; // ID of the card used
  title: string; // NEW: A human-readable title for the saved game

  // --- Timestamps ---
  createdAt: string; // When the game session was started
  updatedAt: string; // When this snapshot was last saved

  // --- Core Game State ---
  currentTurn: number;
  gameState: GameState; // Contains worldState, scene, narration
  conversationHistory: Message[]; // Full user/assistant conversation history

  // --- Logs for Context & Debugging ---
  // Note: All "digests" are now just part of the logs.
  // We extract them for context building, but don't store them separately.
  logs: LogEntry[];

  // --- UI Preferences (Persisted with Snapshot) ---
  worldStatePinnedKeys: string[]; // Stores full variable paths, e.g., "npcs.#fox.hp"
}
@@FILE: src/models/GameState.ts
// src/models/GameState.ts

/**
 * Represents the current scene's location and present entities.
 * Corresponds to the state managed by SceneManager.
 */
export interface SceneState {
  location: string | null;
  present: string[]; // List of entity keys, e.g., ["player.#you", "npcs.#fox"]
}

/**
 * Defines the core mutable state of the game.
 * All game variables (like HP, gold) are expected to be dynamic and reside within `worldState`.
 */
export interface GameState {
  narration: string;
  worldState: Record<string, any>; // The dynamic game world
  scene: SceneState; // The current scene state
}
@@FILE: src/models/LogEntry.ts
// src/models/LogEntry.ts

import { DeltaMap } from './DeltaInstruction';
import { DigestLine, TokenSummary, LogErrorFlag } from './LogEntryElements';
import { AiSettingsInCard } from './PromptCard';

/**
 * Canonical structured log for a single turn or significant event in the game.
 * Corresponds to TurnLogEntry.kt, enhanced with insights from DigestManager.
 */
export interface LogEntry {
 turnNumber: number;
 timestamp: string;

 userInput: string;
 narratorOutput: string; // The raw, full output from the AI
 prose: string; 

 digestLines: DigestLine[];
 deltas?: DeltaMap | null;

 contextSnapshot?: string | null;
 tokenUsage?: TokenSummary | null;
 apiRequestBody?: string | null;
 apiResponseBody?: string | null;
 apiUrl?: string | null;
 latencyMs?: number | null;

 aiSettings?: AiSettingsInCard | null;
 errorFlags: LogErrorFlag[];
 modelSlugUsed: string;
}
@@FILE: src/models/LogEntryElements.ts
// src/models/LogEntryElements.ts

/**
 * Represents a single summary line for the digest, as per DigestLine.kt (implied by TurnLogEntry).
 */
export interface DigestLine {
  text: string;
  importance: number; // 1 (minor) to 5 (critical)
  tags?: string[];    // Optional, e.g., for filtering by specific entities
}

/**
 * Summarizes token usage for an AI call, as per TokenSummary.kt (implied by TurnLogEntry).
 */
export interface TokenSummary {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  cachedTokens?: number; // Optional: If some tokens were served from cache
}

/**
 * Represents a flag for a validation error or issue in the log entry.
 * Based on `LogErrorFlag` (implied enum/sealed class from `TurnLogEntry`).
 */
export type LogErrorFlag =
  | 'MISSING_PROSE'
  | 'MISSING_DELTAS'
  | 'INVALID_JSON_DELTA'
  | 'INVALID_TOKEN_USAGE'
  | 'AI_RESPONSE_TOO_SHORT'
  | 'AI_RESPONSE_TOO_LONG'
  | 'UNEXPECTED_AI_FORMAT'
  | 'API_ERROR'
  | 'UNKNOWN_ERROR';
// Add more flags as needed based on your LogErrorFlag enum/sealed class if it exists.
@@FILE: src/models/Message.ts
// src/models/Message.ts

/**
 * Represents a single message in a conversation with the AI.
 * Corresponds to Message.kt.
 */
export interface Message {
  role: 'system' | 'user' | 'assistant';
  content: string;
}
@@FILE: src/models/ParsedNarrationOutput.ts
// src/models/ParsedNarrationOutput.ts

import { DeltaMap } from './DeltaInstruction';
import { DigestLine } from './LogEntryElements';

/**
 * Represents the structured data extracted from a raw AI narrator response.
 * Corresponds to `NarrationParser.ParsedNarration` from the old project.
 *
 * @param prose The clean, human-readable narrative text.
 * @param deltas A map of world state changes to apply.
 * @param digestLines An array of summary lines.
 * @param scene A flexible JSON object describing the current scene (location, present characters, etc.).
 */
export interface ParsedNarrationOutput {
  prose: string;
  deltas: DeltaMap;
  digestLines: DigestLine[];
  scene?: Record<string, any> | null; // Corresponds to the JsonObject? for the @scene block
}
@@FILE: src/models/PromptCard.ts
// src/models/PromptCard.ts

import { StackInstructions } from './StackInstructions'; // Import the new StackInstructions

/**
 * Defines the configuration settings for an AI connection.
 * These fields are embedded directly within PromptCard.
 * This is a pure data definition, with no default values.
 */
export interface AiSettings {
  selectedConnectionId: string;
  temperature: number;
  topP: number;
  maxTokens: number;
  presencePenalty: number;
  frequencyPenalty: number;
  functionCallingEnabled: boolean;
}

/**
 * A self-contained prompt card that can be submitted to the AI to configure tone, rules, or scenario.
 * This version consolidates AiSettings and uses a structured StackInstructions object.
 * This is a pure data definition, with no default values or logic.
 */
export interface PromptCard {
  // Web-specific lineage and deduplication fields (as per initial migration plan)
  id: string;
  rootId: string;
  parentId: string | null; // Null for root cards
  contentHash: string; // Hash of significant content fields to detect duplicates

  // Fields directly from old PromptCard.kt
  title: string;
  description: string | null; // Optional in Kotlin, so `string | null`
  prompt: string;
  firstTurnOnlyBlock: string;
  stackInstructions: StackInstructions; // Now a structured object
  emitSkeleton: string;      // JSON string
  worldStateInit: string;    // JSON string
  gameRules: string;
  aiSettings: AiSettings;
  helperAiSettings: AiSettings;
  isHelperAiEnabled: boolean; // NEW: Controls whether helper AI is considered active
  tags: string[];            // Kotlin `List<String>` maps to `string[]`
  isExample: boolean;        // From Kotlin `isExample`
  functionDefs: string;      // JSON string

  // Additional web-specific metadata (as per initial migration plan)
  isPublic: boolean;
  createdAt: string; // ISO 8601 string
  updatedAt: string; // ISO 8601 string
  ownerId: string;   // Firebase User UID
}

/**
 * Represents the raw data needed when creating or updating a PromptCard.
 * This does not include generated fields like IDs, hashes, timestamps, or ownerId,
 * nor does it specify default values for optional fields.
 */
export interface NewPromptCardData {
  title: string;
  prompt: string;
  description?: string | null;
  firstTurnOnlyBlock?: string;
  // This is kept as 'string | StackInstructions' to allow raw JSON string input,
  // with parsing logic to convert it to StackInstructions handled elsewhere (e.g., in logic/cardManager or data repository).
  stackInstructions?: string | StackInstructions;
  emitSkeleton?: string;
  worldStateInit?: string;
  gameRules?: string;
  aiSettings?: AiSettings; // Changed from AiSettingsInCard to AiSettings for consistency
  helperAiSettings?: AiSettings; // Changed from AiSettingsInCard to AiSettings for consistency
  isHelperAiEnabled?: boolean; // NEW: Optional for new card data
  tags?: string[];
  isExample?: boolean;
  functionDefs?: string;
  isPublic?: boolean;
}
@@FILE: src/models/StackInstructions.ts
// src/models/StackInstructions.ts

/**
 * Defines the mode for including a stack element.
 * Now an enum to allow runtime access (e.g., Object.values).
 */
export enum StackMode {
  ALWAYS = 'always',
  FIRST_N = 'firstN',
  AFTER_N = 'afterN',
  NEVER = 'never',
  FILTERED = 'filtered', // Added if 'filtered' applies to modes
}

/**
 * Defines the filtering strategy for a stack element.
 * Now an enum to allow runtime access.
 */
export enum FilterMode {
  NONE = 'none',
  SCENE_ONLY = 'sceneOnly',
  TAGGED = 'tagged',
}

/**
 * Defines a policy for including prose or other list-based context.
 * Corresponds to `ProsePolicy`.
 */
export interface ProsePolicy {
  mode: StackMode; // Use the enum
  n: number;
  filtering: FilterMode; // Use the enum
  enabled?: boolean; // NEW: Added for toggling the entire section
}

/**
 * Defines a rule for emitting digest lines based on their importance score.
 * Corresponds to `EmissionRule`.
 */
export interface EmissionRule {
  mode: StackMode; // Use the enum
  n: number;
}

/**
 * Defines the policy for filtering digest lines.
 * Corresponds to `DigestFilterPolicy`.
 */
export interface DigestFilterPolicy {
  filtering: FilterMode; // Use the enum
  enabled?: boolean; // NEW: Added for toggling the entire section
}

/**
 * Defines the policy for token usage and fallback strategies.
 * Corresponds to `TokenPolicy`.
 */
export interface TokenPolicy {
  minTokens: number;
  maxTokens: number;
  fallbackPlan: string[];
}

/**
 * The full, structured stack instructions for a PromptCard.
 * Corresponds to `StackInstructions.kt`.
 */
export interface StackInstructions {
  narratorProseEmission: ProsePolicy;
  digestPolicy: DigestFilterPolicy;
  digestEmission: Record<number, EmissionRule>; // Map<Int, EmissionRule> -> Record<number, EmissionRule>

  expressionLogPolicy: ProsePolicy;
  expressionLinesPerCharacter: number;
  emotionWeighting: boolean;

  worldStatePolicy: ProsePolicy;
  knownEntitiesPolicy: ProsePolicy;

  // REMOVED: outputFormat: string; // This field is being removed
  tokenPolicy: TokenPolicy;
}
@@FILE: src/models/index.ts
// src/models/index.ts

// Re-export all models for easier importing
export * from './AiConnection';
export * from './DeltaInstruction';
export * from './GameSnapshot';
export * from './GameState.ts';
export * from './LogEntry';
export * from './LogEntryElements';
export * from './Message';
export * from './ParsedNarrationOutput';
export * from './PromptCard';
export * from './StackInstructions';
@@FOLDER: src/pages
@@FILE: src/pages/SourceDump.tsx
import React, { useEffect, useState } from 'react';

const SourceDump: React.FC = () => {
  const [code, setCode] = useState<string>('Loading...');

  useEffect(() => {
    fetch('/source-dump.txt')
      .then(res => res.text())
      .then(text => setCode(text))
      .catch(err => setCode('Error loading source dump: ' + err));
  }, []);

  return (
    <pre style={{
      whiteSpace: 'pre-wrap',
      background: '#1e1e1e',
      color: '#d4d4d4',
      padding: '1rem',
      overflowX: 'auto'
    }}>
      {code}
    </pre>
  );
};

export default SourceDump;

@@FOLDER: src/providers
@@FILE: src/providers/GameSessionAndStoreProvider.tsx
// src/providers/GameSessionAndStoreProvider.tsx

import React, { useRef } from 'react';
import { GameSession, IGameSession } from '../logic/gameSession';
import { promptCardManager } from '../logic/cardManager';
import { promptBuilder } from '../logic/promptBuilder';
import { aiClient } from '../logic/aiClient';
import { logManager } from '../logic/logManager';
import { gameRepository } from '../data/repositories/gameRepository';
import { promptCardRepository } from '../data/repositories/promptCardRepository';
import { initializeGameStateStore } from '../state/useGameStateStore';
import { GameSessionProvider } from '../contexts/GameSessionContext'; // Import the context provider

interface GameSessionAndStoreProviderProps {
  children: React.ReactNode;
}

export const GameSessionAndStoreProvider: React.FC<GameSessionAndStoreProviderProps> = ({ children }) => {
  // Use useRef to ensure gameSessionInstance is created only once across renders
  const gameSessionInstanceRef = useRef<IGameSession | null>(null);

  if (!gameSessionInstanceRef.current) {
    console.log("GameSessionAndStoreProvider: Instantiating GameSession...");
    gameSessionInstanceRef.current = new GameSession(
      promptCardRepository,
      gameRepository, // Passed as gameRepoInstance
      promptBuilder,
      aiClient,
      logManager
    );
    // Inject the gameSession instance into the Zustand store's internal state
    initializeGameStateStore(gameSessionInstanceRef.current);
  }

  // Provide the gameSession instance via React Context to any components that need it
  return (
    <GameSessionProvider gameSession={gameSessionInstanceRef.current}>
      {children}
    </GameSessionProvider>
  );
};
@@FOLDER: src/state
@@FILE: src/state/useAuthStore.ts
// src/state/useAuthStore.ts

import { create } from 'zustand';
import { User } from 'firebase/auth'; // Import Firebase User type
import { subscribeToAuthChanges, signInWithGoogle, signOutUser } from '../data/repositories/authRepository'; // Import auth functions

// Define the shape of our authentication state
interface AuthState {
  user: User | null; // The current authenticated user or null
  isLoading: boolean; // True while checking initial auth state
  error: string | null; // Any error during auth operations

  // Actions
  // These are not directly implemented here, but exposed for components to call
  signIn: () => Promise<void>;
  signOut: () => Promise<void>;
}

// Create the Zustand store
export const useAuthStore = create<AuthState>((set, get) => ({
  user: null, // Initial state: no user
  isLoading: true, // Initially loading to check auth state
  error: null, // No error initially

  // Action to handle sign-in
  signIn: async () => {
    set({ error: null }); // Clear previous errors
    try {
      await signInWithGoogle();
      // The onAuthStateChanged listener will update the 'user' state,
      // so we don't need to manually set it here based on the signIn result.
    } catch (err: any) {
      console.error("AuthStore signIn error:", err);
      set({ error: err.message || "Failed to sign in." });
    }
  },

  // Action to handle sign-out
  signOut: async () => {
    set({ error: null }); // Clear previous errors
    try {
      await signOutUser();
    } catch (err: any) {
      console.error("AuthStore signOut error:", err);
      set({ error: err.message || "Failed to sign out." });
    }
  },
}));

// --- Initialize and Subscribe to Auth Changes ---
// This part ensures our store's 'user' state is always in sync with Firebase Auth.
// It runs only once when the module is loaded.
const unsubscribe = subscribeToAuthChanges((user) => {
  useAuthStore.setState({ user: user, isLoading: false }); // Update user and set loading to false
  console.log("Auth State Updated:", user ? user.uid : "No user");
});

// Optional: You might want to handle unsubscription if your app could unmount this module,
// but for a core global store, it often lives for the app's lifetime.
// If you were to integrate this into a React component's useEffect, you'd return the unsubscribe function.
// For a global store, we typically let it live.
@@FILE: src/state/useGameStateStore.ts
// src/state/useGameStateStore.ts

import { create } from 'zustand';
import { GameSnapshot, GameState, LogEntry, Message } from '../models/index';
import { flattenJsonObject, getNestedValue } from '../utils/jsonUtils';
import { produce } from 'immer'; // For immutable updates of nested objects
import { useSettingsStore } from './useSettingsStore'; // Import the new settings store
import { useCallback } from 'react'; // Import useCallback

import { IGameSession } from '../logic/gameSession'; // Import the IGameSession interface for type safety

// Module-level variable to hold the injected GameSession instance
let _gameSessionInstance: IGameSession;

/**
 * Initializes the GameStateStore with the GameSession instance.
 * This function should be called once, typically from a provider component (e.g., GameSessionAndStoreProvider).
 * It ensures that the Zustand store's actions can access the game session.
 */
export const initializeGameStateStore = (gameSession: IGameSession) => {
  if (!_gameSessionInstance) {
    _gameSessionInstance = gameSession;
    console.log("GameStateStore: GameSession instance injected.");
  } else {
    console.warn("GameStateStore: Attempted to re-initialize GameSession instance. This should only happen once.");
  }
};

// Define types for pinning
type PinToggleType = 'variable' | 'entity' | 'category';

interface GameStateStore {
  currentSnapshot: GameSnapshot | null;
  currentPromptCardId: string | null;
  currentGameState: GameState | null;
  gameLogs: LogEntry[];
  conversationHistory: Message[];
  worldStatePinnedKeys: string[]; // Stores full variable paths, e.g., "npcs.#fox.hp"
  narratorInputText: string;
  narratorScrollPosition: number;
  gameError: string | null;
  gameLoading: boolean;

  // Actions - these no longer accept gameSession as a parameter.
  // They will internally use the _gameSessionInstance module variable.
  initializeGame: (userId: string, cardId: string, existingSnapshotId?: string) => Promise<void>;
  processPlayerAction: (action: string) => Promise<void>;
  processFirstNarratorTurn: () => Promise<void>;
  saveGame: () => Promise<void>;
  loadGame: (userId: string, snapshotId: string) => Promise<void>;
  loadLastActiveGame: (userId: string) => Promise<boolean>;

  // Pinning actions
  toggleWorldStatePin: (keyPath: string, type: PinToggleType) => void;
  unpinAllForEntity: (entityPath: string) => void; // e.g., "npcs.#fox"
  unpinIndividualVariable: (variablePath: string) => void; // e.g., "npcs.#fox.hp"

  // UI related state updates
  updateNarratorInputText: (text: string) => void;
  updateNarratorScrollPosition: (position: number) => void;

  // World state editing actions (will be implemented via logic layer eventually)
  renameWorldCategory: (oldName: string, newName: string) => Promise<void>;
  renameWorldEntity: (category: string, oldName: string, newName: string) => Promise<void>;
  deleteWorldCategory: (category: string) => Promise<void>;
  deleteWorldEntity: (category: string, entity: string) => Promise<void>;
  editWorldKeyValue: (key: string, value: any) => Promise<void>;
  deleteWorldKey: (key: string) => Promise<void>;
}

export const useGameStateStore = create<GameStateStore>((set, get) => ({
  currentSnapshot: null,
  currentPromptCardId: null,
  currentGameState: null,
  gameLogs: [],
  conversationHistory: [],
  worldStatePinnedKeys: [],
  narratorInputText: '',
  narratorScrollPosition: 0,
  gameError: null,
  gameLoading: false,

  initializeGame: async (userId, cardId, existingSnapshotId) => {
    console.log('GameStateStore: initializeGame action started.');
    set({ gameLoading: true, gameError: null });

    // Ensure gameSession instance has been injected
    if (!_gameSessionInstance) {
      set({ gameError: "Game session instance not initialized.", gameLoading: false });
      console.error("GameSession instance not found in useGameStateStore. Call initializeGameStateStore first.");
      return;
    }

    const useDummyNarrator = useSettingsStore.getState().useDummyNarrator;

    try {
      console.log('GameStateStore: Calling _gameSessionInstance.initializeGame...');
      // Use the injected _gameSessionInstance
      await _gameSessionInstance.initializeGame(userId, cardId, existingSnapshotId, useDummyNarrator);

      console.log('GameStateStore: _gameSessionInstance.initializeGame completed.');

      // Retrieve state from the injected _gameSessionInstance
      const snapshot = _gameSessionInstance.getCurrentGameSnapshot();
      console.log('GameStateStore: Retrieved snapshot from _gameSessionInstance:', snapshot);
      if (snapshot) {
        set({
          currentSnapshot: snapshot,
          currentPromptCardId: snapshot.promptCardId,
          currentGameState: snapshot.gameState,
          gameLogs: snapshot.logs || [],
          conversationHistory: snapshot.conversationHistory || [],
          worldStatePinnedKeys: snapshot.worldStatePinnedKeys || [],
        });
        console.log('GameStateStore: Zustand state updated with snapshot. currentSnapshot:', get().currentSnapshot);
      } else {
        console.warn('GameStateStore: _gameSessionInstance.getCurrentGameSnapshot() returned null after initialization. Setting error.');
        set({ gameError: "Game state could not be loaded or initialized.", gameLoading: false });
      }
      set({ gameLoading: false });
    } catch (error: any) {
      console.error("GameStateStore: Error in initializeGame action:", error);
      set({ gameError: error.message, gameLoading: false });
    }
  },

  processFirstNarratorTurn: async () => {
    // Ensure gameSession instance has been injected
    if (!_gameSessionInstance) {
      set({ gameError: "Game session instance not initialized.", gameLoading: false });
      return;
    }
    set({ gameLoading: true, gameError: null });

    const useDummyNarrator = useSettingsStore.getState().useDummyNarrator;

    try {
      // Use the injected _gameSessionInstance
      await _gameSessionInstance.processFirstTurn(useDummyNarrator);

      // Retrieve state from the injected _gameSessionInstance
      const updatedSnapshot = _gameSessionInstance.getCurrentGameSnapshot();
      if (updatedSnapshot) {
        set({
          currentSnapshot: updatedSnapshot,
          currentGameState: updatedSnapshot.gameState,
          gameLogs: updatedSnapshot.logs,
          conversationHistory: updatedSnapshot.conversationHistory,
        });
      }
      set({ gameLoading: false });
    } catch (error: any) {
      set({ gameError: error.message, gameLoading: false });
      console.error("Error processing first narrator turn:", error);
    }
  },

  processPlayerAction: async (action) => {
    // Ensure gameSession instance has been injected
    if (!_gameSessionInstance) {
        set({ gameError: "Game session instance not initialized.", gameLoading: false });
        return;
    }
    set({ gameLoading: true, gameError: null });

    const useDummyNarrator = useSettingsStore.getState().useDummyNarrator;

    try {
      // Use the injected _gameSessionInstance
      const { aiProse, newLogEntries, updatedSnapshot } = await _gameSessionInstance.processPlayerAction(
        action,
        useDummyNarrator
      );
      set({
        currentSnapshot: updatedSnapshot,
        currentGameState: updatedSnapshot.gameState,
        gameLogs: updatedSnapshot.logs,
        conversationHistory: updatedSnapshot.conversationHistory,
        narratorInputText: '',
        worldStatePinnedKeys: updatedSnapshot.worldStatePinnedKeys || [],
      });
      set({ gameLoading: false });
    } catch (error: any) {
      set({ gameError: error.message, gameLoading: false });
      console.error("Error processing player action:", error);
    }
  },

  saveGame: async () => {
    // Ensure gameSession instance has been injected
    if (!_gameSessionInstance) {
        console.error("GameSession: Cannot save game because gameSessionInstance is not set in store.");
        throw new Error("Game session not initialized in store.");
    }
    const currentSnapshot = get().currentSnapshot;
    if (currentSnapshot) {
      const snapshotToSave = produce(currentSnapshot, draft => {
        draft.worldStatePinnedKeys = get().worldStatePinnedKeys;
        draft.updatedAt = new Date().toISOString();
      });

      await _gameSessionInstance.saveGame(snapshotToSave);
      console.log('useGameStateStore: saveGame() finished.');
    } else {
      console.warn("No current snapshot in store to save.");
    }
  },

  loadGame: async (userId, snapshotId) => {
    // Ensure gameSession instance has been injected
    if (!_gameSessionInstance) {
        set({ gameError: "Game session instance not initialized.", gameLoading: false });
        return;
    }
    set({ gameLoading: true, gameError: null });
    try {
      // Use the injected _gameSessionInstance
      await _gameSessionInstance.loadGame(userId, snapshotId);
      // Retrieve state from the injected _gameSessionInstance
      const snapshot = _gameSessionInstance.getCurrentGameSnapshot();
      if (snapshot) {
        set({
          currentSnapshot: snapshot,
          currentPromptCardId: snapshot.promptCardId,
          currentGameState: snapshot.gameState,
          gameLogs: snapshot.logs || [],
          conversationHistory: snapshot.conversationHistory || [],
          worldStatePinnedKeys: snapshot.worldStatePinnedKeys || [],
        });
      }
      set({ gameLoading: false });
    } catch (error: any) {
      set({ gameError: error.message, gameLoading: false });
      console.error("Error loading game:", error);
    }
  },

  loadLastActiveGame: async (userId: string): Promise<boolean> => {
    set({ gameLoading: true, gameError: null });
    try {
        if (!_gameSessionInstance) {
            throw new Error("Game session instance not found in store.");
        }

        // Access gameRepo via the injected _gameSessionInstance (now public on IGameSession)
        const allSnapshots = await _gameSessionInstance.gameRepo.getAllGameSnapshots(userId);
        if (allSnapshots.length > 0) {
            const lastActiveSnapshot = allSnapshots[0];
            console.log(`GameStateStore: Found last active game: ${lastActiveSnapshot.id}. Loading...`);
            // Use the injected _gameSessionInstance
            await _gameSessionInstance.loadGame(userId, lastActiveSnapshot.id);
            // Retrieve state from the injected _gameSessionInstance
            const loadedSnapshot = _gameSessionInstance.getCurrentGameSnapshot();
            if (loadedSnapshot) {
                set({
                    currentSnapshot: loadedSnapshot,
                    currentPromptCardId: loadedSnapshot.promptCardId,
                    currentGameState: loadedSnapshot.gameState,
                    gameLogs: loadedSnapshot.logs || [],
                    conversationHistory: loadedSnapshot.conversationHistory || [],
                    worldStatePinnedKeys: loadedSnapshot.worldStatePinnedKeys || [],
                });
                console.log(`GameStateStore: Successfully loaded last active game: ${loadedSnapshot.id}`);
                set({ gameLoading: false });
                return true;
            }
        }
        console.log("GameStateStore: No last active game found for user.");
        set({ gameLoading: false, currentSnapshot: null, currentPromptCardId: null, currentGameState: null, gameLogs: [], conversationHistory: [], worldStatePinnedKeys: [] });
        return false;
    } catch (error: any) {
        console.error("GameStateStore: Error loading last active game:", error);
        set({ gameError: error.message, gameLoading: false });
        return false;
    }
  },
  
  toggleWorldStatePin: (keyPath: string, type: PinToggleType) => {
    console.log(`[Store: toggleWorldStatePin] Toggling pin for "${keyPath}" of type "${type}"`);
    set(produce((state: GameStateStore) => { // Use immer's produce for immutable updates
      const currentWorldState = state.currentGameState?.worldState || {};
      const newPinnedKeys = new Set(state.worldStatePinnedKeys);

      const isCurrentlyPinned = (path: string) => newPinnedKeys.has(path);

      let relevantKeysToToggle: string[] = [];

      if (type === 'variable') {
        relevantKeysToToggle = [keyPath];
      } else if (type === 'entity') {
        const flattenedEntity = flattenJsonObject(getNestedValue(currentWorldState, keyPath.split('.')), keyPath);
        relevantKeysToToggle = Object.keys(flattenedEntity).filter(k => {
          return k.startsWith(keyPath) && k.split('.').length > keyPath.split('.').length;
        });
      } else if (type === 'category') {
        const flattenedCategory = flattenJsonObject(getNestedValue(currentWorldState, keyPath.split('.')), keyPath);
        relevantKeysToToggle = Object.keys(flattenedCategory).filter(k => {
          return k.startsWith(keyPath) && k.split('.').length > keyPath.split('.').length;
        });
      }

      // Determine if we should pin or unpin. If any of the relevant keys are pinned, we unpin all. Otherwise, we pin.
      // Fixed logic for shouldPin: if ALL are currently pinned, we should UNPIN. Otherwise, we PIN.
      const shouldPin = relevantKeysToToggle.length > 0
        ? !relevantKeysToToggle.every(isCurrentlyPinned)
        : true; // If no keys found, default to pinning (e.g., new category/entity)

      console.log(`[Store: toggleWorldStatePin] Relevant keys:`, relevantKeysToToggle);
      console.log(`[Store: toggleWorldStatePin] Current pinned keys before toggle:`, Array.from(newPinnedKeys));
      console.log(`[Store: toggleWorldStatePin] Should pin:`, shouldPin);


      relevantKeysToToggle.forEach(key => {
        if (shouldPin) {
          newPinnedKeys.add(key);
        } else {
          newPinnedKeys.delete(key);
        }
      });

      state.worldStatePinnedKeys = Array.from(newPinnedKeys);
      if (state.currentSnapshot) {
        state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
      }
      console.log(`[Store: toggleWorldStatePin] Pinned keys after toggle:`, state.worldStatePinnedKeys);
    }));
    get().saveGame(); // Trigger a save after pinning state changes
  },

  unpinAllForEntity: (entityPath: string) => {
    console.log(`%c[Store: unpinAllForEntity] Executing for entity: "${entityPath}"`, 'color: orange;');
    set(produce((state: GameStateStore) => {
      console.log(`%c[Store: unpinAllForEntity] worldStatePinnedKeys before: %o`, 'color: orange;', state.worldStatePinnedKeys);
      // Use Set for efficient deletion
      const newPinnedKeys = new Set(state.worldStatePinnedKeys);
      state.worldStatePinnedKeys.forEach(key => {
        if (key.startsWith(entityPath + '.')) {
          newPinnedKeys.delete(key);
        }
      });
      state.worldStatePinnedKeys = Array.from(newPinnedKeys);
      if (state.currentSnapshot) {
        state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
      }
      console.log(`%c[Store: unpinAllForEntity] worldStatePinnedKeys after: %o`, 'color: orange;', state.worldStatePinnedKeys);
    }));
    get().saveGame();
  },

  unpinIndividualVariable: (variablePath: string) => {
    console.log(`%c[Store: unpinIndividualVariable] Executing for variable: "${variablePath}"`, 'color: lightblue;');
    set(produce((state: GameStateStore) => {
      console.log(`%c[Store: unpinIndividualVariable] worldStatePinnedKeys before: %o`, 'color: lightblue;', state.worldStatePinnedKeys);
      // This line is the critical one for unpinning a single variable
      state.worldStatePinnedKeys = state.worldStatePinnedKeys.filter(key => key !== variablePath);
      if (state.currentSnapshot) {
        state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
      }
      console.log(`%c[Store: unpinIndividualVariable] worldStatePinnedKeys after: %o`, 'color: lightblue;', state.worldStatePinnedKeys);
    }));
    get().saveGame();
  },

  updateNarratorInputText: (text) => set({ narratorInputText: text }),
  updateNarratorScrollPosition: (position) => set({ narratorScrollPosition: position }),

  renameWorldCategory: async (oldName, newName) => {
    set(produce((state: GameStateStore) => {
      if (!state.currentGameState) return;
      const newWorldState = state.currentGameState.worldState; // immer makes this mutable draft
      if (newWorldState[oldName]) {
        newWorldState[newName] = newWorldState[oldName];
        delete newWorldState[oldName];
        state.currentGameState.worldState = newWorldState; // Assign back the draft

        // Update pinned keys
        state.worldStatePinnedKeys = state.worldStatePinnedKeys.map(key =>
            key.startsWith(oldName + '.') ? `${newName}${key.substring(oldName.length)}` : key
        );
        if (state.currentSnapshot) {
            state.currentSnapshot.gameState.worldState = newWorldState;
            state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
        }
      }
    }));
    get().saveGame();
  },
  renameWorldEntity: async (category, oldName, newName) => {
    set(produce((state: GameStateStore) => {
      if (!state.currentGameState || !state.currentGameState.worldState[category]) return;
      const categoryObj = state.currentGameState.worldState[category]; // mutable draft
      if (categoryObj[oldName]) {
        categoryObj[newName] = categoryObj[oldName];
        delete categoryObj[oldName];
        state.currentGameState.worldState[category] = categoryObj;

        // Update pinned keys
        const oldEntityPath = `${category}.${oldName}`;
        const newEntityPath = `${category}.${newName}`;
        state.worldStatePinnedKeys = state.worldStatePinnedKeys.map(key =>
            key.startsWith(oldEntityPath + '.') ? `${newEntityPath}${key.substring(oldEntityPath.length)}` : key
        );
        if (state.currentSnapshot) {
            state.currentSnapshot.gameState.worldState = state.currentGameState.worldState;
            state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
        }
      }
    }));
    get().saveGame();
  },
  deleteWorldCategory: async (category) => {
    set(produce((state: GameStateStore) => {
      if (!state.currentGameState || !state.currentGameState.worldState[category]) return;
      const newWorldState = state.currentGameState.worldState; // mutable draft
      delete newWorldState[category];
      state.currentGameState.worldState = newWorldState;

      // Remove relevant pinned keys
      state.worldStatePinnedKeys = state.worldStatePinnedKeys.filter(key => !key.startsWith(category + '.'));
      if (state.currentSnapshot) {
          state.currentSnapshot.gameState.worldState = newWorldState;
          state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
        }
    }));
    get().saveGame();
  },
  deleteWorldEntity: async (category, entity) => {
    set(produce((state: GameStateStore) => {
      if (!state.currentGameState || !state.currentGameState.worldState[category] || !state.currentGameState.worldState[category][entity]) return;
      const categoryObj = state.currentGameState.worldState[category]; // mutable draft
      delete categoryObj[entity];
      state.currentGameState.worldState[category] = categoryObj;

      // Remove relevant pinned keys
      const entityPath = `${category}.${entity}`;
      state.worldStatePinnedKeys = state.worldStatePinnedKeys.filter(key => !key.startsWith(entityPath + '.'));
      if (state.currentSnapshot) {
          state.currentSnapshot.gameState.worldState = state.currentGameState.worldState;
          state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
      }
    }));
    get().saveGame();
  },
  editWorldKeyValue: async (key, value) => {
    set(produce((state: GameStateStore) => {
      if (!state.currentGameState) return;
      const newWorldState = state.currentGameState.worldState; // mutable draft
      const parts = key.split('.');
      let current: any = newWorldState;
      for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!(part in current)) {
              current[part] = {};
          }
          current = current[part];
      }
      current[parts[parts.length - 1]] = value;
      state.currentGameState.worldState = newWorldState; // Assign back the draft
      if (state.currentSnapshot) {
          state.currentSnapshot.gameState.worldState = newWorldState;
      }
    }));
    get().saveGame();
  },
  deleteWorldKey: async (key) => {
    set(produce((state: GameStateStore) => {
      if (!state.currentGameState) return;
      const newWorldState = state.currentGameState.worldState; // mutable draft
      const parts = key.split('.');
      let current: any = newWorldState;
      for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!(part in current)) {
              return; // Path doesn't exist, nothing to delete
          }
          current = current[part];
      }
      delete current[parts[parts.length - 1]];
      state.currentGameState.worldState = newWorldState;

      // Remove from pinned keys
      state.worldStatePinnedKeys = state.worldStatePinnedKeys.filter(pk => pk !== key);
      if (state.currentSnapshot) {
          state.currentSnapshot.gameState.worldState = newWorldState;
          state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
      }
    }));
    get().saveGame();
  },
}));
@@FILE: src/state/useLogStore.ts
// src/state/useLogStore.ts

import { create } from 'zustand';
import { LogEntry } from '../models/LogEntry'; // Assuming LogEntry model is available
import { LogViewMode } from '../utils/types'; // We'll define LogViewMode here




interface LogState {
  logEntries: LogEntry[];
  selectedLogViewModes: LogViewMode[];
  isLoading: boolean;
  error: string | null;

  // Actions
  setLogEntries: (entries: LogEntry[]) => void; // To be called by useGameStateStore after a turn
  setSelectedLogViewModes: (modes: LogViewMode[]) => void;
  // Potentially fetch logs if we implement persistent log storage separate from GameSnapshot
  fetchLogs: (snapshotId: string) => Promise<void>;
}

export const useLogStore = create<LogState>((set, get) => ({
  logEntries: [],
  selectedLogViewModes: [LogViewMode.NARRATOR_OUTPUT, LogViewMode.USER_INPUT, LogViewMode.DIGEST_LINES], // Default selection
  isLoading: false,
  error: null,

  setLogEntries: (entries) => set({ logEntries: entries }),

  setSelectedLogViewModes: (modes) => set({ selectedLogViewModes: modes }),

  fetchLogs: async (snapshotId) => {
    set({ isLoading: true, error: null });
    try {
      // In MVP, logs are part of GameSnapshot. So this would primarily
      // fetch the GameSnapshot and then extract its logs.
      // E.g., const snapshot = await gameRepository.getGameSnapshot(userId, snapshotId);
      // set({ logEntries: snapshot?.logs || [], isLoading: false });
      set({ isLoading: false }); // Placeholder
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error fetching logs:", error);
    }
  },
}));
@@FILE: src/state/usePromptCardStore.ts
// src/state/usePromptCardStore.ts

import { create } from 'zustand';
import { PromptCard, NewPromptCardData, AiConnection } from '../models/index'; // Assuming index.ts exports these
import { promptCardManager } from '../logic/cardManager';
import { gameRepository } from '../data/repositories/gameRepository'; // For AI Connections

interface PromptCardState {
  promptCards: PromptCard[];
  activePromptCard: PromptCard | null;
  aiConnections: AiConnection[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchPromptCards: (userId: string) => Promise<void>;
  setActivePromptCard: (card: PromptCard) => void;
  addPromptCard: (userId: string, cardData: NewPromptCardData) => Promise<PromptCard | null>;
  updatePromptCard: (userId: string, cardId: string, updates: Partial<PromptCard>) => Promise<PromptCard | null>;
  duplicatePromptCard: (userId: string, cardId: string) => Promise<PromptCard | null>;
  deletePromptCard: (userId: string, cardId: string) => Promise<void>;
  fetchAiConnections: (userId: string) => Promise<void>;
  // Import/Export functionality will go here eventually
  importPromptCards: (userId: string, cards: NewPromptCardData[]) => Promise<PromptCard[]>;
  exportPromptCard: (userId: string, cardId: string) => Promise<PromptCard | null>;
}

export const usePromptCardStore = create<PromptCardState>((set, get) => ({
  promptCards: [],
  activePromptCard: null,
  aiConnections: [],
  isLoading: false,
  error: null,

  fetchPromptCards: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const cards = await promptCardManager.getAllPromptCards(userId);
      set({ promptCards: cards, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error fetching prompt cards:", error);
    }
  },

  setActivePromptCard: (card) => {
    set({ activePromptCard: card });
  },

  addPromptCard: async (userId, cardData) => {
    set({ isLoading: true, error: null });
    try {
      const newCard = await promptCardManager.createNewPromptCard(userId, cardData);
      set((state) => ({
        promptCards: [...state.promptCards, newCard],
        isLoading: false,
      }));
      return newCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error adding prompt card:", error);
      return null;
    }
  },

  updatePromptCard: async (userId, cardId, updates) => {
    set({ isLoading: true, error: null });
    try {
      const updatedCard = await promptCardManager.updatePromptCard(userId, cardId, updates);
      if (updatedCard) {
        set((state) => ({
          promptCards: state.promptCards.map(card => card.id === updatedCard.id ? updatedCard : card),
          activePromptCard: state.activePromptCard?.id === updatedCard.id ? updatedCard : state.activePromptCard,
          isLoading: false,
        }));
      }
      return updatedCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error updating prompt card:", error);
      return null;
    }
  },

  duplicatePromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      const duplicatedCard = await promptCardManager.duplicatePromptCard(userId, cardId);
      if (duplicatedCard) {
        set((state) => ({
          promptCards: [...state.promptCards, duplicatedCard],
          isLoading: false,
        }));
      }
      return duplicatedCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error duplicating prompt card:", error);
      return null;
    }
  },

  deletePromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      await promptCardManager.deletePromptCard(userId, cardId);
      set((state) => ({
        promptCards: state.promptCards.filter(card => card.id !== cardId),
        activePromptCard: state.activePromptCard?.id === cardId ? null : state.activePromptCard,
        isLoading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error deleting prompt card:", error);
    }
  },

  fetchAiConnections: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const connections = await gameRepository.getAiConnections(userId);
      set({ aiConnections: connections, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error fetching AI connections:", error);
    }
  },

  importPromptCards: async (userId, cards) => {
    set({ isLoading: true, error: null });
    try {
      const imported = await promptCardManager.importPromptCards(userId, cards);
      set((state) => ({
        promptCards: [...state.promptCards, ...imported],
        isLoading: false,
      }));
      return imported;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error importing prompt cards:", error);
      return [];
    }
  },

  exportPromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      const exported = await promptCardManager.exportPromptCard(userId, cardId);
      set({ isLoading: false });
      return exported;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error exporting prompt card:", error);
      return null;
    }
  },
}));
@@FILE: src/state/useSettingsStore.ts
// src/state/useSettingsStore.ts

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware'; // For persisting non-sensitive settings
import { AiConnection } from '../models/AiConnection';
import { gameRepository } from '../data/repositories/gameRepository'; // For AI connection persistence
import { generateUuid } from '../utils/uuid'; // For generating new connection IDs

interface SettingsState {
  // AI Connections
  aiConnections: AiConnection[];
  selectedConnectionId: string | null; // The currently selected AI connection for gameplay
  isLoadingConnections: boolean;
  connectionsError: string | null;

  // Global app settings
  useDummyNarrator: boolean;
  themeMode: 'light' | 'dark'; // Example for future theme setting

  // Actions
  fetchAiConnections: (userId: string) => Promise<void>;
  addAiConnection: (userId: string, connection: Omit<AiConnection, 'id' | 'createdAt' | 'lastUpdated'>) => Promise<AiConnection | null>;
  updateAiConnection: (userId: string, connection: AiConnection) => Promise<AiConnection | null>;
  deleteAiConnection: (userId: string, connectionId: string) => Promise<void>;
  setSelectedConnectionId: (id: string | null) => void;

  setUseDummyNarrator: (enabled: boolean) => void;
  setThemeMode: (mode: 'light' | 'dark') => void;
}

// Zustand store for application settings
export const useSettingsStore = create<SettingsState>()(
  persist(
    (set, get) => ({
      // Initial state for AI Connections
      aiConnections: [],
      selectedConnectionId: null,
      isLoadingConnections: false,
      connectionsError: null,

      // Initial state for other settings
      useDummyNarrator: false, // Default to false
      themeMode: 'light', // Default theme

      // Actions for AI Connections
      fetchAiConnections: async (userId) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const connections = await gameRepository.getAiConnections(userId);
          set({
            aiConnections: connections,
            isLoadingConnections: false,
            // If no connection is selected or the selected one is gone, pick the first one
            selectedConnectionId: get().selectedConnectionId && connections.some(c => c.id === get().selectedConnectionId)
              ? get().selectedConnectionId
              : (connections.length > 0 ? connections[0].id : null)
          });
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          console.error("Error fetching AI connections:", error);
        }
      },

      addAiConnection: async (userId, newConnectionData) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const newId = generateUuid();
          const now = new Date().toISOString();
          const connection: AiConnection = {
            ...newConnectionData,
            id: newId,
            createdAt: now,
            lastUpdated: now,
          };
          await gameRepository.saveAiConnection(userId, connection);
          set(state => {
            const updatedConnections = [...state.aiConnections, connection].sort((a, b) => a.displayName.localeCompare(b.displayName)); // Keep sorted
            return {
              aiConnections: updatedConnections,
              isLoadingConnections: false,
              selectedConnectionId: state.selectedConnectionId || newId // Auto-select if nothing selected
            };
          });
          return connection;
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          console.error("Error adding AI connection:", error);
          return null;
        }
      },

      updateAiConnection: async (userId, updatedConnection) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const now = new Date().toISOString();
          const connectionToSave = { ...updatedConnection, lastUpdated: now };
          await gameRepository.saveAiConnection(userId, connectionToSave);
          set(state => {
            const updatedConnections = state.aiConnections.map(conn =>
              conn.id === updatedConnection.id ? connectionToSave : conn
            ).sort((a, b) => a.displayName.localeCompare(b.displayName)); // Keep sorted
            return {
              aiConnections: updatedConnections,
              isLoadingConnections: false,
            };
          });
          return connectionToSave;
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          console.error("Error updating AI connection:", error);
          return null;
        }
      },

      deleteAiConnection: async (userId, connectionId) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          await gameRepository.deleteAiConnection(userId, connectionId);
          set(state => {
            const updatedConnections = state.aiConnections.filter(conn => conn.id !== connectionId);
            let newSelectedId = state.selectedConnectionId;
            if (newSelectedId === connectionId) {
                newSelectedId = updatedConnections.length > 0 ? updatedConnections[0].id : null;
            }
            return {
              aiConnections: updatedConnections.sort((a, b) => a.displayName.localeCompare(b.displayName)), // Keep sorted
              selectedConnectionId: newSelectedId,
              isLoadingConnections: false,
            };
          });
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          console.error("Error deleting AI connection:", error);
        }
      },

      setSelectedConnectionId: (id) => set({ selectedConnectionId: id }),

      // Actions for other settings
      setUseDummyNarrator: (enabled) => set({ useDummyNarrator: enabled }),
      setThemeMode: (mode) => set({ themeMode: mode }),
    }),
    {
      name: 'storyforge-app-settings', // Name of the storage item
      storage: createJSONStorage(() => localStorage), // Use localStorage
      partialize: (state) => ({ // Only persist non-sensitive or non-dynamic parts
        selectedConnectionId: state.selectedConnectionId,
        useDummyNarrator: state.useDummyNarrator,
        themeMode: state.themeMode,
        // aiConnections are fetched dynamically, not persisted directly via Zustand middleware
        // because they come from Firestore and might contain sensitive API keys.
        // We *do* store them in Firestore, but this `persist` middleware is for local-only settings.
      }),
      // Rehydration logic for aiConnections will be in fetchAiConnections.
    }
  )
);
@@FOLDER: src/ui
@@FOLDER: src/ui/components
@@FILE: src/ui/components/AiSettingsEditor.tsx
// src/ui/components/AiSettingsEditor.tsx

import React from 'react';
import {
  Box,
  Typography,
  Slider,
  Switch,
  FormControlLabel,
  Divider,
  TextField,
  MenuItem,
} from '@mui/material';
import { AiSettings, AiConnection } from '../../models/index';
import { CollapsibleSection } from './CollapsibleSection';

interface AiSettingsEditorProps {
  label: string;
  settings: AiSettings;
  onSettingsChange: (updatedSettings: AiSettings) => void;
  availableConnections: AiConnection[];
}

export const AiSettingsEditor: React.FC<AiSettingsEditorProps> = ({
  label,
  settings,
  onSettingsChange,
  availableConnections,
}) => {
  const handleSliderChange = (
    prop: keyof AiSettings,
    newValue: number | number[]
  ) => {
    onSettingsChange({ ...settings, [prop]: newValue as number });
  };

  const handleSwitchChange = (prop: keyof AiSettings, checked: boolean) => {
    onSettingsChange({ ...settings, [prop]: checked });
  };

  const handleConnectionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onSettingsChange({ ...settings, selectedConnectionId: event.target.value });
  };

  return (
    <CollapsibleSection title={label} initiallyExpanded={false}>
      <TextField
        select
        fullWidth
        label="AI Connection"
        value={settings.selectedConnectionId}
        onChange={handleConnectionChange}
        variant="outlined"
        sx={{ mb: 2 }}
      >
        {availableConnections.map((conn) => (
          <MenuItem key={conn.id} value={conn.id}>
            {conn.modelName} ({conn.id})
          </MenuItem>
        ))}
      </TextField>

      <Typography gutterBottom>
        Temperature: {settings.temperature.toFixed(2)}
      </Typography>
      <Slider
        value={settings.temperature}
        onChange={(_e, val) => handleSliderChange('temperature', val)}
        min={0.0}
        max={1.5}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls randomness. Low = logical, high = creative. RPG-optimal:
        0.7–1.0.
      </Typography>

      <Typography gutterBottom>Top P: {settings.topP.toFixed(2)}</Typography>
      <Slider
        value={settings.topP}
        onChange={(_e, val) => handleSliderChange('topP', val)}
        min={0.0}
        max={1.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls diversity. Lower = focused, higher = expressive. RPG-optimal:
        0.8–1.0.
      </Typography>

      <Typography gutterBottom>Max Tokens: {settings.maxTokens}</Typography>
      <Slider
        value={settings.maxTokens}
        onChange={(_e, val) => handleSliderChange('maxTokens', val)}
        min={256}
        max={8192}
        step={256}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Maximum length of AI reply. Longer = more story depth. RPG-optimal:
        1024–4096.
      </Typography>

      <Typography gutterBottom>
        Presence Penalty: {settings.presencePenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.presencePenalty}
        onChange={(_e, val) => handleSliderChange('presencePenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages introducing new topics repeatedly. RPG-optimal: 0.0–0.5.
      </Typography>

      <Typography gutterBottom>
        Frequency Penalty: {settings.frequencyPenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.frequencyPenalty}
        onChange={(_e, val) => handleSliderChange('frequencyPenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages repeating phrases. Helps avoid spam. RPG-optimal: 0.2–0.8.
      </Typography>

      <Divider sx={{ my: 2 }} />

      <FormControlLabel
        control={
          <Switch
            checked={settings.functionCallingEnabled}
            onChange={(e) =>
              handleSwitchChange('functionCallingEnabled', e.target.checked)
            }
          />
        }
        label="Enable Function Calling"
      />
      <Typography variant="body2" color="text.secondary">
        Allows AI to call structured functions (if you've defined them in the
        prompt).
      </Typography>
    </CollapsibleSection>
  );
};
@@FILE: src/ui/components/CollapsibleLogEntry.tsx
// src/ui/components/CollapsibleLogEntry.tsx

import React from 'react';
import { Box, Typography, Divider } from '@mui/material';
import { LogEntry } from '../../models/LogEntry';
import { LogViewMode } from '../../utils/types';
import { CollapsibleSection } from './CollapsibleSection';
import { LogEntryDisplay } from './LogEntryDisplay';

interface CollapsibleLogEntryProps {
  entry: LogEntry;
  selectedLogViewModes: LogViewMode[];
}

export const CollapsibleLogEntry: React.FC<CollapsibleLogEntryProps> = ({ entry, selectedLogViewModes }) => {
  // Determine if there's any content to show based on selected modes
  const hasContent = selectedLogViewModes.some(mode => {
    switch (mode) {
      case LogViewMode.NARRATOR_OUTPUT: return !!entry.narratorOutput;
      case LogViewMode.USER_INPUT: return !!entry.userInput;
      case LogViewMode.DIGEST_LINES: return (entry.digestLines?.length || 0) > 0;
      case LogViewMode.DELTAS: return entry.deltas && Object.keys(entry.deltas).length > 0;
      case LogViewMode.CONTEXT_SNAPSHOT: return !!entry.contextSnapshot;
      case LogViewMode.TOKEN_USAGE: return !!entry.tokenUsage;
      case LogViewMode.AI_SETTINGS: return !!entry.aiSettings;
      case LogViewMode.API_DETAILS: return !!entry.apiUrl || !!entry.modelSlugUsed || entry.latencyMs !== null;
      case LogViewMode.ERROR_FLAGS: return (entry.errorFlags?.length || 0) > 0;
      case LogViewMode.MODEL_SLUG_USED: return !!entry.modelSlugUsed;
      default: return false;
    }
  });

  if (!hasContent) {
    // Optionally return null or a placeholder if no content is selected to display
    // For now, if the main entry title is desired even without content, keep rendering.
    // If you want to hide the whole entry if nothing is selected, uncomment below.
    // return null;
  }

  return (
    <CollapsibleSection
      title={`Turn ${entry.turnNumber} - ${new Date(entry.timestamp).toLocaleTimeString()}`}
      initiallyExpanded={entry.turnNumber === 0} // Expand Turn 0 by default
    >
      <Box sx={{ p: 1 }}>
        {selectedLogViewModes.length === 0 ? (
          <Typography variant="body2" color="text.secondary">
            No log view modes selected for this entry. Please select modes from the "Log Views" menu.
          </Typography>
        ) : (
          selectedLogViewModes.map((mode, index) => (
            <React.Fragment key={mode}>
              <CollapsibleSection title={mode} initiallyExpanded={true}> {/* Inner collapsible for each mode */}
                <LogEntryDisplay mode={mode} entry={entry} hideTurnInfo={true} />
              </CollapsibleSection>
              {index < selectedLogViewModes.length - 1 && <Divider sx={{ my: 1 }} />}
            </React.Fragment>
          ))
        )}
      </Box>
    </CollapsibleSection>
  );
};
@@FILE: src/ui/components/CollapsibleSection.tsx
// src/ui/components/CollapsibleSection.tsx

import React from 'react';
import {
  Card,
  CardContent,
  Typography,
  IconButton,
  Collapse,
  Box,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';

interface CollapsibleSectionProps {
  title: string;
  children: React.ReactNode;
  initiallyExpanded?: boolean;
}

export const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  children,
  initiallyExpanded = false,
}) => {
  const [expanded, setExpanded] = React.useState(initiallyExpanded);

  const handleExpandClick = () => {
    setExpanded(!expanded);
  };

  return (
    <Card variant="outlined" sx={{ mb: 2 }}>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1.5,
          cursor: 'pointer',
          '&:hover': {
            backgroundColor: (theme) => theme.palette.action.hover,
          },
        }}
        onClick={handleExpandClick}
      >
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
        </Typography>
        <IconButton
          onClick={handleExpandClick}
          aria-expanded={expanded}
          aria-label="show more"
          size="small"
        >
          {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
      </Box>
      <Collapse in={expanded} timeout="auto" unmountOnExit>
        <CardContent sx={{ pt: 1 }}>{children}</CardContent>
      </Collapse>
    </Card>
  );
};
@@FILE: src/ui/components/InfoDialog.tsx
// src/ui/components/InfoDialog.tsx

import React, { useState } from 'react';
import { Dialog, DialogTitle, DialogContent, DialogActions, Button, IconButton, Tooltip, Box } from '@mui/material';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';

interface InfoDialogProps {
  title: string;
  content: string | React.ReactNode; // Can be a string or JSX
  iconSize?: 'small' | 'medium' | 'large';
  tooltipText?: string; // Optional text for the initial hover tooltip
}

export const InfoDialog: React.FC<InfoDialogProps> = ({ title, content, iconSize = 'small', tooltipText = "Click for more information" }) => {
  const [open, setOpen] = useState(false);

  const handleClickOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <>
      <Tooltip title={tooltipText}>
        <IconButton size={iconSize} onClick={handleClickOpen} sx={{ ml: 0.5, p: 0 }}>
          <InfoOutlinedIcon fontSize="small" />
        </IconButton>
      </Tooltip>
      <Dialog
        open={open}
        onClose={handleClose}
        aria-labelledby="info-dialog-title"
        fullWidth
        maxWidth="sm"
      >
        <DialogTitle id="info-dialog-title">{title}</DialogTitle>
        <DialogContent dividers>
          {/* Use Box with pre-wrap to respect line breaks in string content */}
          {typeof content === 'string' ? <Box sx={{ whiteSpace: 'pre-wrap' }}>{content}</Box> : content}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Close</Button>
        </DialogActions>
      </Dialog>
    </>
  );
};
@@FILE: src/ui/components/LogEntryDisplay.tsx
// src/ui/components/LogEntryDisplay.tsx

import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
import { LogEntry } from '../../models/LogEntry';
import { LogViewMode } from '../../utils/types';

interface LogEntryDisplayProps {
 mode: LogViewMode;
 entry: LogEntry;
 hideTurnInfo?: boolean; // New optional prop
}

export const LogEntryDisplay: React.FC<LogEntryDisplayProps> = ({ mode, entry, hideTurnInfo }) => {
 const renderContent = () => {
  switch (mode) {
   case LogViewMode.NARRATOR_OUTPUT:
    return entry.narratorOutput;
   case LogViewMode.USER_INPUT:
    return entry.userInput;
   case LogViewMode.DIGEST_LINES:
    // MODIFIED: Use `d.importance` which should now be correct
    return entry.digestLines.map(d => `${d.text} (Imp: ${d.importance})`).join('\n');
   case LogViewMode.DELTAS:
    return entry.deltas ? JSON.stringify(entry.deltas, null, 2) : 'No Deltas';
   case LogViewMode.CONTEXT_SNAPSHOT:
    return entry.contextSnapshot ? entry.contextSnapshot : 'No Context Snapshot';
   case LogViewMode.TOKEN_USAGE:
    return entry.tokenUsage ? `Input: ${entry.tokenUsage.inputTokens}, Output: ${entry.tokenUsage.outputTokens}, Total: ${entry.tokenUsage.totalTokens}` : 'No Token Usage Info';
   case LogViewMode.AI_SETTINGS:
    return entry.aiSettings ? JSON.stringify(entry.aiSettings, null, 2) : 'No AI Settings';
   case LogViewMode.API_DETAILS: {
      // MODIFIED: Build a more detailed API details string
     const details = [
      `URL: ${entry.apiUrl || 'N/A'}`,
      `Model: ${entry.modelSlugUsed || 'N/A'}`,
      `Latency: ${entry.latencyMs !== null ? `${entry.latencyMs}ms` : 'N/A'}`,
     ];
      if (entry.apiRequestBody) {
        details.push(`\n--- Request Body (without content) ---\n${entry.apiRequestBody}`);
      }
      if (entry.apiResponseBody) {
        details.push(`\n--- Response Body ---\n${entry.apiResponseBody}`);
      }
      return details.join('\n');
    }
   case LogViewMode.ERROR_FLAGS:
    return entry.errorFlags && entry.errorFlags.length > 0 ? entry.errorFlags.join(', ') : 'No Errors';
   case LogViewMode.MODEL_SLUG_USED:
     return entry.modelSlugUsed || 'N/A';
   default:
    return 'Select a view mode.';
  }
 };

  return (
    <Box sx={{ mb: 1.5 }}>
      {/* Conditionally render turn info based on new prop */}
      {!hideTurnInfo && (
        <Typography variant="caption" color="text.secondary">
          Turn {entry.turnNumber} - {new Date(entry.timestamp).toLocaleTimeString()}
        </Typography>
      )}
      <Typography variant="body2" component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word', mt: 0.5 }}>
        {renderContent()}
      </Typography>
    </Box>
  );
};
@@FILE: src/ui/components/LogView.tsx
// src/ui/components/LogView.tsx

import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
// MODIFIED: Import Message model instead of LogEntry
import { Message } from '../../models/Message';

interface LogViewProps {
 // MODIFIED: Expect conversationHistory of type Message[]
 conversationHistory: Message[];
}

export const LogView: React.FC<LogViewProps> = ({ conversationHistory }) => {
 return (
  <Box sx={{ flexGrow: 1, overflowY: 'auto' }}>
   {conversationHistory.length === 0 ? (
    <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mt: 4 }}>
     The story begins...
    </Typography>
   ) : (
    // MODIFIED: Map over conversationHistory
    conversationHistory.map((message, index) => (
     <Paper key={index} elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
      {message.role === 'user' ? (
       <>
        <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.primary.dark }}>
         You:
        </Typography>
        <Typography variant="body1" sx={{ mb: 1 }}>
         {message.content}
        </Typography>
       </>
      ) : message.role === 'assistant' ? (
       <>
        <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
         AI Narrator:
        </Typography>
        <Typography variant="body1">
         {message.content}
        </Typography>
       </>
        ) : null}
     </Paper>
    ))
   )}
  </Box>
 );
};
@@FILE: src/ui/components/PinnedAttributeChip.tsx
// src/ui/components/PinnedAttributeChip.tsx

import React from 'react'; // Keep React import
import { Chip, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';

interface PinnedAttributeChipProps {
  fullKey: string;
  label: string;
  value: any;
  onUnpin: (key: string) => void;
}

// Wrap the component with React.memo

export const PinnedAttributeChip: React.FC<PinnedAttributeChipProps> = React.memo(({
  fullKey,
  label,
  value,
  onUnpin,
}) => {
  console.log(`[PinnedAttributeChip:${fullKey}] Rendering/Re-rendering.`);

  const longPressProps = useLongPress((e) => {
    e.stopPropagation(); // Double safety — ensures no parent listener fires
    console.log(`[PinnedAttributeChip] Long-pressed individual variable: "${fullKey}". Calling onUnpin (unpinIndividualVariable).`);
    onUnpin(fullKey);
  });

  return (
    <Tooltip title={`Long-press to unpin '${label}'`} key={fullKey}>
      <Chip
        label={`${label}: ${JSON.stringify(value)}`}
        size="small"
        deleteIcon={<PushPinIcon />}
        sx={{
          backgroundColor: (theme) => theme.palette.background.paper,
          color: (theme) => theme.palette.text.primary,
          cursor: 'pointer',
          '& .MuiChip-deleteIcon': {
            opacity: 0.2,
          },
          '&:hover .MuiChip-deleteIcon': {
            opacity: 1,
          },
        }}
        {...longPressProps}
      />
    </Tooltip>
  );
});
@@FILE: src/ui/components/PinnedEntityGroup.tsx
// src/ui/components/PinnedEntityGroup.tsx

import React from 'react';
import { Paper, Typography, Stack, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';
import { PinnedAttributeChip } from './PinnedAttributeChip';

interface Attribute {
  label: string;
  value: any;
  fullKey: string;
}

interface PinnedEntityGroupProps {
  entityPath: string;
  attributes: Attribute[];
  onUnpinEntity: (path: string) => void;
  onUnpinVariable: (key: string) => void;
}

export const PinnedEntityGroup: React.FC<PinnedEntityGroupProps> = ({
  entityPath,
  attributes,
  onUnpinEntity,
  onUnpinVariable, // This prop is passed down but also available here
}) => {
  const longPressEntityProps = useLongPress(() => {
    console.log(`[PinnedEntityGroup] Long-pressed entity header: "${entityPath}". Calling onUnpinEntity.`);
    onUnpinEntity(entityPath);
  });

  const entityDisplayName = entityPath.includes('.')
    ? entityPath.split('.').pop()?.replace(/^[#@$]/, '')
    : entityPath;

  return (
    <Paper
      elevation={3}
      sx={{
        p: 1.5,
        minWidth: 150,
        backgroundColor: (theme) => theme.palette.primary.light,
        color: (theme) => theme.palette.primary.contrastText,
        flexShrink: 0,
        cursor: 'pointer',
      }}
      {...longPressEntityProps}
    >
      <Typography variant="subtitle2" sx={{ fontWeight: 'bold' }}>
        {entityDisplayName}
        <Tooltip title="Long-press to unpin all for this group">
          <PushPinIcon fontSize="small" sx={{ verticalAlign: 'middle', ml: 0.5 }} />
        </Tooltip>
      </Typography>
      <Stack direction="column" spacing={0.5} sx={{ mt: 1 }}>
        {attributes.map(attr => (
          <PinnedAttributeChip
            key={attr.fullKey}
            fullKey={attr.fullKey}
            label={attr.label}
            value={attr.value}
            onUnpin={onUnpinVariable} // This is correct, passing the specific unpin variable function
          />
        ))}
      </Stack>
    </Paper>
  );
};
@@FILE: src/ui/components/PinnedItemsView.tsx
// src/ui/components/PinnedItemsView.tsx

import React, { useEffect } from 'react';
import { Box, Typography, Paper, Stack } from '@mui/material';
import { GameState } from '../../models/GameState';
import { useGameStateStore } from '../../state/useGameStateStore';
import { flattenJsonObject, getNestedValue } from '../../utils/jsonUtils'; // Ensure getNestedValue is imported
import { PinnedEntityGroup } from './PinnedEntityGroup';

interface PinnedItemsViewProps {
  gameState: GameState;
}

export const PinnedItemsView: React.FC<PinnedItemsViewProps> = ({ gameState }) => {
  // Directly select worldStatePinnedKeys and the actions from the store
  // Make sure currentGameState is destructured here if you use it in the component's render or memoized values.
  const { worldStatePinnedKeys, unpinAllForEntity, unpinIndividualVariable } = useGameStateStore();

  // IMPORTANT: Ensure this `worldState` is the actual, current GameState from the prop.
  // We're relying on `gameState` prop being updated by GameScreen
  const worldState = gameState?.worldState || {};

  // Memoize the flattened world state. This should only re-run if the gameState.worldState object reference changes.
  const flattenedWorld = React.useMemo(() => {
    return flattenJsonObject(worldState);
  }, [worldState]); // Depend on the worldState object itself


  // Memoize the list of items to be displayed (key-value pairs)
  // This is the array that feeds into the grouping logic.
  const pinnedItems = React.useMemo(() => {
    // Filter `worldStatePinnedKeys` directly from the store based on `flattenedWorld`'s existence
    const items = worldStatePinnedKeys
      .map(key => ({
        key,
        value: flattenedWorld[key], // Access value from the memoized flattened object
      }))
      .filter(item => {
          // This filter is critical. An item should only be considered if its value is not undefined.
          // This handles cases where a pinned item might no longer exist in the worldState.
          return item.value !== undefined;
      });

      console.log("[PinnedItemsView:pinnedItems] Calculated pinnedItems. Length:", items.length, "Items:", items);
      return items;
  }, [worldStatePinnedKeys, flattenedWorld]); // Depend on both for re-calculation

  // Grouped pinned items logic
  const groupedPinnedItems = React.useMemo(() => {
    const grouped: { [entityPath: string]: { label: string; value: any; fullKey: string }[] } = {};
    pinnedItems.forEach(item => {
      const parts = item.key.split('.');
      if (parts.length >= 2) {
        const secondPart = parts[1];
        const isTaggedEntity = secondPart.startsWith('#') || secondPart.startsWith('@') || secondPart.startsWith('$');
        let entityPath: string;
        let label: string;

        if (parts.length >= 3 && isTaggedEntity) {
          entityPath = parts.slice(0, 2).join('.');
          label = parts.slice(2).join('.');
        } else {
          entityPath = parts[0];
          label = parts.slice(1).join('.');
        }

        // This fallback might have been the source of the 31 vs 32 discrepancy if a root-level key was accidentally pinned as a variable
        // but based on your logs, all pinned keys seem deeply nested. Let's keep it robust.
        if (label === '') {
          label = parts[parts.length - 1]; // Fallback, e.g., if key is "world"
        }

        grouped[entityPath] = grouped[entityPath] || [];
        grouped[entityPath].push({ label, value: item.value, fullKey: item.key });
      }
    });
    // Sort attributes within each group for consistent rendering
    Object.keys(grouped).forEach(entityPath => {
      grouped[entityPath].sort((a, b) => a.label.localeCompare(b.label));
    });
    console.log("[PinnedItemsView] Grouped Pinned Items (re-calculated):", grouped); // Updated log message
    return grouped;
  }, [pinnedItems]); // Recalculate if pinnedItems array changes

  // Logging effect for re-renders and key count
  useEffect(() => {
    console.log("[PinnedItemsView] Component re-rendered. Current worldStatePinnedKeys (from store):", worldStatePinnedKeys);
    console.log("[PinnedItemsView] Number of pinned keys (from store):", worldStatePinnedKeys.length);
    console.log("[PinnedItemsView] Number of calculated pinnedItems (filtered):", pinnedItems.length);
    console.log("[PinnedItemsView] Number of grouped entities:", Object.keys(groupedPinnedItems).length);
    let totalGroupedItems = 0;
    Object.values(groupedPinnedItems).forEach(arr => totalGroupedItems += arr.length);
    console.log("[PinnedItemsView] Total items in groupedPinnedItems:", totalGroupedItems);

  }, [worldStatePinnedKeys, pinnedItems, groupedPinnedItems]); // Added pinnedItems to dependency

  if (pinnedItems.length === 0) { // Check length of `pinnedItems` (the filtered list)
    return (
      <Paper elevation={0} sx={{ p: 1.5, mt: 1, backgroundColor: (theme) => theme.palette.background.default }}>
        <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
          No items pinned. Right-click or long-press items in the World State screen to pin them here.
        </Typography>
      </Paper>
    );
  }

  return (
    <Stack
      direction="row"
      spacing={2}
      sx={{
        py: 1,
        overflowX: 'auto',
        backgroundColor: 'transparent',
      }}
    >
      {Object.entries(groupedPinnedItems).map(([entityPath, attributes]) => (
        <PinnedEntityGroup
          key={entityPath} // Keying by entityPath is correct for entity groups
          entityPath={entityPath}
          attributes={attributes}
          onUnpinEntity={unpinAllForEntity}
          onUnpinVariable={unpinIndividualVariable}
        />
      ))}
    </Stack>
  );
};
@@FILE: src/ui/components/StackInstructionsEditor.tsx
// src/ui/components/StackInstructionsEditor.tsx

import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  FormLabel,
  RadioGroup,
  FormControlLabel,
  Radio,
  InputLabel,
  Select,
  MenuItem,
  Grid,
  Checkbox,
  Divider,
  Switch,
} from '@mui/material';
import { CollapsibleSection } from './CollapsibleSection';
import { StackInstructions, StackMode, FilterMode, EmissionRule, ProsePolicy, DigestFilterPolicy } from '../../models/StackInstructions';
import { InfoDialog } from './InfoDialog';

interface StackInstructionsEditorProps {
  stackInstructions: StackInstructions;
  onStackInstructionsChange: (updatedInstructions: StackInstructions) => void;
}

const StackInstructionsEditor: React.FC<StackInstructionsEditorProps> = ({
  stackInstructions,
  onStackInstructionsChange,
}) => {
  // Helper to update a policy (ProsePolicy, DigestFilterPolicy, EmissionRule)
  const handlePolicyChange = (
    policyKey: keyof StackInstructions,
    field: keyof ProsePolicy | keyof EmissionRule | keyof DigestFilterPolicy,
    value: any
  ) => {
    onStackInstructionsChange({
      ...stackInstructions,
      [policyKey]: { ...(stackInstructions[policyKey] as any), [field]: value },
    });
  };

  const handleDigestEmissionChange = (
    score: number,
    field: keyof EmissionRule,
    value: any
  ) => {
    const currentRule = stackInstructions.digestEmission[score] || { mode: StackMode.NEVER, n: 0 };
    onStackInstructionsChange({
      ...stackInstructions,
      digestEmission: {
        ...stackInstructions.digestEmission,
        [score]: { ...currentRule, [field]: value },
      },
    });
  };

  const handleTokenPolicyChange = (
    field: keyof StackInstructions['tokenPolicy'],
    value: any
  ) => {
    onStackInstructionsChange({
      ...stackInstructions,
      tokenPolicy: { ...stackInstructions.tokenPolicy, [field]: value },
    });
  };

  // Generic toggle for enabled state of a policy
  const handleToggleEnable = (policyName: keyof StackInstructions) => {
    const currentPolicy = stackInstructions[policyName] as ProsePolicy | DigestFilterPolicy;
    onStackInstructionsChange({
      ...stackInstructions,
      [policyName]: { ...currentPolicy, enabled: !currentPolicy.enabled },
    });
  };

  return (
    <CollapsibleSection title="🧠 Stack Instructions" initiallyExpanded={false}>
      <Box sx={{ mb: 3 }}>
        <Typography variant="body2" color="text.secondary">
          These settings control how previous game information (the 'context stack') is assembled
          and presented to the AI for each new turn.
          <InfoDialog
            title="Understanding the Context Stack"
            content={`The AI's 'memory' for each turn is built from a 'context stack' of information. This stack is essentially a list of messages sent to the AI, preceding your current input.

The **order** in which these elements are presented to the AI can significantly impact its responses and adherence to rules. Generally, more important and structured information (like world state and rules) should come earlier in the stack, followed by dynamic elements (like logs and conversation history).

Each section below can be individually enabled/disabled using the toggle switches. If a section is disabled, it will not be included in the AI's prompt for subsequent turns, saving tokens but potentially reducing AI's context.`}
          />
        </Typography>
      </Box>

      {/* Narrator Prose Emission */}
      <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            Narrator Prose Emission
          </Typography>
          <FormControlLabel
            control={
              <Switch
                checked={stackInstructions.narratorProseEmission.enabled || false}
                onChange={() => handleToggleEnable('narratorProseEmission')}
              />
            }
            label="Enable"
            labelPlacement="start"
          />
        </Box>
        <Box sx={{ opacity: stackInstructions.narratorProseEmission.enabled ? 1 : 0.5, pointerEvents: stackInstructions.narratorProseEmission.enabled ? 'auto' : 'none' }}>
          <Typography gutterBottom>
            Mode
            <InfoDialog
              title="Narrator Prose Emission Mode"
              content={`Controls how past narrator output (the main story text) is included in the AI's context.

- ALWAYS: Include all past narrator prose.
- FIRST_N: Include prose only from the first 'N' turns.
- AFTER_N: Include prose only from turns after 'N'.
- NEVER: Do not include any past narrator prose.`}
            />
          </Typography>
          <FormControl component="fieldset" fullWidth margin="normal">
            <RadioGroup
              row
              value={stackInstructions.narratorProseEmission.mode}
              onChange={(e) =>
                handlePolicyChange('narratorProseEmission', 'mode', e.target.value as StackMode)
              }
            >
              {Object.values(StackMode).map((mode) => (
                <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
              ))}
            </RadioGroup>
            {(stackInstructions.narratorProseEmission.mode === StackMode.FIRST_N ||
              stackInstructions.narratorProseEmission.mode === StackMode.AFTER_N) && (
                <TextField
                  label="N (Turns)"
                  type="number"
                  value={stackInstructions.narratorProseEmission.n}
                  onChange={(e) => handlePolicyChange('narratorProseEmission', 'n', parseInt(e.target.value))}
                  sx={{ mt: 1, width: '150px' }}
                  inputProps={{ min: 0 }}
                />
              )}
            <Typography gutterBottom sx={{ mt: 2 }}>
              Filtering
              <InfoDialog
                title="Narrator Prose Filtering"
                content={`Filters which narrator prose lines are included based on their content or associated tags.

- NONE: Include all prose based on the selected mode.
- SCENE_ONLY: Only include prose that contains tags (e.g., #character, @location) relevant to the current scene.
- TAGGED: Only include prose that contains any recognized tags (any #, @, or $ tag).`}
              />
            </Typography>
            <FormControl fullWidth>
              <InputLabel id="narrator-filtering-label">Filtering</InputLabel>
              <Select
                labelId="narrator-filtering-label"
                value={stackInstructions.narratorProseEmission.filtering}
                label="Filtering"
                onChange={(e) =>
                  handlePolicyChange('narratorProseEmission', 'filtering', e.target.value as FilterMode)
                }
              >
                {Object.values(FilterMode).map((mode) => (
                  <MenuItem key={mode} value={mode}>
                    {mode}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </FormControl>
        </Box>
      </Box>

      <Divider sx={{ my: 3 }} />

      {/* Digest Lines Emission & Policy */}
      <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            Digest Lines Emission & Policy
          </Typography>
          <FormControlLabel
            control={
              <Switch
                checked={stackInstructions.digestPolicy.enabled || false}
                onChange={() => handleToggleEnable('digestPolicy')}
              />
            }
            label="Enable"
            labelPlacement="start"
          />
        </Box>
        <Box sx={{ opacity: stackInstructions.digestPolicy.enabled ? 1 : 0.5, pointerEvents: stackInstructions.digestPolicy.enabled ? 'auto' : 'none' }}>
          <Typography gutterBottom>
            Global Digest Filtering Policy
            <InfoDialog
              title="Global Digest Filtering Policy"
              content={`Applies a filter to ALL digest lines before their individual emission rules are checked.

- NONE: No global filtering, all digests are considered.
- SCENE_ONLY: Only consider digests that contain tags (e.g., #character, @location) relevant to the current scene.
- TAGGED: Only consider digests that have any recognized tags.`}
            />
          </Typography>
          <FormControl component="fieldset" fullWidth margin="normal">
            <RadioGroup
              row
              value={stackInstructions.digestPolicy.filtering}
              onChange={(e) => handlePolicyChange('digestPolicy', 'filtering', e.target.value as FilterMode)}
            >
              {Object.values(FilterMode).map((mode) => (
                <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
              ))}
            </RadioGroup>
          </FormControl>

          <Grid container spacing={2} sx={{ mb: 2 }}>
            {[5, 4, 3, 2, 1].map((score) => (
              <Grid item xs={12} sm={6} md={4} key={score}>
                <Box sx={{ border: '1px solid #ccc', p: 1.5, borderRadius: 1 }}>
                  <Typography variant="subtitle2">
                    Importance {score} Digests
                    <InfoDialog
                      title={`Digest Importance Score ${score} Rule`}
                      content={`Determines how digest lines with an importance score of ${score} are included in the AI's context. Higher scores are more critical events.

- ALWAYS: Include all digests of this score.
- FIRST_N: Include digests of this score only from the first 'N' turns.
- AFTER_N: Include digests of this score only from turns after 'N'.
- NEVER: Do not include any digests of this score.`}
                    />
                  </Typography>
                  <FormControl component="fieldset" fullWidth size="small">
                    <RadioGroup
                      row
                      value={stackInstructions.digestEmission[score]?.mode || StackMode.NEVER}
                      onChange={(e) =>
                        handleDigestEmissionChange(score, 'mode', e.target.value as StackMode)
                      }
                    >
                      {Object.values(StackMode).map((mode) => (
                        <FormControlLabel key={mode} value={mode} control={<Radio size="small" />} label={mode} />
                      ))}
                    </RadioGroup>
                    {(stackInstructions.digestEmission[score]?.mode === StackMode.FIRST_N ||
                      stackInstructions.digestEmission[score]?.mode === StackMode.AFTER_N) && (
                        <TextField
                          label="N"
                          type="number"
                          value={stackInstructions.digestEmission[score]?.n || 0}
                          onChange={(e) => handleDigestEmissionChange(score, 'n', parseInt(e.target.value))}
                          size="small"
                          sx={{ mt: 1, width: '100px' }}
                          inputProps={{ min: 0 }}
                        />
                      )}
                  </FormControl>
                </Box>
              </Grid>
            ))}
          </Grid>
        </Box>
      </Box>

      <Divider sx={{ my: 3 }} />

      {/* Expression Log Policy */}
      <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            Expression Log Policy
          </Typography>
          <FormControlLabel
            control={
              <Switch
                checked={stackInstructions.expressionLogPolicy.enabled || false}
                onChange={() => handleToggleEnable('expressionLogPolicy')}
              />
            }
            label="Enable"
            labelPlacement="start"
          />
        </Box>
        <Box sx={{ opacity: stackInstructions.expressionLogPolicy.enabled ? 1 : 0.5, pointerEvents: stackInstructions.expressionLogPolicy.enabled ? 'auto' : 'none' }}>
          <Typography gutterBottom>
            Mode
            <InfoDialog
              title="Expression Log Mode"
              content={`Controls how character 'expression' (portions of past narrator prose related to character actions/emotions) is included.

- ALWAYS: Include all relevant expression logs.
- FIRST_N: Include expression logs only from the first 'N' turns.
- AFTER_N: Include expression logs only from turns after 'N'.
- NEVER: Do not include any expression logs.`}
            />
          </Typography>
          <FormControl component="fieldset" fullWidth margin="normal">
            <RadioGroup
              row
              value={stackInstructions.expressionLogPolicy.mode}
              onChange={(e) =>
                handlePolicyChange('expressionLogPolicy', 'mode', e.target.value as StackMode)
              }
            >
              {Object.values(StackMode).map((mode) => (
                <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
              ))}
            </RadioGroup>
            {(stackInstructions.expressionLogPolicy.mode === StackMode.FIRST_N ||
              stackInstructions.expressionLogPolicy.mode === StackMode.AFTER_N) && (
                <TextField
                  label="N (Turns)"
                  type="number"
                  value={stackInstructions.expressionLogPolicy.n}
                  onChange={(e) => handlePolicyChange('expressionLogPolicy', 'n', parseInt(e.target.value))}
                  sx={{ mt: 1, width: '150px' }}
                  inputProps={{ min: 0 }}
                />
              )}
            <Typography gutterBottom sx={{ mt: 2 }}>
              Filtering
              <InfoDialog
                title="Expression Log Filtering"
                content={`Filters which expression logs are included based on their content or associated tags.

- NONE: Include all expression logs based on the selected mode.
- SCENE_ONLY: Only include expression logs that contain tags relevant to the current scene.
- TAGGED: Only include expression logs that contain any recognized tags.`}
              />
            </Typography>
            <FormControl fullWidth sx={{ mt: 2 }}>
              <InputLabel id="expression-filtering-label">Filtering</InputLabel>
              <Select
                labelId="expression-filtering-label"
                value={stackInstructions.expressionLogPolicy.filtering}
                label="Filtering"
                onChange={(e) =>
                  handlePolicyChange('expressionLogPolicy', 'filtering', e.target.value as FilterMode)
                }
              >
                {Object.values(FilterMode).map((mode) => (
                  <MenuItem key={mode} value={mode}>
                    {mode}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </FormControl>
          <TextField
            fullWidth
            label={
              <>
                Expression Lines Per Character
                <InfoDialog
                  title="Expression Lines Per Character"
                  content="The maximum number of lines of narrative prose to extract and summarize for character expressions. A higher number provides more detail but uses more tokens."
                />
              </>
            }
            type="number"
            value={stackInstructions.expressionLinesPerCharacter}
            onChange={(e) => onStackInstructionsChange({ ...stackInstructions, expressionLinesPerCharacter: parseInt(e.target.value) })}
            sx={{ mb: 2, width: '250px' }}
            inputProps={{ min: 0 }}
          />
          <FormControlLabel
            control={
              <Checkbox
                checked={stackInstructions.emotionWeighting}
                onChange={(e) => onStackInstructionsChange({ ...stackInstructions, emotionWeighting: e.target.checked })}
              />
            }
            label={
              <>
                Emotion Weighting
                <InfoDialog
                  title="Emotion Weighting"
                  content="If enabled, the system attempts to prioritize or emphasize narrative elements related to character emotions when building the context, potentially influencing AI's empathetic responses."
                />
              </>
            }
          />
        </Box>
      </Box>

      <Divider sx={{ my: 3 }} />

      {/* World State Policy */}
      <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            World State Policy
          </Typography>
          <FormControlLabel
            control={
              <Switch
                checked={stackInstructions.worldStatePolicy.enabled || false}
                onChange={() => handleToggleEnable('worldStatePolicy')}
              />
            }
            label="Enable"
            labelPlacement="start"
          />
        </Box>
        <Box sx={{ opacity: stackInstructions.worldStatePolicy.enabled ? 1 : 0.5, pointerEvents: stackInstructions.worldStatePolicy.enabled ? 'auto' : 'none' }}>
          <Typography gutterBottom>
            Mode
            <InfoDialog
              title="World State Policy Mode"
              content={`Controls how the current world state JSON is included in the AI's context.

- ALWAYS: Include the full current world state.
- FILTERED: Include only parts of the world state (e.g., pinned items or scene-relevant data). This requires proper filtering logic in the system.
- NEVER: Do not include any world state.`}
            />
          </Typography>
          <FormControl component="fieldset" fullWidth margin="normal">
            <RadioGroup
              row
              value={stackInstructions.worldStatePolicy.mode}
              onChange={(e) =>
                handlePolicyChange('worldStatePolicy', 'mode', e.target.value as StackMode)
              }
            >
              {Object.values(StackMode).map((mode) => (
                <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
              ))}
            </RadioGroup>
            {(stackInstructions.worldStatePolicy.mode === StackMode.FIRST_N ||
              stackInstructions.worldStatePolicy.mode === StackMode.AFTER_N) && (
                <TextField
                  label="N (Items/Count)"
                  type="number"
                  value={stackInstructions.worldStatePolicy.n}
                  onChange={(e) => handlePolicyChange('worldStatePolicy', 'n', parseInt(e.target.value))}
                  sx={{ mt: 1, width: '150px' }}
                  inputProps={{ min: 0 }}
                />
              )}
            <Typography gutterBottom sx={{ mt: 2 }}>
              Filtering
              <InfoDialog
                title="World State Filtering"
                content={`Filters which parts of the world state are included.

- NONE: Include all world state data based on the selected mode.
- SCENE_ONLY: Include only world state data directly related to entities present in the current scene.
- TAGGED: Include only world state data for entities that have tags.`}
              />
            </Typography>
            <FormControl fullWidth sx={{ mt: 2 }}>
              <InputLabel id="worldstate-filtering-label">Filtering</InputLabel>
              <Select
                labelId="worldstate-filtering-label"
                value={stackInstructions.worldStatePolicy.filtering}
                label="Filtering"
                onChange={(e) =>
                  handlePolicyChange('worldStatePolicy', 'filtering', e.target.value as FilterMode)
                }
              >
                {Object.values(FilterMode).map((mode) => (
                  <MenuItem key={mode} value={mode}>
                    {mode}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </FormControl>
        </Box>
      </Box>

      <Divider sx={{ my: 3 }} />

      {/* Known Entities Policy */}
      <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            Known Entities Policy
          </Typography>
          <FormControlLabel
            control={
              <Switch
                checked={stackInstructions.knownEntitiesPolicy.enabled || false}
                onChange={() => handleToggleEnable('knownEntitiesPolicy')}
              />
            }
            label="Enable"
            labelPlacement="start"
          />
        </Box>
        <Box sx={{ opacity: stackInstructions.knownEntitiesPolicy.enabled ? 1 : 0.5, pointerEvents: stackInstructions.knownEntitiesPolicy.enabled ? 'auto' : 'none' }}>
          <Typography gutterBottom>
            Mode
            <InfoDialog
              title="Known Entities Policy Mode"
              content={`Controls how a list of 'known entities' (tagged items, characters, locations from world state) is included. This list reminds the AI of important things without sending the full world state.

- ALWAYS: Include all known entities.
- FIRST_N: Include known entities up to the 'N'th entity discovered.
- AFTER_N: Include known entities discovered after the 'N'th entity.
- NEVER: Do not include known entities.`}
            />
          </Typography>
          <FormControl component="fieldset" fullWidth margin="normal">
            <RadioGroup
              row
              value={stackInstructions.knownEntitiesPolicy.mode}
              onChange={(e) =>
                handlePolicyChange('knownEntitiesPolicy', 'mode', e.target.value as StackMode)
              }
            >
              {Object.values(StackMode).map((mode) => (
                <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
              ))}
            </RadioGroup>
            {(stackInstructions.knownEntitiesPolicy.mode === StackMode.FIRST_N ||
              stackInstructions.knownEntitiesPolicy.mode === StackMode.AFTER_N) && (
                <TextField
                  label="N (Entities)"
                  type="number"
                  value={stackInstructions.knownEntitiesPolicy.n}
                  onChange={(e) => handlePolicyChange('knownEntitiesPolicy', 'n', parseInt(e.target.value))}
                  sx={{ mt: 1, width: '150px' }}
                  inputProps={{ min: 0 }}
                />
              )}
            <Typography gutterBottom sx={{ mt: 2 }}>
              Filtering
              <InfoDialog
                title="Known Entities Filtering"
                content={`Filters which known entities are listed.

- NONE: Include all known entities found based on the selected mode.
- SCENE_ONLY: Only include entities that are currently present in the scene.
- TAGGED: Only include entities that have explicit #, @, or $ tags.`}
              />
            </Typography>
            <FormControl fullWidth sx={{ mt: 2 }}>
              <InputLabel id="knownentities-filtering-label">Filtering</InputLabel>
              <Select
                labelId="knownentities-filtering-label"
                value={stackInstructions.knownEntitiesPolicy.filtering}
                label="Filtering"
                onChange={(e) =>
                  handlePolicyChange('knownEntitiesPolicy', 'filtering', e.target.value as FilterMode)
                }
              >
                {Object.values(FilterMode).map((mode) => (
                  <MenuItem key={mode} value={mode}>
                    {mode}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </FormControl>
        </Box>
      </Box>

      <Divider sx={{ my: 3 }} />

      {/* REMOVED: Output Format */}
      {/*
      <Typography variant="h6" gutterBottom>
        Output Format
        <InfoDialog
          title="Output Format String (Stack Emission)"
          content={`This string defines the *expected order* and *types* of structured blocks the AI should generate in its response, following the \`Emit & Tagging Skeleton\`. It's crucial for the application to correctly parse the AI's output.

**Common keywords (separated by underscores):**
- \`prose\`: The main narrative text.
- \`digest\`: The summarized digest lines (e.g., \`@digest\` block).
- \`emit\`: World state changes (e.g., \`@delta\` block).
- \`scene\`: Scene changes (e.g., \`@scene\` block).

**Example Orders:**
- \`prose_digest_emit_scene\`: Narration, then digest, then deltas, then scene changes.
- \`emit_prose\`: Deltas first, then narration (useful for strict state updates).

**Important:** The AI will try to follow this order, but might occasionally deviate. Ensure your \`Emit & Tagging Skeleton\` also guides the AI to produce these blocks correctly.`}
        />
      </Typography>
      <TextField
        fullWidth
        label="Output Format String"
        value={stackInstructions.outputFormat}
        onChange={(e) => onStackInstructionsChange({ ...stackInstructions, outputFormat: e.target.value })}
        sx={{ mb: 3 }}
      />
      */}

      <Typography variant="h6" gutterBottom>
        Token Policy
      </Typography>
      <TextField
        fullWidth
        label={
          <>
            Min Tokens
            <InfoDialog
              title="Min Tokens"
              content="The AI will attempt to generate a response of at least this many tokens."
            />
          </>
        }
        type="number"
        value={stackInstructions.tokenPolicy.minTokens}
        onChange={(e) =>
          handlePolicyChange(
            'tokenPolicy',
            'minTokens',
            parseInt(e.target.value)
          )
        }
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
      />
      <TextField
        fullWidth
        label={
          <>
            Max Tokens
            <InfoDialog
              title="Max Tokens"
              content="The absolute maximum number of tokens the AI can generate."
            />
          </>
        }
        type="number"
        value={stackInstructions.tokenPolicy.maxTokens}
        onChange={(e) =>
          handlePolicyChange(
            'tokenPolicy',
            'maxTokens',
            parseInt(e.target.value)
          )
        }
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
      />
      <TextField
        fullWidth
        label={
          <>
            Fallback Plan
            <InfoDialog
              title="Fallback Plan"
              content={`A prioritized, comma-separated list of strategies the system will use to reduce the *input prompt's* token count if it exceeds the AI model's context window.

**Common Fallback Strategies:**
- \`drop_known_entities\`: Removes the 'Known Entities' block.
- \`drop_low_importance_digest\`: Removes low-importance digests.
- \`truncate_expression_logs\`: Shortens expression logs.
- \`drop_narrator_prose\`: Removes past narrator prose.
- \`truncate_conversation_history\`: Shortens older conversation turns.`}
            />
          </>
        }
        value={stackInstructions.tokenPolicy.fallbackPlan.join(', ')}
        onChange={(e) =>
          handleTokenPolicyChange(
            'fallbackPlan',
            e.target.value.split(',').map((s) => s.trim())
          )
        }
        sx={{ mb: 2 }}
      />
  </CollapsibleSection>);
};

export { StackInstructionsEditor };
@@FILE: src/ui/components/WorldStateItemRow.tsx
// src/ui/components/WorldStateItemRow.tsx

import React, { useState } from 'react';
import {
  Box,
  Typography,
  IconButton,
  TextField,
  InputAdornment,
  Checkbox,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import PushPinIcon from '@mui/icons-material/PushPin';
import PushPinOutlinedIcon from '@mui/icons-material/PushPinOutlined';
import { parseJsonPrimitive } from '../../utils/jsonUtils';

interface WorldStateItemRowProps {
  itemKey: string; // Full key, e.g., "npcs.goblin_1.hp"
  value: any; // The raw value, JsonElement equivalent
  onDelete: (key: string) => Promise<void>; // Make it async as store actions might be async
  onEdit: (key: string, value: any) => Promise<void>; // Make it async
  isPinned: boolean;
  onTogglePin: (key: string) => void; // This will call the store's toggleWorldStatePin with 'variable' type
}

export const WorldStateItemRow: React.FC<WorldStateItemRowProps> = ({
  itemKey,
  value,
  onDelete,
  onEdit,
  isPinned,
  onTogglePin,
}) => {
  const [editMode, setEditMode] = useState(false);
  const [editText, setEditText] = useState(JSON.stringify(value)); // Use JSON.stringify for complex values

  // Extract the last part of the key for display name
  const displayName = itemKey.substring(itemKey.lastIndexOf('.') + 1);

  const handleEditConfirm = async () => {
    try {
      const parsedValue = parseJsonPrimitive(editText);
      await onEdit(itemKey, parsedValue); // Await the async edit operation
      setEditMode(false);
    } catch (e) {
      console.error("Failed to parse input for world state edit:", e);
      // TODO: Provide user feedback (e.g., Snackbar) for parsing errors
    }
  };

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        mb: 1,
        p: 1,
        borderRadius: 1,
        backgroundColor: (theme) => (editMode ? theme.palette.action.hover : 'transparent'),
      }}
    >
      <Typography variant="body2" sx={{ fontWeight: 'bold', flexShrink: 0 }}>
        {displayName}:
      </Typography>
      <Box sx={{ flexGrow: 1 }}>
        {editMode ? (
          <TextField
            fullWidth
            size="small"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onBlur={handleEditConfirm}
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleEditConfirm();
              }
            }}
            InputProps={{
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton size="small" onClick={handleEditConfirm}>
                    <EditIcon fontSize="small" />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        ) : (
          <Typography
            variant="body2"
            sx={{
              cursor: 'pointer',
              border: '1px solid',
              borderColor: (theme) => theme.palette.divider,
              borderRadius: 1,
              p: 0.8,
              '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
            }}
            onClick={() => setEditMode(true)}
          >
            {JSON.stringify(value)}
          </Typography>
        )}
      </Box>
      <Checkbox
        icon={<PushPinOutlinedIcon fontSize="small" />}
        checkedIcon={<PushPinIcon fontSize="small" />}
        checked={isPinned}
        onChange={() => onTogglePin(itemKey)} // Pass the full itemKey
        size="small"
        sx={{ p: 0.5 }}
      />
      <IconButton size="small" onClick={() => onDelete(itemKey)} sx={{ p: 0.5 }}>
        <DeleteIcon fontSize="small" color="error" />
      </IconButton>
    </Box>
  );
};
@@FOLDER: src/ui/screens
@@FILE: src/ui/screens/CardLibraryScreen.tsx
// src/ui/screens/PromptCardLibraryScreen.tsx
// RENAMED from GameLibraryScreen.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  TextField,
  InputAdornment,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { PromptCard } from '../../models/index';
import Snackbar from '@mui/material/Snackbar';
import { useNavigate } from 'react-router-dom';


interface PromptCardLibraryScreenProps { // RENAMED interface
  onNavToggle: () => void;
  // onNavigateToEditor: (cardId?: string) => void; // To navigate to editor with a specific card
}

const PromptCardLibraryScreen: React.FC<PromptCardLibraryScreenProps> = ({ onNavToggle }) => { // RENAMED component
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const {
    promptCards,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    deletePromptCard,
  } = usePromptCardStore();
  const { initializeGame } = useGameStateStore();

  const [searchTerm, setSearchTerm] = useState('');
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info'>('info');


  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
    }
  }, [user?.uid, fetchPromptCards]);

  const filteredCards = promptCards.filter(card =>
    card.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  const handleEditCard = (card: PromptCard) => {
    setActivePromptCard(card);
    // Navigate to PromptCardManager/Editor screen
    navigate('/cards'); // Navigate to the PromptCardManager
    setSnackbarMessage(`Editing "${card.title}"`);
    setSnackbarSeverity('info');
    console.log(`Navigating to editor for card: ${card.id}`);
  };

  const handleDeleteCard = async (cardId: string) => {
    if (!user?.uid) return;
    try {
      await deletePromptCard(user.uid, cardId);
      setSnackbarMessage('Card deleted successfully!');
      setSnackbarSeverity('success');
    } catch (e) {
      setSnackbarMessage(`Failed to delete card: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };

  const handleStartGame = async (card: PromptCard) => {
    if (!user?.uid) {
      setSnackbarMessage('Must be logged in to start a game.');
      setSnackbarSeverity('error');
      return;
    }
    try {
      // First, set the active card, then initialize game
      setActivePromptCard(card);
      await initializeGame(user.uid, card.id);
      setSnackbarMessage(`Game "${card.title}" initialized! Navigating to game...`);
      setSnackbarSeverity('success');
      navigate('/game'); // Navigate to the GameScreen
      console.log(`Game "${card.title}" started! Navigating to GameScreen.`);
    } catch (e) {
      setSnackbarMessage(`Failed to start game: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };


  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Card Library...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Prompt Card Library
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {error && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {error}
        </Alert>
      )}

      <Box sx={{ p: 2 }}>
        <TextField
          fullWidth
          label="Search Cards"
          variant="outlined"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon />
              </InputAdornment>
            ),
          }}
          sx={{ mb: 2 }}
        />
      </Box>

      <Paper elevation={1} sx={{ flexGrow: 1, m: 2, overflowY: 'auto' }}>
        {filteredCards.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              {searchTerm ? "No cards match your search." : "No cards available. Go to Prompt Cards Manager to create one!"}
            </Typography>
            <Button variant="contained" startIcon={<AddIcon />} sx={{ mt: 2 }} onClick={() => navigate('/cards')}>
              Go to Prompt Card Manager
            </Button>
          </Box>
        ) : (
          <List>
            {filteredCards.map((card) => (
              <React.Fragment key={card.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="start-game" onClick={() => handleStartGame(card)}>
                        <PlayArrowIcon color="primary" />
                      </IconButton>
                      <IconButton edge="end" aria-label="edit-card" onClick={() => handleEditCard(card)}>
                        <EditIcon />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete-card" onClick={() => handleDeleteCard(card.id)}>
                        <DeleteIcon color="error" />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={card.title}
                    secondary={card.description || 'No description'}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>
      <Snackbar
        open={!!snackbarMessage}
        autoHideDuration={6000}
        onClose={() => setSnackbarMessage(null)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={() => setSnackbarMessage(null)} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardLibraryScreen;
@@FILE: src/ui/screens/GameLibraryScreen.tsx
// src/ui/screens/GameLibraryScreen.tsx
// NEW: This screen lists saved games (snapshots)

import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import DeleteIcon from '@mui/icons-material/Delete';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { gameRepository } from '../../data/repositories/gameRepository';
import { GameSnapshot } from '../../models/GameSnapshot';
import { useNavigate } from 'react-router-dom';
import Snackbar from '@mui/material/Snackbar';
import { formatIsoDateForDisplay } from '../../utils/formatDate';

interface GameLibraryScreenProps {
  onNavToggle: () => void;
}

const GameLibraryScreen: React.FC<GameLibraryScreenProps> = ({ onNavToggle }) => {
  const { user } = useAuthStore(); // Ensure user is available here
  const navigate = useNavigate();
  const { loadGame, gameLoading } = useGameStateStore();

  const [savedGames, setSavedGames] = useState<GameSnapshot[]>([]);
  const [loadingSavedGames, setLoadingSavedGames] = useState(true);
  const [savedGamesError, setSavedGamesError] = useState<string | null>(null);
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info' | 'warning'>('info');
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  const fetchSavedGames = async (userId: string) => {
    setLoadingSavedGames(true);
    setSavedGamesError(null);
    try {
      const games = await gameRepository.getAllGameSnapshots(userId);
      setSavedGames(games);
    } catch (e: any) {
      setSavedGamesError(e.message || 'Failed to fetch saved games.');
    } finally {
      setLoadingSavedGames(false);
    }
  };

  useEffect(() => {
    if (user?.uid) {
      fetchSavedGames(user.uid);
    }
  }, [user?.uid]);

  const showSnackbar = (
    message: string,
    severity: 'success' | 'error' | 'info' | 'warning' = 'info'
  ) => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };

  const handleSnackbarClose = (event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') {
      return;
    }
    setSnackbarOpen(false);
  };

  const handleLoadGame = async (snapshotId: string) => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to load a game.', 'error');
      return;
    }
    try {
      // MODIFIED: Pass user.uid as the first argument
      await loadGame(user.uid, snapshotId); 
      showSnackbar('Game loaded successfully! Navigating to game...', 'success');
      navigate('/game');
    } catch (e) {
      showSnackbar(
        `Failed to load game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  const handleDeleteGame = async (snapshotId: string) => {
    if (!user?.uid) return;
    try {
      await gameRepository.deleteGameSnapshot(user.uid, snapshotId);
      fetchSavedGames(user.uid);
      showSnackbar('Game deleted successfully!', 'success');
    } catch (e) {
      showSnackbar(
        `Failed to delete game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  if (loadingSavedGames || gameLoading) {
    return (
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
        }}
      >
        <CircularProgress />
        <Typography variant="h6" ml={2}>
          Loading Games...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Game Library (Saved Games)
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {savedGamesError && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {savedGamesError}
        </Alert>
      )}

      <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
        <Button
          variant="contained"
          onClick={() => navigate('/cards')}
          sx={{ mt: 2 }}
        >
          Start New Game (Select Prompt Card)
        </Button>
      </Box>

      <Paper elevation={1} sx={{ flexGrow: 1, m: 2, overflowY: 'auto' }}>
        {savedGames.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              No saved games found. Start a new one!
            </Typography>
          </Box>
        ) : (
          <List>
            {savedGames.map((game) => (
              <React.Fragment key={game.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton
                        edge="end"
                        aria-label="load-game"
                        onClick={() => handleLoadGame(game.id)}
                      >
                        <PlayArrowIcon color="primary" />
                      </IconButton>
                      <IconButton
                        edge="end"
                        aria-label="delete-game"
                        onClick={() => handleDeleteGame(game.id)}
                      >
                        <DeleteIcon color="error" />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={game.title}
                    secondary={`Turn: ${game.currentTurn} | Last Saved: ${formatIsoDateForDisplay(
                      game.updatedAt
                    )}`}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>

      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default GameLibraryScreen;

@@FILE: src/ui/screens/GameScreen.tsx
import React, { useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Button,
  TextField,
  Paper,
  IconButton,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Snackbar,
  Alert,
} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import CasinoIcon from '@mui/icons-material/Casino';
import MenuIcon from '@mui/icons-material/Menu';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { LogView } from '../components/LogView';
import { PinnedItemsView } from '../components/PinnedItemsView'; // Ensure this import is correct
import { GameState, LogEntry, Message } from '../../models/index';
import { DiceRoller } from '../../utils/diceRoller';

interface GameScreenProps {
  onNavToggle: () => void;
}

const GameScreen: React.FC<GameScreenProps> = ({ onNavToggle }) => {
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const {
    currentSnapshot,
    currentGameState,
    conversationHistory,
    narratorInputText,
    narratorScrollPosition,
    gameLoading,
    gameError,
    processPlayerAction,
    updateNarratorInputText,
    processFirstNarratorTurn,
    updateNarratorScrollPosition,
  } = useGameStateStore();

  const [showRollDialog, setShowRollDialog] = React.useState(false);
  const [rollFormula, setRollFormula] = React.useState("2d6");
  const [snackbarMessage, setSnackbarMessage] = React.useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = React.useState<'success' | 'error' | 'info' | 'warning'>('info');

  const logRef = useRef<HTMLDivElement>(null);
  const initialTurnTriggeredForSnapshot = useRef<string | null>(null);

  const handleGoToLogin = () => {
    console.log('GameScreen: Navigating to /login due to game not initialized or user not logged in.');
    navigate('/login');
  };

  if (!user || !currentSnapshot || !currentGameState) {
    console.warn('GameScreen: Displaying "Game not initialized" message because:', {
      userExists: !!user,
      snapshotExists: !!currentSnapshot,
      gameStateExists: !!currentGameState,
      errorMessage: gameError
    });

    if (gameLoading) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
          <CircularProgress />
          <Typography variant="h6" ml={2}>Loading Game...</Typography>
        </Box>
      );
    }

    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <Typography variant="h6" color="error">Game not initialized or user not logged in.</Typography>
        <Button onClick={handleGoToLogin}>Go to Login</Button>
      </Box>
    );
  }

  useEffect(() => {
    if (logRef.current) {
      logRef.current.scrollTop = logRef.current.scrollHeight;
    }
  }, [conversationHistory]);

  useEffect(() => {
    if (!currentSnapshot) return;
    if (
      initialTurnTriggeredForSnapshot.current !== currentSnapshot.id &&
      currentSnapshot.currentTurn === 0 &&
      currentSnapshot.conversationHistory?.length === 1 &&
      !gameLoading
    ) {
      initialTurnTriggeredForSnapshot.current = currentSnapshot.id;
      console.log("GameScreen: Detected start of Turn 0. Triggering narrator's first response.");
      processFirstNarratorTurn();
    }
  }, [currentSnapshot, gameLoading, processFirstNarratorTurn]);

  useEffect(() => {
    if (logRef.current && narratorScrollPosition !== undefined) {
      logRef.current.scrollTop = narratorScrollPosition;
    }
    return () => {
      if (logRef.current) {
        updateNarratorScrollPosition(logRef.current.scrollTop);
      }
    };
  }, []);

  const handleSendAction = async () => {
    if (narratorInputText.trim() === '') return;
    try {
      await processPlayerAction(narratorInputText);
      setSnackbarSeverity('success');
      setSnackbarMessage('Action sent!');
    } catch (e) {
      setSnackbarSeverity('error');
      setSnackbarMessage(`Failed to process action: ${e instanceof Error ? e.message : 'Unknown error'}`);
    }
  };

  const handleRollDice = async () => {
    try {
      const result = DiceRoller.roll(rollFormula);
      const summary = DiceRoller.format(result);
      await processPlayerAction(`Roll: ${rollFormula}\n${summary}`);
      setSnackbarSeverity('success');
      setSnackbarMessage(`Rolled ${rollFormula}: ${summary}`);
    } catch (e) {
      setSnackbarSeverity('error');
      setSnackbarMessage(`Failed to roll dice: ${e instanceof Error ? e.message : 'Invalid formula or error'}`);
    }
  };

  const handleRollDialogConfirm = () => {
    if (!rollFormula.match(/^(\d*)d(\d+)([\+\-]\d+)?$/i)) {
        setSnackbarSeverity('warning');
        setSnackbarMessage('Invalid dice formula format. Please use NdN[+M|-M].');
        return;
    }
    setShowRollDialog(false);
  };

  // Estimate the height of the PinnedItemsView to set the paddingTop for the log view.
  // This might require some trial and error or a more dynamic calculation if the content varies wildly.
  // Let's assume a fixed height for now for demonstration.
  const estimatedPinnedItemsHeight = '120px'; // Re-evaluate and adjust this value as needed.
                                              // It depends on the height of your PinnedEntityGroup components.
                                              // If you have multiple rows of pinned items, this needs to be larger.

  return (
    // Main container Box needs position: relative to anchor absolute children
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2, position: 'relative' }}>
      {/* Header */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h5" component="h1">
          Narrator
        </Typography>
        <IconButton onClick={onNavToggle} aria-label="menu" sx={{ ml: 'auto' }}>
          <MenuIcon />
        </IconButton>
      </Box>

      {/* Pinned Items Section - Will be absolutely positioned and float */}
      {/* This Box now directly positions the Stack from PinnedItemsView */}
      <Box sx={{
          position: 'absolute', // Position it absolutely
          top: '60px', // Adjust this value to position it below the header
          left: '16px', // Align with main padding
          right: '16px', // Align with main padding
          zIndex: 10, // Ensure it's above the log view
          // The PinnedItemsView's internal Stack now handles its own overflowX
          // No background needed here, as the tiles themselves have backgrounds.
      }}>
        <PinnedItemsView gameState={currentGameState} />
      </Box>

      {/* Log/Chat View */}
      {/* Add padding to the top of the log view to make space for the floating pinned items */}
      <Paper
        ref={logRef}
        elevation={1}
        sx={{
          flexGrow: 1,
          mt: 2, // You can likely remove or reduce this mt if the paddingTop covers the spacing.
                // Leaving it for now, but test to see if it causes too much space.
          p: 2,
          overflowY: 'auto',
          backgroundColor: (theme) => theme.palette.background.paper,
          // This padding ensures content doesn't get hidden under the absolutely positioned pinned items
          paddingTop: `calc(${estimatedPinnedItemsHeight} + 1em)`, // Use estimated height + buffer
          boxSizing: 'border-box', // Ensure padding is included in the element's total height and width
        }}
      >
        <LogView conversationHistory={conversationHistory} />
      </Paper>

      {/* Input Field Section (remains the same) */}
      <Box sx={{ display: 'flex', mt: 2, gap: 1, position: 'relative' }}>
        <TextField
          fullWidth
          multiline
          maxRows={4}
          variant="outlined"
          placeholder="What do you do?"
          value={narratorInputText}
          onChange={(e) => updateNarratorInputText(e.target.value)}
          onKeyPress={(e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              handleSendAction();
            }
          }}
          sx={{ flexGrow: 1 }}
        />
        <Button
          variant="contained"
          onClick={handleSendAction}
          endIcon={<SendIcon />}
          disabled={gameLoading || narratorInputText.trim() === ''}
        >
          {gameLoading ? <CircularProgress size={24} color="inherit" /> : 'Send'}
        </Button>

        {/* Dice Roller Button (Absolutely Positioned Overlay - remains the same) */}
        <IconButton
          sx={{
            position: 'absolute',
            bottom: 'calc(100% - 30px)',
            right: '10px',
            transform: 'translateY(-100%)',
            backgroundColor: (theme) => theme.palette.primary.light,
            color: (theme) => theme.palette.primary.contrastText,
            '&:hover': {
              backgroundColor: (theme) => theme.palette.primary.main,
            },
            zIndex: 10,
          }}
          onClick={handleRollDice}
          onContextMenu={(e) => {
            e.preventDefault();
            setShowRollDialog(true);
          }}
          aria-label="roll dice"
        >
          <CasinoIcon />
        </IconButton>
      </Box>

      {/* ... (Dice Roll Dialog and Snackbar remain the same) ... */}
    </Box>
  );
};

export default GameScreen;
@@FILE: src/ui/screens/LogViewerScreen.tsx
// src/ui/screens/LogViewerScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  Menu,
  MenuItem,
  Checkbox,
  FormControlLabel,
  Paper,
  CircularProgress,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { useLogStore } from '../../state/useLogStore';
import { LogViewMode } from '../../utils/types';
import { useGameStateStore } from '../../state/useGameStateStore';
// import { LogEntryDisplay } from '../components/LogEntryDisplay'; // Removed direct import
import { CollapsibleLogEntry } from '../components/CollapsibleLogEntry'; // NEW: Import CollapsibleLogEntry
import { AutoSizer, List } from 'react-virtualized'; // For efficient list rendering

interface LogViewerScreenProps {
  onNavToggle: () => void;
}

const LogViewerScreen: React.FC<LogViewerScreenProps> = ({ onNavToggle }) => {
  const { logEntries, selectedLogViewModes, isLoading, error, setSelectedLogViewModes, setLogEntries } = useLogStore();
  const { currentSnapshot } = useGameStateStore(); // Access logs from here initially

  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const open = Boolean(anchorEl);

  useEffect(() => {
    // When the current game snapshot changes, update the logs in the log store
    if (currentSnapshot) {
      setLogEntries(currentSnapshot.logs);
    } else {
      setLogEntries([]);
    }
  }, [currentSnapshot, setLogEntries]);


  const handleMenuClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleCheckboxChange = (mode: LogViewMode, checked: boolean) => {
    const newSelection = checked
      ? [...selectedLogViewModes, mode]
      : selectedLogViewModes.filter((m) => m !== mode);
    setSelectedLogViewModes(newSelection);
  };

  // Virtualized list row renderer
  const rowRenderer = ({ index, key, style }: { index: number; key: string; style: React.CSSProperties }) => {
    const entry = logEntries[index];
    if (!entry) return null; // Should not happen with proper list management

    return (
      <Box key={key} style={style} sx={{ p: 1, borderBottom: '1px solid', borderColor: 'divider' }}>
        {/* Render the new CollapsibleLogEntry component for each row */}
        <CollapsibleLogEntry entry={entry} selectedLogViewModes={selectedLogViewModes} />
      </Box>
    );
  };

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Logs...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Log Review
          </Typography>
          <Button color="inherit" onClick={handleMenuClick}>
            Log Views ▼
          </Button>
          <Menu
            anchorEl={anchorEl}
            open={open}
            onClose={handleMenuClose}
            MenuListProps={{
              'aria-labelledby': 'basic-button',
            }}
          >
            {Object.values(LogViewMode).map((mode) => (
              <MenuItem key={mode} onClick={() => handleCheckboxChange(mode, !selectedLogViewModes.includes(mode))}>
                <FormControlLabel
                  control={
                    <Checkbox
                      checked={selectedLogViewModes.includes(mode)}
                      onChange={() => {}} // Handled by MenuItem's onClick
                      name={mode}
                    />
                  }
                  label={mode}
                />
              </MenuItem>
            ))}
          </Menu>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {error && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {error}
        </Alert>
      )}

      {selectedLogViewModes.length === 0 ? (
        <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
          <Typography variant="body1" color="text.secondary">
            Please select at least one log view from the "Log Views" menu.
          </Typography>
        </Box>
      ) : (
        <Paper
          elevation={1}
          sx={{
            flexGrow: 1,
            m: 2,
            display: 'flex',
            flexDirection: 'column',
            minHeight: 0, // ensures child flex containers can shrink
          }}
        >
          {/* Fixed header inside Paper */}
          <Box sx={{ p: 1, borderBottom: '1px solid', borderColor: 'divider', textAlign: 'center' }}>
            <Typography variant="subtitle1" color="text.primary">
              Showing: {selectedLogViewModes.join(' | ')}
            </Typography>
          </Box>

          {/* Scrollable log list */}
          <Box sx={{ flex: 1, overflowY: 'auto' }}>
            {logEntries.map((entry, index) => (
              <Box key={index} sx={{ p: 1, borderBottom: '1px solid', borderColor: 'divider' }}>
                <CollapsibleLogEntry
                  entry={entry}
                  selectedLogViewModes={selectedLogViewModes}
                />
              </Box>
            ))}
          </Box>

        </Paper>

      )}
    </Box>
  );
};

export default LogViewerScreen;
@@FILE: src/ui/screens/LoginScreen.tsx
// src/ui/screens/LoginScreen.tsx

import React from 'react';
import { useAuthStore } from '../../state/useAuthStore'; // Import our Zustand auth store

const LoginScreen: React.FC = () => {
  // Destructure state and actions from the auth store
  const { user, isLoading, error, signIn, signOut } = useAuthStore();

  if (isLoading) {
    return (
      <div style={styles.container}>
        <h2>Loading Authentication Status...</h2>
      </div>
    );
  }

  if (user) {
    // User is logged in
    return (
      <div style={styles.container}>
        <h2>Welcome, {user.displayName || user.email}!</h2>
        <p>Your User ID: {user.uid}</p>
        <button onClick={signOut} style={styles.button}>
          Sign Out
        </button>
      </div>
    );
  } else {
    // No user logged in
    return (
      <div style={styles.container}>
        <h2>Please Log In to StoryForge</h2>
        {error && <p style={styles.errorText}>Error: {error}</p>}
        <button onClick={signIn} style={styles.button}>
          Sign in with Google
        </button>
      </div>
    );
  }
};

const styles: { [key: string]: React.CSSProperties } = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: '100vh', // Take full viewport height
    backgroundColor: '#f0f2f5',
    fontFamily: 'Arial, sans-serif',
    padding: '20px',
  },
  button: {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#4285F4', // Google blue
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    marginTop: '20px',
    transition: 'background-color 0.3s ease',
  },
  errorText: {
    color: 'red',
    marginTop: '10px',
  }
};

export default LoginScreen;
@@FILE: src/ui/screens/PromptCardEditor.tsx
// src/ui/screens/PromptCardEditor.tsx

import React from 'react';
import {
  Box,
  TextField,
  Checkbox,
  FormControlLabel,
  Grid,
  Switch,
  Divider,
} from '@mui/material';
import { CollapsibleSection } from '../components/CollapsibleSection';
import { AiSettingsEditor } from '../components/AiSettingsEditor';
import { StackInstructionsEditor } from '../components/StackInstructionsEditor';
import { PromptCard, AiConnection, StackInstructions } from '../../models/index';
// Import default values for new cards or resetting
import {
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
  defaultStackInstructions,
  defaultAiSettingsInCard,
} from '../../data/config/promptCardDefaults';
import { InfoDialog } from '../components/InfoDialog'; // NEW: Import InfoDialog

interface PromptCardEditorProps {
  card: PromptCard;
  onCardChange: (updatedCard: PromptCard) => void;
  availableConnections: AiConnection[];
}

const PromptCardEditor: React.FC<PromptCardEditorProps> = ({
  card,
  onCardChange,
  availableConnections,
}) => {
  const createChangeHandler = <K extends keyof PromptCard>(prop: K) => {
    return (value: PromptCard[K]) => {
      onCardChange({ ...card, [prop]: value });
    };
  };

  const handleAiSettingsChange = (
    settingsKey: 'aiSettings' | 'helperAiSettings',
    updatedSettings: PromptCard['aiSettings']
  ) => {
    onCardChange({ ...card, [settingsKey]: updatedSettings });
  };

  const handleStackInstructionsChange = (updatedInstructions: StackInstructions) => {
    onCardChange({ ...card, stackInstructions: updatedInstructions });
  };

  return (
    <Box sx={{ p: 1, pb: 4 }}>
      {/* Title & Description */}
      <CollapsibleSection title="Title & Description" initiallyExpanded={true}>
        <TextField
          fullWidth
          label={
            <>
              Title
              <InfoDialog
                title="Prompt Card Title"
                content="A short, descriptive name for this prompt card. Used for display in the game library and manager."
              />
            </>
          }
          value={card.title}
          onChange={(e) => createChangeHandler('title')(e.target.value)}
          sx={{ mb: 2 }}
        />
        <TextField
          fullWidth
          label={
            <>
              Description
              <InfoDialog
                title="Prompt Card Description"
                content="An optional, longer explanation of what this prompt card is about. It helps you remember the card's purpose and can be seen by others if the card is made public. It is NOT sent to the AI."
              />
            </>
          }
          multiline
          minRows={2}
          value={card.description || ''}
          onChange={(e) => createChangeHandler('description')(e.target.value || null)}
          placeholder="Optional: A short description for this prompt card."
        />
      </CollapsibleSection>

      {/* AI Prompt */}
      <CollapsibleSection title="AI Prompt" initiallyExpanded={true}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label={
            <>
              Core Scenario / Persona Prompt
              <InfoDialog
                title="Core Scenario / Persona Prompt"
                content="This is the most important part of your prompt card. It defines the core scenario, the AI's persona (e.g., 'You are a wise old wizard...'), the setting, and any foundational rules. This text is ALWAYS sent to the AI."
              />
            </>
          }
          value={card.prompt}
          onChange={(e) => createChangeHandler('prompt')(e.target.value)}
        />
      </CollapsibleSection>

      {/* First Turn Scene Setup */}
      <CollapsibleSection title="First Turn Scene Setup" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={4}
          label={
            <>
              Intro scene shown only on turn 1
              <InfoDialog
                title="First Turn Only Block"
                content={`This text is added to the AI's prompt ONLY for the very first turn of a new game session using this card. It's ideal for setting an initial scene, asking the player for their first action, or providing specific introductory narrative.
                
Example:
"The camera pans down. It's your first time in this place. Describe the scene and how the world feels from the character's perspective."`}
              />
            </>
          }
          value={card.firstTurnOnlyBlock}
          onChange={(e) => createChangeHandler('firstTurnOnlyBlock')(e.target.value)}
          placeholder={DEFAULT_FIRST_TURN_PROMPT_BLOCK}
        />
      </CollapsibleSection>

      {/* Emit & Tagging Skeleton */}
      <CollapsibleSection title="Emit & Tagging Skeleton" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={6}
          label={
            <>
              Emit/Tagging Rules (JSON/Text)
              <InfoDialog
                title="Emit & Tagging Skeleton"
                content={`This section provides the AI with strict rules on how to output structured data (emits, tags, scene changes) as part of its response. It ensures consistency for automated parsing and game state updates.
                
It should contain markdown and specific marker words like @delta, @digest, @scene.

Example Emit:
{
  "+npcs.#fox.trust": 1,
  "=player.#you.weapons.primary.arrows": 47
}

Example Tagging:
- Use # for characters/NPCs (e.g., #goblin)
- Use @ for locations (e.g., @forest)
- Use $ for items (e.g., $sword)`}
              />
            </>
          }
          value={card.emitSkeleton}
          onChange={(e) => createChangeHandler('emitSkeleton')(e.target.value)}
          placeholder={DEFAULT_EMIT_SKELETON_STRING}
        />
      </CollapsibleSection>

      {/* World State Initialization */}
      <CollapsibleSection title="World State Initialization" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label={
            <>
              Initial World State (JSON)
              <InfoDialog
                title="Initial World State (JSON)"
                content={`A JSON object defining the starting state of your game world. This is loaded once at the beginning of a new game session.
                
It's recommended to use a three-level structure: category.entity.variable.
Categories define broad groups (e.g., 'player', 'npcs', 'locations', 'items').
Entities are specific instances within a category (e.g., '#you', '#goblin_1', '@forest').
Variables are properties of those entities (e.g., 'hp', 'gold', 'status').

Example:
{
  "player": {
    "#you": {
      "hp": 100,
      "gold": 50,
      "inventory": ["$dagger", "$torch"],
      "location": "@forest_edge"
    }
  },
  "npcs": {
    "#goblin_1": {
      "hp": 20,
      "mood": "grumpy",
      "location": "@goblin_camp"
    }
  },
  "locations": {
    "@forest_edge": {
      "description": "A dense forest path.",
      "weather": "sunny"
    }
  }
}`}
              />
            </>
          }
          value={card.worldStateInit}
          onChange={(e) => createChangeHandler('worldStateInit')(e.target.value)}
          placeholder="{}"
        />
      </CollapsibleSection>

      {/* Game Rules */}
      <CollapsibleSection title="Game Rules Skeleton" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={5}
          label={
            <>
              Game Rules
              <InfoDialog
                title="Game Rules"
                content="Textual rules or guidelines for the AI to follow throughout the game. This can include combat mechanics, social interaction rules, or narrative conventions. This is always included in the AI prompt."
              />
            </>
          }
          value={card.gameRules}
          onChange={(e) => createChangeHandler('gameRules')(e.target.value)}
          placeholder="Rules for the AI to follow during gameplay."
        />
      </CollapsibleSection>

      {/* Primary AI Settings */}
      <AiSettingsEditor
        label="Primary AI Settings"
        settings={card.aiSettings}
        onSettingsChange={(s) => handleAiSettingsChange('aiSettings', s)}
        availableConnections={availableConnections}
      />

      {/* Helper AI Settings with Toggle */}
      <CollapsibleSection title="Helper AI Settings" initiallyExpanded={false}>
        <FormControlLabel
          control={
            <Switch
              checked={card.isHelperAiEnabled}
              onChange={(e) => createChangeHandler('isHelperAiEnabled')(e.target.checked)}
            />
          }
          label={
            <>
              Enable Helper AI
              <InfoDialog
                title="Enable Helper AI"
                content="Toggle this to enable or disable an additional, secondary AI call for specific tasks (e.g., generating descriptions for new items, character dialog, or resolving complex rules). If disabled, the Helper AI settings below are ignored."
              />
            </>
          }
          sx={{ mb: 2 }}
        />
        <Divider sx={{ mb: 2 }} />
        <Box sx={{ opacity: card.isHelperAiEnabled ? 1 : 0.5, pointerEvents: card.isHelperAiEnabled ? 'auto' : 'none' }}>
          <AiSettingsEditor
            label=""
            settings={card.helperAiSettings}
            onSettingsChange={(s) => handleAiSettingsChange('helperAiSettings', s)}
            availableConnections={availableConnections}
          />
        </Box>
      </CollapsibleSection>

      {/* Function Definitions */}
      <CollapsibleSection title="Function Definitions" initiallyExpanded={false}>
        <TextField
          fullWidth
          multiline
          minRows={6}
          label={
            <>
              Function Definitions (JSON)
              <InfoDialog
                title="Function Definitions"
                content={`Provide JSON schemas for functions the AI can 'call'. This enables the AI to interact with external tools or structured game systems by outputting specific function calls.
                
Example (OpenAI format):
{
  "name": "use_item",
  "description": "Use an item from the player's inventory.",
  "parameters": {
    "type": "object",
    "properties": {
      "item_name": {
        "type": "string",
        "description": "The name of the item to use."
      }
    },
    "required": ["item_name"]
  }
}`}
              />
            </>
          }
          value={card.functionDefs}
          onChange={(e) => createChangeHandler('functionDefs')(e.target.value)}
          placeholder="e.g., { 'name': 'action', 'parameters': { ... } }"
        />
      </CollapsibleSection>

      {/* Stack Instructions (with discrete controls) */}
      <StackInstructionsEditor
        stackInstructions={card.stackInstructions}
        onStackInstructionsChange={handleStackInstructionsChange}
      />

      {/* Public/Example Toggles */}
      <Box sx={{ mt: 3, display: 'flex', flexDirection: 'column', gap: 1 }}>
        <FormControlLabel
          control={
            <Checkbox
              checked={card.isPublic}
              onChange={(e) => createChangeHandler('isPublic')(e.target.checked)}
            />
          }
          label={
            <>
              Make Public (visible to others)
              <InfoDialog
                title="Public Card"
                content="If checked, this prompt card will be visible and potentially usable by other users. Use this for sharing your creations."
              />
            </>
          }
        />
        <FormControlLabel
          control={
            <Checkbox
              checked={card.isExample}
              onChange={(e) => createChangeHandler('isExample')(e.target.checked)}
            />
          }
          label={
            <>
              Is Example Card (for showcase)
              <InfoDialog
                title="Example Card"
                content="Mark this card as an official example. This is usually for built-in, curated content rather than user-generated cards."
              />
            </>
          }
        />
      </Box>
    </Box>
  );
};

export default PromptCardEditor;
@@FILE: src/ui/screens/PromptCardManager.tsx
// src/ui/screens/PromptCardManager.tsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  MenuItem,
  Snackbar
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import FileUploadIcon from '@mui/icons-material/FileUpload';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import { useNavigate } from 'react-router-dom';

import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useSettingsStore } from '../../state/useSettingsStore';
import { PromptCard, NewPromptCardData } from '../../models/index';
import PromptCardEditor from './PromptCardEditor';

import {
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
  defaultStackInstructions,
  defaultAiSettingsInCard,
} from '../../data/config/promptCardDefaults';


interface PromptCardManagerProps {
  onNavToggle: () => void;
}

const PromptCardManager: React.FC<PromptCardManagerProps> = ({ onNavToggle }) => {
  const navigate = useNavigate();
  const { user } = useAuthStore();
  const {
    promptCards,
    activePromptCard,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    addPromptCard,
    updatePromptCard,
    duplicatePromptCard,
    deletePromptCard,
    importPromptCards,
    exportPromptCard,
  } = usePromptCardStore();
  const { initializeGame } = useGameStateStore();
  const { aiConnections, fetchAiConnections } = useSettingsStore();

  const [localEditedCard, setLocalEditedCard] = useState<PromptCard | null>(null);
  const [isCardDirty, setIsCardDirty] = useState(false);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [saveAsNewTitle, setSaveAsNewTitle] = useState('');
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info' | 'warning'>('info');

  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
      fetchAiConnections(user.uid);
    }
  }, [user?.uid, fetchPromptCards, fetchAiConnections]);

  useEffect(() => {
    setLocalEditedCard(activePromptCard ? { ...activePromptCard } : null);
    setIsCardDirty(false);
  }, [activePromptCard]);

  const showSnackbar = (message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };

  const handleSnackbarClose = (event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') {
      return;
    }
    setSnackbarOpen(false);
  };


  const handleCardSelect = (card: PromptCard) => {
    if (isCardDirty) {
      showSnackbar('Unsaved changes will be lost if you switch cards.', 'warning');
    }
    setActivePromptCard(card);
  };

  const handleNewCard = async () => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to create a new card.', 'error');
      return;
    }
    const defaultConnectionId = aiConnections.length > 0 ? aiConnections[0].id : "";

    const newCardData: NewPromptCardData = {
      title: "New Prompt Card",
      prompt: "This is a new prompt card. Describe the setting and your character's starting situation.",
      description: null,
      firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: defaultStackInstructions,
      emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: '',
      gameRules: '',
      aiSettings: {
        ...defaultAiSettingsInCard,
        selectedConnectionId: defaultConnectionId,
      },
      helperAiSettings: {
        ...defaultAiSettingsInCard,
        selectedConnectionId: defaultConnectionId,
      },
      isHelperAiEnabled: false,
      tags: [],
      isExample: false,
      functionDefs: '',
      isPublic: false,
    };
    try {
      const createdCard = await addPromptCard(user.uid, newCardData);
      if (createdCard) {
        setActivePromptCard(createdCard);
        showSnackbar('New card created successfully!', 'success');
      }
    } catch (e) {
      showSnackbar(`Failed to create new card: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  };

  const handleSaveCard = async (saveAsNew: boolean = false) => {
    if (!user?.uid || !localEditedCard) return;

    try {
      let savedCard: PromptCard | null = null;
      if (saveAsNew) {
        const newCardData: NewPromptCardData = {
          ...localEditedCard,
          title: saveAsNewTitle || `${localEditedCard.title} (Copy)`,
          id: '',
          rootId: '',
          parentId: null,
          createdAt: '',
          updatedAt: '',
          ownerId: user.uid,
          isExample: false,
          isPublic: false,
        };
        savedCard = await addPromptCard(user.uid, newCardData);
      } else {
        savedCard = await updatePromptCard(user.uid, localEditedCard.id, localEditedCard);
      }

      if (savedCard) {
        setActivePromptCard(savedCard);
        showSnackbar('Card saved successfully!', 'success');
      }
    } catch (e) {
      showSnackbar(`Failed to save card: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    } finally {
      setShowSaveDialog(false);
      setSaveAsNewTitle('');
    }
  };

  const handleRevertCard = () => {
    if (activePromptCard) {
      setLocalEditedCard({ ...activePromptCard });
      setIsCardDirty(false);
      showSnackbar('Changes reverted.', 'info');
    }
  };

  const handlePushToLive = () => {
    if (localEditedCard && isCardDirty) {
        handleSaveCard(false);
    }
  };


  const handleDeleteCard = async (cardId: string) => {
    if (!user?.uid) return;
    try {
      await deletePromptCard(user.uid, cardId);
      showSnackbar('Card deleted successfully!', 'success');
    } catch (e) {
      showSnackbar(`Failed to delete card: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  };

  const handleDuplicateCard = async (cardId: string) => {
    if (!user?.uid) return;
    try {
      const duplicated = await duplicatePromptCard(user.uid, cardId);
      if (duplicated) {
        showSnackbar('Card duplicated successfully!', 'success');
      }
    } catch (e) {
      showSnackbar(`Failed to duplicate card: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  };

  const handleStartGame = async () => {
    console.log('PromptCardManager: handleStartGame called. User:', user?.uid, 'Active Card:', activePromptCard?.id);
    if (!user?.uid || !activePromptCard) {
      showSnackbar('Please log in and select a prompt card to start a game.', 'warning');
      return;
    }
    if (isCardDirty) {
      showSnackbar('Please save or revert changes before starting a game.', 'warning');
      return;
    }
    try {
      console.log('PromptCardManager: Calling initializeGame...');
      await initializeGame(user.uid, activePromptCard.id);
      console.log('PromptCardManager: initializeGame AWAITED successfully. Now navigating to /game.');
      showSnackbar('Game initialized! Navigating to game screen...', 'success');
      navigate('/game');
    }
    catch (e: any) {
      console.error('PromptCardManager: Error during game initialization:', e);
      showSnackbar(`Failed to start game: ${e.message || 'Unknown error'}`, 'error');
    }
  };

  const handleImport = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !user?.uid) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const content = e.target?.result as string;
        let parsed: NewPromptCardData | NewPromptCardData[];
        try {
            parsed = JSON.parse(content);
        } catch (parseError) {
            showSnackbar('Invalid JSON format in file.', 'error');
            return;
        }

        const cardsToImport: NewPromptCardData[] = Array.isArray(parsed) ? parsed : [parsed];

        await importPromptCards(user.uid, cardsToImport);
        showSnackbar(`Successfully imported ${cardsToImport.length} cards!`, 'success');
      } catch (err) {
        showSnackbar(`Failed to import cards: ${err instanceof Error ? e.message : 'Invalid JSON'}`, 'error');
        console.error("Import error:", err);
      } finally {
        event.target.value = '';
      }
    };
    reader.readAsText(file);
  };

  const handleExport = async (cardId: string) => {
    if (!user?.uid) return;
    try {
      const card = await exportPromptCard(user.uid, cardId);
      if (card) {
        const json = JSON.stringify(card, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `prompt_card_${card.title.replace(/\s/g, '_')}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showSnackbar(`Card "${card.title}" exported.`, 'success');
      }
    } catch (e) {
      showSnackbar(`Failed to export card: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  };


  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Cards...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h5" component="h1">
          Prompt Cards
        </Typography>
        <IconButton onClick={onNavToggle} aria-label="menu">
          <MenuIcon />
        </IconButton>
      </Box>

      <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
        <Button variant="contained" onClick={handleNewCard} startIcon={<AddIcon />}>
          New Card
        </Button>
        <Button variant="outlined" component="label" startIcon={<FileUploadIcon />}>
          Import Cards
          <input type="file" hidden accept=".json" onChange={handleImport} />
        </Button>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          Error: {error}
        </Alert>
      )}

      <Box sx={{ display: 'flex', flex: 1, overflow: 'hidden', gap: 2 }}>
        <Paper elevation={1} sx={{ flex: 1, minWidth: 250, maxWidth: 350, overflowY: 'auto' }}>
          <Typography variant="h6" sx={{ p: 2, pb: 1 }}>Your Cards</Typography>
          <Divider />
          <List>
            {promptCards.length === 0 ? (
              <ListItem>
                <ListItemText primary="No cards yet. Create a new one!" sx={{ textAlign: 'center' }} />
              </ListItem>
            ) : (
              promptCards.map((card) => (
                <ListItem
                  key={card.id}
                  selected={activePromptCard?.id === card.id}
                  onClick={() => handleCardSelect(card)}
                  sx={{ 
                      py: 1, 
                      pr: 0, 
                      cursor: 'pointer', // Add cursor to show it's clickable
                      '&:hover': {
                          backgroundColor: 'action.hover'
                      }
                  }}
              >
                  <ListItemText
                    primary={card.title}
                    secondary={card.description || 'No description'}
                    primaryTypographyProps={{ noWrap: true }}
                    secondaryTypographyProps={{ noWrap: true }}
                  />
                  <IconButton edge="end" aria-label="duplicate" onClick={(e) => { e.stopPropagation(); handleDuplicateCard(card.id); }}>
                    <ContentCopyIcon fontSize="small" />
                  </IconButton>
                  <IconButton edge="end" aria-label="delete" onClick={(e) => { e.stopPropagation(); handleDeleteCard(card.id); }}>
                    <DeleteIcon fontSize="small" />
                  </IconButton>
                  <IconButton edge="end" aria-label="export" onClick={(e) => { e.stopPropagation(); handleExport(card.id); }}>
                    <FileDownloadIcon fontSize="small" />
                  </IconButton>
                </ListItem>
              ))
            )}
          </List>
        </Paper>

        <Paper elevation={1} sx={{ flex: 2, p: 2, overflowY: 'auto' }}>
          {!activePromptCard || !localEditedCard ? (
            <Box sx={{ textAlign: 'center', mt: 4 }}>
              <Typography variant="h6" color="text.secondary">
                Select a card or create a new one to start editing.
              </Typography>
            </Box>
          ) : (
            <>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6" component="h2">
                  Active Card: {localEditedCard.title}
                </Typography>
                <Box sx={{ display: 'flex', gap: 1 }}>
                  {isCardDirty && (
                    <>
                      <Button variant="outlined" onClick={handleRevertCard}>
                        Revert
                      </Button>
                      <Button variant="outlined" onClick={() => setShowSaveDialog(true)}>
                        Save
                      </Button>
                      <Button variant="contained" onClick={() => handleSaveCard(false)}>
                        Apply Changes
                      </Button>
                    </>
                  )}
                  {!isCardDirty && (
                    <Button
                      variant="contained"
                      color="primary"
                      onClick={handleStartGame}
                      startIcon={<PlayArrowIcon />}
                    >
                      Start Game
                    </Button>
                  )}
                </Box>
              </Box>
              <Divider sx={{ mb: 2 }} />
              <PromptCardEditor
                card={localEditedCard}
                onCardChange={(updatedCard) => {
                  setLocalEditedCard(updatedCard);
                  setIsCardDirty(JSON.stringify(updatedCard) !== JSON.stringify(activePromptCard));
                }}
                availableConnections={aiConnections}
              />
            </>
          )}
        </Paper>
      </Box>

      <Dialog open={showSaveDialog} onClose={() => setShowSaveDialog(false)}>
        <DialogTitle>Save Prompt Card</DialogTitle>
        <DialogContent>
          <Typography variant="body1" sx={{ mb: 2 }}>How would you like to save this prompt card?</Typography>
          <TextField
            autoFocus
            margin="dense"
            label="Save as New Title (Optional)"
            type="text"
            fullWidth
            variant="outlined"
            value={saveAsNewTitle}
            onChange={(e) => setSaveAsNewTitle(e.target.value)}
            placeholder={`${localEditedCard?.title} (Copy)`}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => handleSaveCard(false)} disabled={!activePromptCard?.id}>Update Original</Button>
          <Button onClick={() => handleSaveCard(true)}>Save as New</Button>
          <Button onClick={() => setShowSaveDialog(false)}>Cancel</Button>
        </DialogActions>
      </Dialog>

      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardManager;
@@FILE: src/ui/screens/SettingsScreen.tsx
// src/ui/screens/SettingsScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  TextField,
  Switch,
  FormControlLabel,
  Snackbar,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import CheckIcon from '@mui/icons-material/Check';
import CloseIcon from '@mui/icons-material/Close';
import WifiIcon from '@mui/icons-material/Wifi'; // For testing connection

import { useSettingsStore } from '../../state/useSettingsStore';
import { useAuthStore } from '../../state/useAuthStore';
import { AiConnection } from '../../models/AiConnection';
import { aiClient } from '../../logic/aiClient'; // Import aiClient for connection testing
import { generateUuid } from '../../utils/uuid'; // For generating new connection IDs

interface SettingsScreenProps {
  onNavToggle: () => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onNavToggle }) => {
  const { user } = useAuthStore();
  const {
    aiConnections,
    selectedConnectionId,
    isLoadingConnections,
    connectionsError,
    useDummyNarrator,
    themeMode,
    fetchAiConnections,
    addAiConnection,
    updateAiConnection,
    deleteAiConnection,
    setSelectedConnectionId,
    setUseDummyNarrator,
    setThemeMode,
  } = useSettingsStore();

  const [editingConnection, setEditingConnection] = useState<AiConnection | null>(null);
  const [newConnectionData, setNewConnectionData] = useState<Omit<AiConnection, 'id' | 'createdAt' | 'lastUpdated'> | null>(null);
  const [testStatus, setTestStatus] = useState<string | null>(null);
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info' | 'warning'>('info');

  useEffect(() => {
    if (user?.uid) {
      fetchAiConnections(user.uid);
    }
  }, [user?.uid, fetchAiConnections]);

  // Helper to show snackbar
  const showSnackbar = (message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };

  const handleSnackbarClose = (event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') {
      return;
    }
    setSnackbarOpen(false);
  };

  const handleAddConnectionClick = () => {
    setEditingConnection(null); // Clear any existing edit
    setNewConnectionData({
      displayName: '',
      apiUrl: '',
      apiToken: '',
      modelName: '',
      modelSlug: '',
      functionCallingEnabled: false,
      userAgent: 'StoryForge/1.0 (Web)',
    });
    setTestStatus(null);
  };

  const handleEditConnectionClick = (connection: AiConnection) => {
    setEditingConnection({ ...connection }); // Create a mutable copy for editing
    setNewConnectionData(null); // Clear new connection data
    setTestStatus(null);
  };

  const handleDeleteConnectionClick = async (connectionId: string) => {
    if (!user?.uid) return;
    try {
      await deleteAiConnection(user.uid, connectionId);
      showSnackbar('Connection deleted successfully!', 'success');
    } catch (e: any) {
      showSnackbar(`Failed to delete connection: ${e.message}`, 'error');
    }
  };

  const handleSaveConnection = async () => {
    if (!user?.uid) return;

    try {
      if (editingConnection) {
        // Update existing connection
        await updateAiConnection(user.uid, editingConnection);
        showSnackbar('Connection updated successfully!', 'success');
      } else if (newConnectionData) {
        // Add new connection
        await addAiConnection(user.uid, newConnectionData);
        showSnackbar('Connection added successfully!', 'success');
      }
      setEditingConnection(null);
      setNewConnectionData(null);
    } catch (e: any) {
      showSnackbar(`Failed to save connection: ${e.message}`, 'error');
    }
  };

  const handleTestConnection = async (connectionToTest: AiConnection) => {
    setTestStatus('Testing...');
    try {
      const success = await aiClient.testConnection(connectionToTest);
      if (success) {
        setTestStatus('✅ Success!');
        showSnackbar('AI connection test successful!', 'success');
      } else {
        setTestStatus('❌ Failed. Check URL, Token, and Model Slug.');
        showSnackbar('AI connection test failed. See status for details.', 'error');
      }
    } catch (e: any) {
      setTestStatus(`❌ Error: ${e.message}`);
      showSnackbar(`AI connection test error: ${e.message}`, 'error');
    }
  };

  const currentEdited = editingConnection || newConnectionData;

  if (isLoadingConnections) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Settings...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Settings
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {connectionsError && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {connectionsError}
        </Alert>
      )}

      <Box sx={{ mt: 2, p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
        <Typography variant="h6" gutterBottom>Application Settings</Typography>
        <FormControlLabel
          control={
            <Switch
              checked={useDummyNarrator}
              onChange={(e) => setUseDummyNarrator(e.target.checked)}
            />
          }
          label="Use Dummy Narrator (for testing without AI calls)"
        />
        <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
          When enabled, the game will use a simple, pre-programmed response instead of calling a real AI.
        </Typography>

        <Divider sx={{ my: 2 }} />

        <FormControlLabel
            control={
                <Switch
                    checked={themeMode === 'dark'}
                    onChange={(e) => setThemeMode(e.target.checked ? 'dark' : 'light')}
                />
            }
            label="Dark Mode"
        />
        <Typography variant="body2" color="text.secondary">
            Toggle between light and dark themes.
        </Typography>
      </Box>

      <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>AI Connections</Typography>
      <Paper elevation={1} sx={{ flexGrow: 1, overflowY: 'auto', mb: 2 }}>
        <List>
          {aiConnections.length === 0 ? (
            <ListItem>
              <ListItemText primary="No AI connections configured. Add one below." sx={{ textAlign: 'center', py: 2 }} />
            </ListItem>
          ) : (
            aiConnections.map((conn) => (
              <React.Fragment key={conn.id}>
                <ListItem
                  button
                  selected={selectedConnectionId === conn.id}
                  onClick={() => setSelectedConnectionId(conn.id)}
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="edit" onClick={(e) => { e.stopPropagation(); handleEditConnectionClick(conn); }}>
                        <EditIcon fontSize="small" />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete" onClick={(e) => { e.stopPropagation(); handleDeleteConnectionClick(conn.id); }}>
                        <DeleteIcon fontSize="small" color="error" />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={conn.displayName}
                    secondary={`${conn.modelName} (${conn.apiUrl.substring(0, 30)}...)`}
                  />
                </ListItem>
                <Divider />
              </React.Fragment>
            ))
          )}
        </List>
      </Paper>

      <Button
        variant="contained"
        startIcon={<AddIcon />}
        onClick={handleAddConnectionClick}
        sx={{ mb: 2 }}
      >
        Add New Connection
      </Button>

      {/* Connection Edit/Add Dialog */}
      {(editingConnection || newConnectionData) && (
        <Dialog open onClose={() => { setEditingConnection(null); setNewConnectionData(null); setTestStatus(null); }} fullWidth maxWidth="sm">
          <DialogTitle>{editingConnection ? 'Edit AI Connection' : 'Add New AI Connection'}</DialogTitle>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              label="Connection Name"
              type="text"
              fullWidth
              variant="outlined"
              value={currentEdited?.displayName || ''}
              onChange={(e) => {
                if (editingConnection) { setEditingConnection({ ...editingConnection, displayName: e.target.value }); }
                else if (newConnectionData) { setNewConnectionData({ ...newConnectionData, displayName: e.target.value }); }
              }}
              sx={{ mb: 2 }}
            />
            <TextField
              margin="dense"
              label="API URL"
              type="url"
              fullWidth
              variant="outlined"
              value={currentEdited?.apiUrl || ''}
              onChange={(e) => {
                if (editingConnection) { setEditingConnection({ ...editingConnection, apiUrl: e.target.value }); }
                else if (newConnectionData) { setNewConnectionData({ ...newConnectionData, apiUrl: e.target.value }); }
              }}
              helperText="e.g., https://api.openai.com/v1/ or https://api.deepseek.com/v1/"
              sx={{ mb: 2 }}
            />
            <TextField
              margin="dense"
              label="API Token"
              type="password" // Use type="password" for security
              fullWidth
              variant="outlined"
              value={currentEdited?.apiToken || ''}
              onChange={(e) => {
                if (editingConnection) { setEditingConnection({ ...editingConnection, apiToken: e.target.value }); }
                else if (newConnectionData) { setNewConnectionData({ ...newConnectionData, apiToken: e.target.value }); }
              }}
              helperText="Your secret API key (e.g., sk-...)"
              sx={{ mb: 2 }}
            />
            <TextField
              margin="dense"
              label="Model Name (Display)"
              type="text"
              fullWidth
              variant="outlined"
              value={currentEdited?.modelName || ''}
              onChange={(e) => {
                if (editingConnection) { setEditingConnection({ ...editingConnection, modelName: e.target.value }); }
                else if (newConnectionData) { setNewConnectionData({ ...newConnectionData, modelName: e.target.value }); }
              }}
              helperText="User-friendly name, e.g., 'GPT-4 Turbo' or 'DeepSeek Coder'"
              sx={{ mb: 2 }}
            />
            <TextField
              margin="dense"
              label="Model Slug (API ID)"
              type="text"
              fullWidth
              variant="outlined"
              value={currentEdited?.modelSlug || ''}
              onChange={(e) => {
                if (editingConnection) { setEditingConnection({ ...editingConnection, modelSlug: e.target.value }); }
                else if (newConnectionData) { setNewConnectionData({ ...newConnectionData, modelSlug: e.target.value }); }
              }}
              helperText="The actual model ID used in API requests, e.g., 'gpt-4-turbo' or 'deepseek-coder'"
              sx={{ mb: 2 }}
            />
             <TextField
              margin="dense"
              label="User Agent (Optional)"
              type="text"
              fullWidth
              variant="outlined"
              value={currentEdited?.userAgent || ''}
              onChange={(e) => {
                if (editingConnection) { setEditingConnection({ ...editingConnection, userAgent: e.target.value }); }
                else if (newConnectionData) { setNewConnectionData({ ...newConnectionData, userAgent: e.target.value }); }
              }}
              helperText="Custom User-Agent header for API requests (e.g., 'StoryForge/1.0')"
              sx={{ mb: 2 }}
            />
            <FormControlLabel
              control={
                <Switch
                  checked={currentEdited?.functionCallingEnabled || false}
                  onChange={(e) => {
                    if (editingConnection) { setEditingConnection({ ...editingConnection, functionCallingEnabled: e.target.checked }); }
                    else if (newConnectionData) { setNewConnectionData({ ...newConnectionData, functionCallingEnabled: e.target.checked }); }
                  }}
                />
              }
              label="Enable Function Calling"
            />
            <Typography variant="body2" color="text.secondary">
                If the model supports tool use/function calling.
            </Typography>

            <Box sx={{ mt: 2, display: 'flex', alignItems: 'center', gap: 1 }}>
              <Button
                variant="outlined"
                startIcon={<WifiIcon />}
                onClick={() => currentEdited && handleTestConnection(currentEdited as AiConnection)}
                disabled={!currentEdited?.apiUrl || !currentEdited?.apiToken || !currentEdited?.modelSlug}
              >
                Test Connection
              </Button>
              {testStatus && (
                <Typography variant="body2" color={testStatus.startsWith('✅') ? 'success.main' : 'error.main'}>
                  {testStatus}
                </Typography>
              )}
            </Box>

          </DialogContent>
          <DialogActions>
            <Button onClick={() => { setEditingConnection(null); setNewConnectionData(null); setTestStatus(null); }}>
              Cancel
            </Button>
            <Button onClick={handleSaveConnection} variant="contained" disabled={!currentEdited?.displayName || !currentEdited?.apiUrl || !currentEdited?.apiToken || !currentEdited?.modelSlug}>
              Save
            </Button>
          </DialogActions>
        </Dialog>
      )}

      {/* Snackbar for general messages */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default SettingsScreen;
@@FILE: src/ui/screens/SourceDump.tsx
import React, { useEffect, useState } from 'react';

// Small reusable copy button
function CopyButton({ text }: { text: string }) {
  const [copied, setCopied] = useState(false);
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch (err) {
      console.error('Copy failed', err);
    }
  };
  return (
    <button
      onClick={handleCopy}
      style={{
        marginLeft: '6px',
        fontSize: '0.8rem',
        cursor: 'pointer',
        background: 'none',
        border: '1px solid #ccc',
        borderRadius: '4px',
        padding: '2px 5px',
      }}
    >
      {copied ? '✅' : '📋'}
    </button>
  );
}

function FolderView({
  name,
  node,
  level = 0,
}: {
  name: string;
  node: any;
  level?: number;
}) {
  const [open, setOpen] = useState(true);

  const isFolder = typeof node === 'object';
  if (!isFolder) return null;

  const folderIndent = { paddingLeft: `${level * 1.2}rem` };

  // Gather folder text for copy
  const folderText = node.__files
    ? node.__files.map((f: any) => f.content).join('\n')
    : '';

  return (
    <div style={{ ...folderIndent }}>
      <div
        style={{
          cursor: 'pointer',
          userSelect: 'none',
          fontWeight: 'bold',
        }}
        onClick={() => setOpen(!open)}
      >
        {open ? '📂' : '📁'} {name}
        {folderText && <CopyButton text={folderText} />}
      </div>

      {open && (
        <>
          {node.__files &&
            node.__files.map((file: any) => (
              <div key={file.name} style={{ paddingLeft: '1.5rem' }}>
                📄 {file.name}
                <CopyButton text={file.content} />
              </div>
            ))}
          {Object.entries(node)
            .filter(([k]) => k !== '__files')
            .map(([childName, childNode]) => (
              <FolderView
                key={childName}
                name={childName}
                node={childNode}
                level={level + 1}
              />
            ))}
        </>
      )}
    </div>
  );
}

export default function SourceDump() {
  const [dumpText, setDumpText] = useState('');
  const [tree, setTree] = useState<any>(null);

  useEffect(() => {
    fetch(`/source-dump.txt?_=${Date.now()}`)
      .then((res) => res.text())
      .then((text) => {
        setDumpText(text);
        setTree(parseDumpToTree(text));
      });
  }, []);

  if (!dumpText) return <div>Loading...</div>;

  return (
    <div style={{ padding: '1rem', fontFamily: 'monospace' }}>
      <h2>
        📋 Copy Entire Repo
        <CopyButton text={dumpText} />
      </h2>

      {tree && <FolderView name="src" node={tree.src || tree} />}

      <hr style={{ margin: '2rem 0' }} />
      <h3>Full Dump:</h3>
      <pre
        style={{
          whiteSpace: 'pre-wrap',
          fontSize: '0.85rem',
          maxHeight: '400px',
          overflow: 'auto',
        }}
      >
        {dumpText}
      </pre>
    </div>
  );
}

function parseDumpToTree(dump: string) {
  const lines = dump.split('\n');
  const root: any = { __files: [] };;
  let currentFolder: string[] = [];
  let currentFile: { name: string; content: string } | null = null;

  const ensureFolder = (pathParts: string[]) => {
    let node = root;
    for (const part of pathParts) {
      if (!node[part]) node[part] = { __files: [] };
      node = node[part];
    }
    return node;
  };

  for (let line of lines) {
    if (line.startsWith('@@FOLDER:')) {
      const folderPath = line.replace('@@FOLDER: ', '').trim();
      currentFolder = folderPath.split('/').slice(1); // remove 'src'
      ensureFolder(currentFolder);
    } else if (line.startsWith('@@FILE:')) {
      const filePath = line.replace('@@FILE: ', '').trim();
      const parts = filePath.split('/');
      const fileName = parts.pop()!;
      currentFolder = parts.slice(1);
      const folderNode = ensureFolder(currentFolder);
      currentFile = { name: fileName, content: '' };
      folderNode.__files.push(currentFile);
    } else {
      if (currentFile) currentFile.content += line + '\n';
    }
  }

  return root;
}

@@FILE: src/ui/screens/WorldStateScreen.tsx
// src/ui/screens/WorldStateScreen.tsx

import React, { useState, useEffect, useCallback, useMemo } from 'react'; // Import useCallback and useMemo
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  Paper,
  CircularProgress,
  Alert,
  List,
  ListItem,
  ListItemText,
  Collapse,
  Checkbox,
  Switch,
  TextField,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Divider,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import { useGameStateStore } from '../../state/useGameStateStore';
import { flattenJsonObject, getNestedValue } from '../../utils/jsonUtils';
import { WorldStateItemRow } from '../components/WorldStateItemRow';

interface WorldStateScreenProps {
  onNavToggle: () => void;
}

interface GroupedWorldState {
  [category: string]: {
    [entity: string]: {
      [variable: string]: any;
      tag?: string; // Add tag as a possible property for entities
    };
  };
}

const WorldStateScreen: React.FC<WorldStateScreenProps> = ({ onNavToggle }) => {
  const {
    currentGameState,
    gameLoading,
    gameError,
    worldStatePinnedKeys,
    toggleWorldStatePin,
    renameWorldCategory,
    renameWorldEntity,
    deleteWorldCategory,
    deleteWorldEntity,
    editWorldKeyValue,
    deleteWorldKey,
  } = useGameStateStore();

  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());
  const [expandedEntities, setExpandedEntities] = useState<Set<string>>(new Set());
  const [editingCategory, setEditingCategory] = useState<string | null>(null);
  const [newCategoryName, setNewCategoryName] = useState('');
  const [editingEntity, setEditingEntity] = useState<[string, string] | null>(null);
  const [newEntityName, setNewEntityName] = useState('');

  const worldState = currentGameState?.worldState || {};
  const flattenedWorld = useMemo(() => flattenJsonObject(worldState), [worldState]);

  // Helper function: Get all direct child variable keys under a given path
  const getAllChildVariableKeys = useCallback((basePath: string): string[] => {
    const relevantKeys: string[] = [];
    const nestedData = getNestedValue(worldState, basePath.split('.'));

    if (typeof nestedData !== 'object' || nestedData === null) {
      return [];
    }

    const flattenedChildren = flattenJsonObject(nestedData, basePath);

    // Filter to only include direct children (variables) of the current path
    // A key "parent.child.grandchild" is a child of "parent.child" but not a direct child of "parent"
    for (const key in flattenedChildren) {
        if (key.startsWith(basePath) && key.length > basePath.length) { // Ensure it's a descendant
            // Check if it's a direct variable and not an intermediate object in a deeper path
            const partsAfterBase = key.substring(basePath.length + 1).split('.');
            if (partsAfterBase.length === 1 && typeof flattenedChildren[key] !== 'object') {
                relevantKeys.push(key);
            } else if (partsAfterBase.length > 1 && typeof getNestedValue(nestedData, partsAfterBase.slice(0, partsAfterBase.length -1)) === 'object') {
                // If it's a nested key, but its immediate parent is still an object (not a primitive value)
                // this means it's an intermediate path or a variable under a nested object.
                // We want to capture the leaf variables. This logic needs to be careful.
                // A simpler approach for "all variables under a path" is to flatten and then filter.
                relevantKeys.push(key); // Add all descendant leaf nodes
            }
        }
    }
    return relevantKeys;
  }, [worldState]);


  // Helper: Check if ANY child variable of a given parent path is pinned
  const isAnyChildPinned = useCallback((parentPath: string) => {
    const allChildKeys = getAllChildVariableKeys(parentPath);
    return allChildKeys.some(key => worldStatePinnedKeys.includes(key));
  }, [getAllChildVariableKeys, worldStatePinnedKeys]);

  // Helper: Check if ALL child variables of a given parent path are pinned
  const areAllChildrenPinned = useCallback((parentPath: string) => {
    const allChildKeys = getAllChildVariableKeys(parentPath);
    if (allChildKeys.length === 0) return false; // No children to be pinned, so not "all pinned"
    return allChildKeys.every(key => worldStatePinnedKeys.includes(key));
  }, [getAllChildVariableKeys, worldStatePinnedKeys]);


  const groupedByCategory: GroupedWorldState = useMemo(() => {
    const grouped: GroupedWorldState = {};
    for (const fullKey in flattenedWorld) {
      const value = flattenedWorld[fullKey];
      const parts = fullKey.split(".");
      if (parts.length < 1) continue; // Should at least have a category

      const category = parts[0];
      let entity: string | undefined;
      let variable: string;

      // Determine if it's category.entity.variable or just category.variable
      // If path is "category.variable" -> entity is '@@_direct', variable is 'variable'
      // If path is "category.entity.variable" -> entity is 'entity', variable is 'variable'
      const isTopLevelVariable = parts.length === 2 && !parts[1].startsWith('#') && !parts[1].startsWith('@') && !parts[1].startsWith('$');
      const isNestedEntityVariable = parts.length >= 2 && (parts[1].startsWith('#') || parts[1].startsWith('@') || parts[1].startsWith('$'));

      if (isNestedEntityVariable) {
          entity = parts[1];
          variable = parts.slice(2).join(".");
      } else { // Handle top-level category variables or untagged entities that are direct children of categories
          entity = '@@_direct'; // Use a special marker for direct category properties
          variable = parts.slice(1).join(".");
      }

      grouped[category] = grouped[category] || {};
      grouped[category][entity] = grouped[category][entity] || {};
      grouped[category][entity][variable] = value;
    }

    // Clean up empty '@@_direct' entities if no direct variables existed
    for (const category in grouped) {
      if (Object.keys(grouped[category]['@@_direct'] || {}).length === 0) {
        delete grouped[category]['@@_direct'];
      }
    }
    return grouped;
  }, [flattenedWorld]);


  const handleToggleCategoryPin = useCallback((category: string) => {
    const allVarsInCat = getAllChildVariableKeys(category);
    const currentlyAllPinned = areAllChildrenPinned(category);
    
    // If all are currently pinned, unpin all. Otherwise, pin all.
    const shouldPin = !currentlyAllPinned;

    allVarsInCat.forEach(key => {
        toggleWorldStatePin(key, 'variable'); // `toggleWorldStatePin` handles adding/removing based on its internal logic
    });
  }, [getAllChildVariableKeys, areAllChildrenPinned, toggleWorldStatePin]);

  const handleToggleEntityPin = useCallback((category: string, entity: string) => {
    const entityPath = `${category}.${entity}`;
    const allVarsInEntity = getAllChildVariableKeys(entityPath);
    const currentlyAllPinned = areAllChildrenPinned(entityPath);

    const shouldPin = !currentlyAllPinned;

    allVarsInEntity.forEach(key => {
        toggleWorldStatePin(key, 'variable');
    });
  }, [getAllChildVariableKeys, areAllChildrenPinned, toggleWorldStatePin]);


  const handleToggleCategoryExpand = useCallback((category: string) => {
    setExpandedCategories((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(category)) {
        newSet.delete(category);
      } else {
        newSet.add(category);
      }
      return newSet;
    });
  }, []);

  const handleToggleEntityExpand = useCallback((category: string, entity: string) => {
    const key = `${category}.${entity}`;
    setExpandedEntities((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(key)) {
        newSet.delete(key);
      } else {
        newSet.add(key);
      }
      return newSet;
    });
  }, []);

  const handleStartRenameCategory = useCallback((category: string) => {
    setEditingCategory(category);
    setNewCategoryName(category);
  }, []);

  const handleConfirmRenameCategory = useCallback(async () => {
    if (editingCategory && newCategoryName.trim() !== '' && newCategoryName !== editingCategory) {
      await renameWorldCategory(editingCategory, newCategoryName);
    }
    setEditingCategory(null);
  }, [editingCategory, newCategoryName, renameWorldCategory]);

  const handleStartRenameEntity = useCallback((category: string, entity: string) => {
    setEditingEntity([category, entity]);
    setNewEntityName(entity);
  }, []);

  const handleConfirmRenameEntity = useCallback(async () => {
    if (editingEntity && newEntityName.trim() !== '' && newEntityName !== editingEntity[1]) {
      await renameWorldEntity(editingEntity[0], editingEntity[1], newEntityName);
    }
    setEditingEntity(null);
  }, [editingEntity, newEntityName, renameWorldEntity]);


  if (gameLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading World State...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      {/* Header */}
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            World State
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {gameError && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {gameError}
        </Alert>
      )}

      {Object.keys(groupedByCategory).length === 0 ? (
        <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
          <Typography variant="body1" color="text.secondary">
            No world state data available. Start a game to generate it.
          </Typography>
        </Box>
      ) : (
        <Paper elevation={1} sx={{ flexGrow: 1, m: 2, p: 2, overflowY: 'auto' }}>
          {Object.entries(groupedByCategory).map(([category, entities]) => {
            const isCategoryExpanded = expandedCategories.has(category);
            const categoryAllPinned = areAllChildrenPinned(category);
            const categoryAnyPinned = isAnyChildPinned(category);

            return (
              <Box key={category} sx={{ mb: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
                <Box
                  sx={{
                    display: 'flex',
                    alignItems: 'center',
                    p: 1.5,
                    cursor: 'pointer',
                    backgroundColor: (theme) => theme.palette.action.hover,
                  }}
                  onClick={() => handleToggleCategoryExpand(category)}
                >
                  <IconButton size="small" sx={{ mr: 1 }}>
                    {isCategoryExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                  </IconButton>
                  <Typography variant="h6" sx={{ flexGrow: 1 }}>
                    {category}
                  </Typography>
                  <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleStartRenameCategory(category); }}><EditIcon fontSize="small" /></IconButton>
                  <Checkbox
                    checked={categoryAllPinned}
                    indeterminate={categoryAnyPinned && !categoryAllPinned}
                    onClick={(e) => { e.stopPropagation(); handleToggleCategoryPin(category); }}
                  />
                  <IconButton size="small" onClick={(e) => { e.stopPropagation(); deleteWorldCategory(category); }}>
                    <DeleteIcon fontSize="small" color="error" />
                  </IconButton>
                </Box>
                <Collapse in={isCategoryExpanded}>
                  <Divider />
                  <List component="div" disablePadding sx={{ pl: 2 }}>
                    {Object.entries(entities).map(([entity, variables]) => {
                      // Handle the '@@_direct' special entity for direct category variables
                      if (entity === '@@_direct') {
                        return Object.entries(variables).map(([varName, value]) => (
                          <WorldStateItemRow
                            key={`${category}.${varName}`}
                            itemKey={`${category}.${varName}`}
                            value={value}
                            onDelete={deleteWorldKey}
                            onEdit={editWorldKeyValue}
                            isPinned={worldStatePinnedKeys.includes(`${category}.${varName}`)}
                            onTogglePin={(key) => toggleWorldStatePin(key, 'variable')}
                          />
                        ));
                      }

                      const isEntityExpanded = expandedEntities.has(`${category}.${entity}`);
                      const entityPath = `${category}.${entity}`;
                      const entityAllPinned = areAllChildrenPinned(entityPath);
                      const entityAnyPinned = isAnyChildPinned(entityPath);

                      // Extract tag for display/editing if it exists as a direct property of the entity object
                      // The tag might be directly on the entity object itself, or be a nested field (less common for "tag")
                      const tagValue = (variables as any).tag; // Assuming 'tag' is a direct property

                      return (
                        <Box key={entity} sx={{ mb: 1, border: '1px dashed', borderColor: 'divider', borderRadius: 1, mt: 1 }}>
                          <Box
                            sx={{
                              display: 'flex',
                              alignItems: 'center',
                              p: 1,
                              cursor: 'pointer',
                              backgroundColor: (theme) => theme.palette.background.paper,
                            }}
                            onClick={() => handleToggleEntityExpand(category, entity)}
                          >
                            <IconButton size="small" sx={{ mr: 1 }}>
                              {isEntityExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                            </IconButton>
                            <Typography variant="subtitle1" sx={{ flexGrow: 1 }}>
                              {entity}
                            </Typography>
                            <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleStartRenameEntity(category, entity); }}><EditIcon fontSize="small" /></IconButton>
                            <Checkbox
                              checked={entityAllPinned}
                              indeterminate={entityAnyPinned && !entityAllPinned}
                              onClick={(e) => { e.stopPropagation(); handleToggleEntityPin(category, entity); }}
                            />
                            <IconButton size="small" onClick={(e) => { e.stopPropagation(); deleteWorldEntity(category, entity); }}>
                              <DeleteIcon fontSize="small" color="error" />
                            </IconButton>
                          </Box>
                          <Collapse in={isEntityExpanded}>
                            <Divider />
                            <Box sx={{ p: 1.5 }}>
                              {/* Tag Editor: Only show tag editor if the entity name suggests it's a tagged entity */}
                              {(entity.startsWith('#') || entity.startsWith('@') || entity.startsWith('$')) && (
                                <TextField
                                  fullWidth
                                  label="Tag"
                                  value={tagValue || ''} // Display current tag value
                                  onChange={(e) => {
                                    const raw = e.target.value.trim();
                                    // Basic validation for tags
                                    const isValid = raw === '' || raw.startsWith("#") || raw.startsWith("@") || raw.startsWith("$");
                                    if (isValid) {
                                        editWorldKeyValue(`${category}.${entity}.tag`, raw);
                                    } else {
                                        // Provide user feedback for invalid tag format
                                        console.warn("Invalid tag format. Tags should start with #, @, or $.");
                                    }
                                  }}
                                  sx={{ mb: 1.5 }}
                                />
                              )}

                              {Object.entries(variables).filter(([varName]) => varName !== 'tag').map(([varName, value]) => (
                                <WorldStateItemRow
                                  key={varName}
                                  itemKey={`${entityPath}.${varName}`}
                                  value={value}
                                  onDelete={deleteWorldKey}
                                  onEdit={editWorldKeyValue}
                                  isPinned={worldStatePinnedKeys.includes(`${entityPath}.${varName}`)}
                                  onTogglePin={(key) => toggleWorldStatePin(key, 'variable')}
                                />
                              ))}
                            </Box>
                          </Collapse>
                        </Box>
                      );
                    })}
                  </List>
                </Collapse>
              </Box>
            );
          })}
        </Paper>
      )}

      {/* Rename Category Dialog */}
      <Dialog open={!!editingCategory} onClose={() => setEditingCategory(null)}>
        <DialogTitle>Rename Category</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="New Category Name"
            type="text"
            fullWidth
            variant="outlined"
            value={newCategoryName}
            onChange={(e) => setNewCategoryName(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setEditingCategory(null)}>Cancel</Button>
          <Button onClick={handleConfirmRenameCategory}>Rename</Button>
        </DialogActions>
      </Dialog>

      {/* Rename Entity Dialog */}
      <Dialog open={!!editingEntity} onClose={() => setEditingEntity(null)}>
        <DialogTitle>Rename Entity</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="New Entity Name"
            type="text"
            fullWidth
            variant="outlined"
            value={newEntityName}
            onChange={(e) => setNewEntityName(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setEditingEntity(null)}>Cancel</Button>
          <Button onClick={handleConfirmRenameEntity}>Rename</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default WorldStateScreen;
@@FOLDER: src/utils
@@FILE: src/utils/diceRoller.ts
// src/utils/diceRoller.ts

/**
 * Represents the result of a dice roll.
 */
interface DiceRollResult {
  rolls: number[];
  sum: number;
  modifier: number;
  formula: string;
}

export const DiceRoller = {
  /**
   * Rolls dice based on a formula (e.g., "1d20", "2d6+3").
   * Supports basic NdN and optional +M or -M.
   * @param formula The dice rolling formula string.
   * @returns A DiceRollResult object.
   */
  roll: (formula: string): DiceRollResult => {
    const parts = formula.match(/^(\d*)d(\d+)([\+\-]\d+)?$/i);
    if (!parts) {
      throw new Error(`Invalid dice formula: ${formula}. Expected format: NdN[+M|-M]`);
    }

    const numDice = parseInt(parts[1] || '1', 10);
    const numSides = parseInt(parts[2], 10);
    const modifier = parts[3] ? parseInt(parts[3], 10) : 0;

    const rolls: number[] = [];
    let sum = 0;

    for (let i = 0; i < numDice; i++) {
      const roll = Math.floor(Math.random() * numSides) + 1;
      rolls.push(roll);
      sum += roll;
    }

    return {
      rolls,
      sum: sum + modifier,
      modifier,
      formula,
    };
  },

  /**
   * Formats a DiceRollResult into a human-readable string.
   * @param result The DiceRollResult to format.
   * @returns A formatted string (e.g., "Roll: 2d6 -> [3, 5] = 8").
   */
  format: (result: DiceRollResult): string => {
    let summary = `Roll: ${result.formula} -> [${result.rolls.join(', ')}]`;
    if (result.modifier !== 0) {
      summary += `${result.modifier >= 0 ? '+' : ''}${result.modifier}`;
    }
    summary += ` = ${result.sum}`;
    return summary;
  },
};
@@FILE: src/utils/formatDate.ts
// src/utils/formatDate.ts

/**
 * Formats an ISO 8601 date string into a more human-readable local date and time.
 * @param isoString The date string in ISO 8601 format (e.g., "2023-10-27T10:00:00Z").
 * @returns A formatted date string (e.g., "October 27, 2023, 10:00 AM").
 */
export function formatIsoDateForDisplay(isoString: string): string {
  try {
    const date = new Date(isoString);
    if (isNaN(date.getTime())) {
      // Invalid date string
      return "Invalid Date";
    }
    // Options for a readable format. Adjust as needed.
    const options: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: true, // Use 12-hour clock with AM/PM
    };
    return new Intl.DateTimeFormat(undefined, options).format(date);
  } catch (error) {
    console.error("Error formatting date:", error);
    return "Error formatting date";
  }
}

@@FILE: src/utils/hash.test.ts
// src/utils/hash.test.ts

import { generateContentHash, getPromptCardContentForHash } from './hash';
import { PromptCard, AiSettingsInCard, StackInstructions } from '../models/PromptCard';
import { defaultAiSettingsInCard, defaultStackInstructions, DEFAULT_FIRST_TURN_PROMPT_BLOCK, DEFAULT_EMIT_SKELETON_STRING } from '../data/config/promptCardDefaults';

describe('hash utilities', () => {

  // Test for generateContentHash
  it('generateContentHash should produce consistent hashes for the same input', () => {
    const str1 = 'Hello, world!';
    const str2 = 'Hello, world!';
    const str3 = 'Goodbye, world!';

    expect(generateContentHash(str1)).toBe(generateContentHash(str2));
    expect(generateContentHash(str1)).not.toBe(generateContentHash(str3));
  });

  it('generateContentHash should produce different hashes for inputs with different casing or whitespace', () => {
    const str1 = 'Test String';
    const str2 = 'test string';
    const str3 = 'TestString';
    const str4 = 'Test String ';

    expect(generateContentHash(str1)).not.toBe(generateContentHash(str2));
    expect(generateContentHash(str1)).not.toBe(generateContentHash(str3));
    expect(generateContentHash(str1)).not.toBe(generateContentHash(str4));
  });

  // Test for getPromptCardContentForHash
  it('getPromptCardContentForHash should produce consistent string for identical card content', () => {
    const card1: PromptCard = {
      id: '1', rootId: '1', parentId: null, contentHash: '', ownerId: 'user1', createdAt: 'iso', updatedAt: 'iso',
      title: 'Test Card',
      description: 'A simple card for testing.',
      prompt: 'This is the main prompt.',
      firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: defaultStackInstructions,
      emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: '',
      gameRules: 'No rules.',
      aiSettings: { ...defaultAiSettingsInCard, temperature: 0.8 },
      helperAiSettings: { ...defaultAiSettingsInCard, temperature: 0.9 },
      tags: ['tagA', 'tagB'],
      isExample: false,
      isPublic: false,
      functionDefs: '{}',
    };

    const card2: PromptCard = { ...card1 }; // Create a deep copy or equivalent content
    // Ensure that order of tags doesn't affect hash string
    const card3: PromptCard = { ...card1, tags: ['tagB', 'tagA'] };

    expect(getPromptCardContentForHash(card1)).toBe(getPromptCardContentForHash(card2));
    expect(getPromptCardContentForHash(card1)).toBe(getPromptCardContentForHash(card3)); // Tags should be sorted internally
  });

  it('getPromptCardContentForHash should produce different string for different card content', () => {
    const baseCard: PromptCard = {
      id: '1', rootId: '1', parentId: null, contentHash: '', ownerId: 'user1', createdAt: 'iso', updatedAt: 'iso',
      title: 'Test Card',
      description: 'A simple card for testing.',
      prompt: 'This is the main prompt.',
      firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: defaultStackInstructions,
      emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: '',
      gameRules: 'No rules.',
      aiSettings: { ...defaultAiSettingsInCard, temperature: 0.7 },
      helperAiSettings: { ...defaultAiSettingsInCard, temperature: 0.7 },
      tags: ['fantasy'],
      isExample: false,
      isPublic: false,
      functionDefs: '{}',
    };

    // Change title
    const changedTitle = { ...baseCard, title: 'New Title' };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedTitle));

    // Change prompt
    const changedPrompt = { ...baseCard, prompt: 'A new main prompt.' };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedPrompt));

    // Change description
    const changedDescription = { ...baseCard, description: 'Updated description.' };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedDescription));

    // Change AI settings
    const changedAiSettings = { ...baseCard, aiSettings: { ...baseCard.aiSettings, temperature: 0.9 } };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedAiSettings));

    // Change stack instructions (by object change)
    const changedStackInstructions = { ...baseCard, stackInstructions: { ...baseCard.stackInstructions, outputFormat: 'new_format' } };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedStackInstructions));

    // Change tags
    const changedTags = { ...baseCard, tags: ['scifi'] };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedTags));
  });

  it('getPromptCardContentForHash should handle null/empty strings consistently', () => {
    const cardWithNulls: PromptCard = {
      id: '1', rootId: '1', parentId: null, contentHash: '', ownerId: 'user1', createdAt: 'iso', updatedAt: 'iso',
      title: 'Empty Card',
      description: null, // Null description
      prompt: '', // Empty prompt
      firstTurnOnlyBlock: '', // Empty first turn block
      stackInstructions: defaultStackInstructions,
      emitSkeleton: '',
      worldStateInit: '',
      gameRules: '',
      aiSettings: defaultAiSettingsInCard,
      helperAiSettings: defaultAiSettingsInCard,
      tags: [], // Empty tags array
      isExample: false,
      isPublic: false,
      functionDefs: '',
    };

    const cardWithEmptyStrings: PromptCard = {
      id: '2', rootId: '2', parentId: null, contentHash: '', ownerId: 'user1', createdAt: 'iso', updatedAt: 'iso',
      title: 'Empty Card',
      description: '', // Empty string description
      prompt: '',
      firstTurnOnlyBlock: '',
      stackInstructions: defaultStackInstructions,
      emitSkeleton: '',
      worldStateInit: '',
      gameRules: '',
      aiSettings: defaultAiSettingsInCard,
      helperAiSettings: defaultAiSettingsInCard,
      tags: [],
      isExample: false,
      isPublic: false,
      functionDefs: '',
    };

    // Should produce the same content hash string
    expect(getPromptCardContentForHash(cardWithNulls)).toBe(getPromptCardContentForHash(cardWithEmptyStrings));
  });
});
@@FILE: src/utils/hash.ts
// src/utils/hash.ts

import { PromptCard, AiSettingsInCard, StackInstructions } from '../models/PromptCard';
import { StackInstructions as StackInstructionsModel } from '../models/StackInstructions';


/**
 * Generates a simple, non-cryptographic hash from a string.
 * This is suitable for content deduplication checks within the application.
 *
 * Based on the 'sdbm' hash algorithm.
 * @param str The input string to hash.
 * @returns A string representation of the hash.
 */
export function generateContentHash(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = char + (hash << 6) + (hash << 16) - hash; // sdbm hash algorithm
  }
  // Convert to unsigned 32-bit integer and then to hex string
  return (hash >>> 0).toString(16);
}

/**
 * Creates a normalized string representation of key PromptCard content for hashing.
 * This function defines which fields are considered for deduplication.
 * It's important that this function is deterministic: the same input should always
 * produce the same output string.
 * @param card The PromptCard object (or partial object containing relevant fields).
 * @returns A string representing the key content of the card.
 */
export function getPromptCardContentForHash(card: {
  title: string;
  description: string | null;
  prompt: string;
  firstTurnOnlyBlock: string;
  stackInstructions: StackInstructions | string; // Can be object or string, needs to be stringified
  emitSkeleton: string;
  worldStateInit: string;
  gameRules: string;
  tags: string[];
  functionDefs: string;
  aiSettings: AiSettingsInCard; // Include AI settings in hash as they affect "content"
  helperAiSettings: AiSettingsInCard; // Include helper AI settings
}): string {
  // Use a consistent order and join method to ensure same content yields same hash
  // Sort tags for consistent hashing regardless of input order
  const sortedTags = [...(card.tags || [])].sort().join(',');

  // Stringify complex objects for consistent hashing.
  // We need to handle both the structured StackInstructions object and a potential raw JSON string input.
  const stackInstructionsString = typeof card.stackInstructions === 'object'
    ? JSON.stringify(card.stackInstructions)
    : (card.stackInstructions || '');

  // Stringify AI settings objects consistently
  const aiSettingsString = JSON.stringify(card.aiSettings);
  const helperAiSettingsString = JSON.stringify(card.helperAiSettings);

  // Concatenate all relevant content fields.
  // Order matters here for deterministic hashing.
  return [
    card.title,
    card.description || '', // Treat null as empty string for hashing
    card.prompt,
    card.firstTurnOnlyBlock,
    stackInstructionsString,
    card.emitSkeleton,
    card.worldStateInit,
    card.gameRules,
    aiSettingsString,
    helperAiSettingsString,
    sortedTags,
    card.functionDefs,
  ].join('|||'); // Use a distinctive separator to avoid accidental matches
}
@@FOLDER: src/utils/hooks
@@FILE: src/utils/hooks/useLongPress.ts
// src/utils/hooks/useLongPress.ts

import React, { useRef, useCallback } from 'react';

/**
 * Custom hook to detect long press events.
 * @param onLongPress The callback function to execute on long press.
 * @param onClick The callback function to execute on a regular click (optional).
 * @param options Configuration options for long press.
 * @param options.delay The duration in milliseconds for a press to be considered a long press (default: 500).
 */
export function useLongPress<T extends HTMLElement>(
  onLongPress: (event: React.MouseEvent<T> | React.TouchEvent<T>) => void,
  onClick?: (event: React.MouseEvent<T> | React.TouchEvent<T>) => void,
  { delay = 500 } = {}
) {
  const timeout = useRef<NodeJS.Timeout>();
  const target = useRef<T>();

  const start = useCallback(
    (event: React.MouseEvent<T> | React.TouchEvent<T>) => {
      // Stop the event from bubbling to parent elements
      event.stopPropagation();

      // Prevent context menu on long press on some browsers
      event.preventDefault();

      target.current = event.currentTarget as T;
      timeout.current = setTimeout(() => {
        onLongPress(event);
        target.current = undefined; // Clear target after long press
      }, delay);
    },
    [onLongPress, delay]
  );

  const clear = useCallback(
    (event: React.MouseEvent<T> | React.TouchEvent<T>, shouldClick = true) => {
      clearTimeout(timeout.current);
      if (shouldClick && onClick && target.current === event.currentTarget) {
        onClick(event);
      }
      target.current = undefined;
    },
    [onClick]
  );

  return {
    onMouseDown: start,
    onTouchStart: start,
    onMouseUp: (e: React.MouseEvent<T>) => clear(e),
    onMouseLeave: (e: React.MouseEvent<T>) => clear(e, false),
    onTouchEnd: (e: React.TouchEvent<T>) => clear(e),
    onTouchCancel: (e: React.TouchEvent<T>) => clear(e, false),
  };
}

@@FILE: src/utils/jsonUtils.ts
// src/utils/jsonUtils.ts

import { JsonPrimitive } from '@mui/material'; // Assuming this is for example, JsonPrimitive isn't from MUI

/**
 * Flattens a nested JSON object into a single-level map with dot-separated keys.
 * @param obj The JSON object to flatten.
 * @param prefix The prefix for the current level (used in recursion).
 * @returns A map where keys are dot-separated paths and values are primitives or arrays/objects at the leaf.
 */
export function flattenJsonObject(obj: Record<string, any>, prefix: string = ""): Record<string, any> {
  const result: Record<string, any> = {};

  for (const k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      const fullKey = prefix ? `${prefix}.${k}` : k;
      const value = obj[k];

      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        Object.assign(result, flattenJsonObject(value, fullKey));
      } else {
        result[fullKey] = value;
      }
    }
  }
  return result;
}

/**
 * Attempts to parse a string into a JSON primitive (string, number, boolean, null).
 * This is a simplified version of the Android `parseJsonPrimitive` and may need robustness.
 * @param text The string to parse.
 * @returns The parsed JSON primitive or the original string if no better match.
 */
export function parseJsonPrimitive(text: string): any {
  const trimmed = text.trim();

  if (trimmed.toLowerCase() === 'true') return true;
  if (trimmed.toLowerCase() === 'false') return false;
  if (trimmed === 'null') return null;

  const num = Number(trimmed);
  if (!isNaN(num) && isFinite(num)) {
    return num;
  }

  // If it's a string that looks like a string (quoted), remove quotes
  if (trimmed.startsWith('"') && trimmed.endsWith('"') && trimmed.length >= 2) {
    return trimmed.substring(1, trimmed.length - 1);
  }

  // Fallback: if string doesn't parse cleanly, treat as raw string
  return trimmed;
}

/**
 * Safely retrieves a nested value from an object using a dot-separated path.
 * @param obj The object to traverse.
 * @param pathParts An array of strings representing the path.
 * @returns The value at the specified path, or undefined if not found.
 */
export function getNestedValue(obj: Record<string, any>, pathParts: string[]): any {
  let current: any = obj;
  for (const part of pathParts) {
    if (typeof current !== 'object' || current === null || !(part in current)) {
      return undefined;
    }
    current = current[part];
  }
  return current;
}
@@FILE: src/utils/types.ts
// src/utils/types.ts

export enum LogViewMode {
  NARRATOR_OUTPUT = 'Narrator Output',
  USER_INPUT = 'User Input',
  DIGEST_LINES = 'Digest Lines',
  DELTAS = 'Deltas',
  CONTEXT_SNAPSHOT = 'Context Snapshot',
  TOKEN_USAGE = 'Token Usage',
  AI_SETTINGS = 'AI Settings',
  API_DETAILS = 'API Details',
  ERROR_FLAGS = 'Error Flags',
  MODEL_SLUG_USED = 'Model Slug Used'
}
@@FILE: src/utils/uuid.ts
// src/utils/uuid.ts

import { v4 as uuidv4 } from 'uuid';

/**
 * Generates a new unique UUID (Universally Unique Identifier).
 * @returns A string representation of a UUID v4.
 */
export function generateUuid(): string {
  return uuidv4();
}
@@FILE: src/vite-env.d.ts
/// <reference types="vite/client" />

