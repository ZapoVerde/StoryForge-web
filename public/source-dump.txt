@@FILE: src/App.css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

@@FILE: src/App.tsx
// src/App.tsx
import React, { useEffect, useRef } from 'react';
import { BrowserRouter as Router } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import { useSettingsStore } from './state/useSettingsStore';
import { getAppTheme } from './theme';
import MainLayout from './ui/components/MainLayout';
import { AppRoutes } from './AppRoutes';
import { useAuthStore } from './state/useAuthStore';
import { useGameStateStore } from './state/useGameStateStore';
import { usePromptCardStore } from './state/usePromptCardStore';
import { useLogStore } from './state/useLogStore';

const App: React.FC = () => {
  const { themeMode } = useSettingsStore();
  const theme = React.useMemo(() => getAppTheme(themeMode), [themeMode]);

  const { user } = useAuthStore();
  const wasUserLoggedIn = useRef(!!user);

  useEffect(() => {
    const isLoggingOut = wasUserLoggedIn.current && !user;

    if (isLoggingOut) {
      console.log("User is logging out. Resetting all data stores.");
      useGameStateStore.getState().reset();
      usePromptCardStore.getState().reset();
      useSettingsStore.getState().reset();
      useLogStore.getState().reset();
    }
    
    // Update the ref for the next render
    wasUserLoggedIn.current = !!user;
  }, [user]);

  return (
    <ThemeProvider theme={theme}>
      <Router>
        <MainLayout>
          <AppRoutes />
        </MainLayout>
      </Router>
    </ThemeProvider>
  );
};

export default App;
@@FILE: src/AppRoutes.tsx
// src/AppRoutes.tsx
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import ProtectedRoute from './ui/components/ProtectedRoute';
import AuthOrchestrator from './ui/components/AuthOrchestrator';
import LoginScreen from './ui/screens/LoginScreen';
import GameLibraryScreen from './ui/screens/GameLibraryScreen';
import PromptCardManager from './ui/screens/PromptCardManager';
import GameScreen from './ui/screens/GameScreen';
import WorldStateScreen from './ui/screens/WorldStateScreen';
import LogViewerScreen from './ui/screens/LogViewerScreen';
import SettingsScreen from './ui/screens/SettingsScreen';
import SourceDump from './ui/screens/SourceDump';

// A simple wrapper to protect routes that need an active game.
const GameActiveRoute: React.FC<{ children: JSX.Element }> = ({ children }) => {
    const { currentSnapshot } = useGameStateStore();
    if (!currentSnapshot) {
        return <Navigate to="/library" replace />;
    }
    return children;
};

import { useGameStateStore } from './state/useGameStateStore';

export const AppRoutes = () => {
  return (
    <Routes>
      {/* Public Routes */}
      <Route path="/login" element={<LoginScreen />} />
      <Route path="/sourcedump" element={<SourceDump />} />

      {/* Authenticated Routes Layout */}
      <Route
        element={
          <ProtectedRoute>
            <AuthOrchestrator />
          </ProtectedRoute>
        }
      >
        {/* These routes render inside AuthOrchestrator's <Outlet /> */}
        <Route path="/library" element={<GameLibraryScreen onNavToggle={() => {}} />} />
        <Route path="/cards" element={<PromptCardManager onNavToggle={() => {}} />} />
        <Route path="/settings" element={<SettingsScreen onNavToggle={() => {}} />} />

        {/* Routes that also require an active game */}
        <Route path="/game" element={<GameActiveRoute><GameScreen onNavToggle={() => {}} /></GameActiveRoute>} />
        <Route path="/world-state" element={<GameActiveRoute><WorldStateScreen onNavToggle={() => {}} /></GameActiveRoute>} />
        <Route path="/logs" element={<GameActiveRoute><LogViewerScreen onNavToggle={() => {}} /></GameActiveRoute>} />

        {/* Default authenticated route */}
        <Route path="/" element={<Navigate to="/library" replace />} />
      </Route>

      {/* Catch-all for any unhandled paths */}
      <Route path="*" element={<Navigate to="/login" replace />} />
    </Routes>
  );
};
@@FOLDER: src/assets
@@FILE: src/assets/react.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
@@FOLDER: src/config
@@FILE: src/config/navigation.tsx
// src/config/navigation.ts
import LibraryBooksIcon from '@mui/icons-material/LibraryBooks';
import StyleIcon from '@mui/icons-material/Style';
import SettingsIcon from '@mui/icons-material/Settings';
import TravelExploreIcon from '@mui/icons-material/TravelExplore';
import HistoryIcon from '@mui/icons-material/History';
import DataObjectIcon from '@mui/icons-material/DataObject';
import CodeIcon from '@mui/icons-material/Code';
import { GameSnapshot } from '../models';

/**
 * Generates the navigation items array.
 * @param currentSnapshot - The current game snapshot, used to determine if game-specific links should be enabled.
 * @returns An array of navigation item objects.
 */
export const getNavItems = (currentSnapshot: GameSnapshot | null) => [
  { text: 'Game Library', icon: <LibraryBooksIcon />, path: '/library', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Prompt Cards', icon: <StyleIcon />, path: '/cards', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Settings', icon: <SettingsIcon />, path: '/settings', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Current Game', icon: <TravelExploreIcon />, path: '/game', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'World State', icon: <DataObjectIcon />, path: '/world-state', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'Log Viewer', icon: <HistoryIcon />, path: '/logs', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'Source Dump', icon: <CodeIcon />, path: '/sourcedump', requiresAuth: false, requiresGame: false, disabled: false },
];
@@FOLDER: src/contexts
@@FILE: src/contexts/GameSessionContext.tsx
// src/contexts/GameSessionContext.tsx

import React, { createContext, useContext } from 'react';
import { IGameSession } from '../logic/gameSession';

// Define the context to hold the IGameSession instance
const GameSessionContext = createContext<IGameSession | undefined>(undefined);

// Provider component to wrap the application and provide the gameSession
export const GameSessionProvider: React.FC<{ children: React.ReactNode; gameSession: IGameSession }> = ({ children, gameSession }) => {
  return (
    <GameSessionContext.Provider value={gameSession}>
      {children}
    </GameSessionContext.Provider>
  );
};

// Custom hook to easily consume the gameSession from the context by React components
export const useGameSession = () => {
  const context = useContext(GameSessionContext);
  if (context === undefined) {
    throw new Error('useGameSession must be used within a GameSessionProvider');
  }
  return context;
};
@@FILE: src/contexts/LayoutContext.tsx
// src/contexts/LayoutContext.tsx
import React, { createContext, useContext, useState } from 'react';

interface LayoutContextType {
  toggleDrawer: () => void;
}

const LayoutContext = createContext<LayoutContextType | undefined>(undefined);

export const useLayout = () => {
  const context = useContext(LayoutContext);
  if (!context) {
    throw new Error('useLayout must be used within a LayoutProvider');
  }
  return context;
};

export const LayoutProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mobileOpen, setMobileOpen] = useState(false);
  const toggleDrawer = () => setMobileOpen(!mobileOpen);

  const value = { toggleDrawer, mobileOpen }; // Provide mobileOpen as well if needed by MainLayout

  // The actual provider component will be part of MainLayout to have access to state
  // This file just defines the context and hook. The implementation will be in MainLayout.
  // This is a common pattern to avoid circular dependencies.
  // For this refactor, we will define the Provider logic directly within MainLayout.
  return (
    <LayoutContext.Provider value={{ toggleDrawer }}>
      {children}
    </LayoutContext.Provider>
  );
};
@@FOLDER: src/data
@@FOLDER: src/data/config
@@FILE: src/data/config/promptCardDefaults.ts
// src/data/config/promptCardDefaults.ts

// In src/data/config/promptCardDefaults.ts
import { AiSettingsInCard } from '../../models/PromptCard'; // Corrected path
import { StackInstructions, StackMode, FilterMode } from '../../models/StackInstructions'; // Corrected path

/**
 * Default AI settings to be used for PromptCards if not specified.
 * Corresponds to AiSettings.kt's default values, now embedded in PromptCard.
 */
export const defaultAiSettingsInCard: AiSettingsInCard = {
  selectedConnectionId: "",
  temperature: 0.7,
  topP: 1.0,
  maxTokens: 2048,
  presencePenalty: 0.0,
  frequencyPenalty: 0.0,
  functionCallingEnabled: false,
};

/**
 * Default structured StackInstructions object.
 * This is the parsed object version of the default JSON string from PromptCardDefaults.kt.
 */
export const defaultStackInstructions: StackInstructions = {
  narratorProseEmission: { mode: StackMode.FIRST_N, n: 3, filtering: FilterMode.SCENE_ONLY, enabled: true }, // NEW: enabled: true
  digestPolicy: { filtering: FilterMode.TAGGED, enabled: true }, // NEW: enabled: true
  digestEmission: {
    "5": { mode: StackMode.ALWAYS },
    "4": { mode: StackMode.AFTER_N, n: 1 },
    "3": { mode: StackMode.FIRST_N, n: 6 },
    "2": { mode: StackMode.FIRST_N, n: 3 },
    "1": { mode: StackMode.NEVER },
  },
  expressionLogPolicy: { mode: StackMode.ALWAYS, filtering: FilterMode.SCENE_ONLY, enabled: true }, // NEW: enabled: true
  expressionLinesPerCharacter: 3,
  emotionWeighting: true,
  worldStatePolicy: { mode: StackMode.FILTERED, filtering: FilterMode.SCENE_ONLY, enabled: true }, // NEW: enabled: true
  knownEntitiesPolicy: { mode: StackMode.FIRST_N, n: 2, filtering: FilterMode.TAGGED, enabled: true }, // NEW: enabled: true
  // REMOVED: "outputFormat": "prose_digest_emit",
  tokenPolicy: {
    minTokens: 1000,
    maxTokens: 4096,
    fallbackPlan: [
      "drop_known_entities",
      "drop_low_importance_digest",
      "truncate_expression_logs",
    ],
  },
};

/**
 * Default content for the 'firstTurnOnlyBlock' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_FIRST_TURN_PROMPT_BLOCK: string = `The camera pans down. It's your first time in this place.
Describe the scene and how the world feels from the character's perspective.`;

/**
 * Default content for the 'emitSkeleton' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_EMIT_SKELETON_STRING: string = `
### Narrator Output Structure

**IMPORTANT:** Your response MUST follow this exact structure. Each section MUST be separated by the specified markers on their own lines.

1.  **Narrative Prose:**
    *   Begin with clear, immersive narration in freeform prose.
    *   This is the only section that should contain descriptive text. It MUST NOT contain any markers or JSON blocks.

2.  **Summary Digest Block (\`@digest\`):**
    *   After the prose, you MUST include a single newline, followed by the marker \`@digest\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing an array of 1-5 summary lines.
    *   Each line MUST have an importance score from 1 (minor) to 5 (critical).

3.  **Emit Block (\`@delta\`):**
    *   After the digest block, include a single newline, followed by the marker \`@delta\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing key-value deltas for the world state.

4.  **Scene Change Block (\`@scene\`, Optional):**
    *   If the scene has shifted, include a single newline, followed by the marker \`@scene\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block with the new scene object.

---

### **MANDATORY OUTPUT FORMAT EXAMPLE**

This is not optional. Your output must match this structure precisely.

The mist curls like spectral fingers around the ancient oaks. #Lyrielle stands rigid, her silver-threaded cloak shimmering faintly in the moonlight. You feel a sudden chill as #Brom shifts his weight, his leather armor creaking.

@digest
\`\`\`json
[
  { "text": "#Lyrielle appears tense and wary.", "importance": 3 },
  { "text": "The mist in @MoonlitVale thickens, obscuring the path.", "importance": 2 }
]
\`\`\`

@delta
\`\`\`json
{
  "=npcs.#lyrielle.status": "wary",
  "+world.environment.fog_density": 0.1
}
\`\`\`

@scene
\`\`\`json
{
  "location": "@MoonlitVale",
  "present": ["#you", "#lyrielle", "#brom"],
  "weather": "foggy"
}
\`\`\`
---

### Emit & Tagging Rules

*   **Emit Rules:** Paths are \`category.entity.field\`. Use symbolic ops: \`+\`, \`=\`, \`!\`, \`-\`. Paths must be valid.
*   **Tagging Rules:** Use \`#\` for characters, \`@\` for locations, \`$\` for items. Use tags consistently in narration and emits.

`.trim();
@@FOLDER: src/data/infrastructure
@@FILE: src/data/infrastructure/firebaseClient.ts
// src/data/infrastructure/firebaseClient.ts

import { initializeApp, getApps, getApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore'; // Removed initializeFirestore and PersistentLocalCache

// Your Firebase configuration
function getEnvVar(name: string): string {
  const value = import.meta.env[name] as string | undefined;
  if (!value) {
    throw new Error(`Missing required environment variable: ${name}`);
  }
  return value;
}

const firebaseConfig = {
  apiKey: getEnvVar('VITE_FIREBASE_API_KEY'),
  authDomain: getEnvVar('VITE_FIREBASE_AUTH_DOMAIN'),
  projectId: getEnvVar('VITE_FIREBASE_PROJECT_ID'),
  storageBucket: getEnvVar('VITE_FIREBASE_STORAGE_BUCKET'),
  messagingSenderId: getEnvVar('VITE_FIREBASE_MESSAGING_SENDER_ID'),
  appId: getEnvVar('VITE_FIREBASE_APP_ID'),
};

// Initialize Firebase App
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

// Get Firebase services (without offline persistence for MVP)
export const auth = getAuth(app);
export const db = getFirestore(app);
@@FOLDER: src/data/repositories
@@FILE: src/data/repositories/authRepository.ts
// src/data/authRepository.ts

import {
  GoogleAuthProvider,
  signInWithPopup,
  signOut,
  onAuthStateChanged,
  User,
} from 'firebase/auth';
import { auth } from '../infrastructure/firebaseClient'; // Import the auth instance from our firebaseClient

/**
 * Handles user login using Google as the authentication provider.
 * @returns A Promise that resolves with the Firebase User credential if successful, or rejects with an error.
 */
export async function signInWithGoogle(): Promise<User | null> {
  const provider = new GoogleAuthProvider();
  try {
    const result = await signInWithPopup(auth, provider);
    // The signed-in user info.
    const user = result.user;
    console.log("User logged in:", user.uid);
    return user;
  } catch (error: any) {
    // Handle Errors here.
    const errorCode = error.code;
    const errorMessage = error.message;
    // The email of the user's account used.
    const email = error.customData?.email;
    // The AuthCredential type that was used.
    const credential = GoogleAuthProvider.credentialFromError(error);
    console.error("Error signing in with Google:", errorCode, errorMessage, email, credential);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Handles user logout.
 * @returns A Promise that resolves when the user is successfully signed out.
 */
export async function signOutUser(): Promise<void> {
  try {
    await signOut(auth);
    console.log("User signed out.");
  } catch (error) {
    console.error("Error signing out:", error);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Subscribes to authentication state changes.
 * This is crucial for keeping the UI updated about the current user's login status.
 * @param callback A function to call when the auth state changes, receiving the current Firebase User or null.
 * @returns An unsubscribe function that can be called to stop listening for changes.
 */
export function subscribeToAuthChanges(callback: (user: User | null) => void): () => void {
  // onAuthStateChanged returns an unsubscribe function
  const unsubscribe = onAuthStateChanged(auth, (user) => {
    callback(user);
  });
  console.log("Auth state change listener attached.");
  return unsubscribe;
}

// Optional: You could also add a way to get the current user synchronously if needed,
// though `subscribeToAuthChanges` is generally preferred for reactivity.
export function getCurrentUser(): User | null {
  return auth.currentUser;
}
@@FILE: src/data/repositories/gameRepository.ts
// src/data/repositories/gameRepository.ts

import {
  collection,
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  query,
  getDocs,
  serverTimestamp,
  orderBy,
  Timestamp, // Import Timestamp type
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient';
import { GameSnapshot } from '../../models/GameSnapshot';
import { AiConnection } from '../../models/AiConnection';
import { generateUuid } from '../../utils/uuid'; // Import generateUuid

/**
 * Defines the contract for GameSnapshot and AiConnection data persistence operations.
 */
export interface IGameRepository {
  /**
   * Saves a new or updates an existing GameSnapshot.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshot The GameSnapshot object to save.
   * @returns A Promise that resolves when the snapshot is successfully saved.
   */
  saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void>;

  /**
   * Retrieves a single GameSnapshot by its ID for a specific user.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshotId The ID of the GameSnapshot to retrieve.
   * @returns A Promise that resolves with the GameSnapshot object or null if not found.
   */
  getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null>;

  /**
   * Retrieves all GameSnapshots for a specific user, ordered by updatedAt descending.
   * @param userId The ID of the user owning the snapshots.
   * @returns A Promise that resolves with an array of GameSnapshot objects.
   */
  getAllGameSnapshots(userId: string): Promise<GameSnapshot[]>;

  /**
   * Deletes a GameSnapshot by its ID for a specific user.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshotId The ID of the GameSnapshot to delete.
   * @returns A Promise that resolves when the snapshot is successfully deleted.
   */
  deleteGameSnapshot(userId: string, snapshotId: string): Promise<void>;

  /**
   * Retrieves all AI Connections for a user.
   * @param userId The ID of the user.
   * @returns A Promise resolving with an array of AiConnection objects.
   */
  getAiConnections(userId: string): Promise<AiConnection[]>;

  /**
   * Saves a new or updates an existing AI Connection.
   * @param userId The ID of the user.
   * @param connection The AiConnection object to save.
   * @returns A Promise that resolves when the connection is successfully saved.
   */
  saveAiConnection(userId: string, connection: AiConnection): Promise<void>;

  /**
   * Deletes an AI Connection by its ID for a specific user.
   * @param userId The ID of the user.
   * @param connectionId The ID of the AiConnection to delete.
   * @returns A Promise that resolves when the connection is successfully deleted.
   */
  deleteAiConnection(userId: string, connectionId: string): Promise<void>;
}

/**
 * Concrete implementation of IGameRepository using Firestore.
 */
class FirestoreGameRepository implements IGameRepository {

  private getSnapshotsCollectionRef(userId: string) {
    // Path: users/{userId}/gameSnapshots
    return collection(db, 'users', userId, 'gameSnapshots');
  }

  private getAiConnectionsCollectionRef(userId: string) {
    // Path: users/{userId}/aiConnections
    return collection(db, 'users', userId, 'aiConnections');
  }

  // Helper to convert Firestore Timestamp to ISO string
  private convertTimestamps<T extends { createdAt?: any; updatedAt?: any; lastUpdated?: any }>(data: any): T {
    const convertedData: any = { ...data };

    if (data.createdAt && data.createdAt instanceof Timestamp) {
      convertedData.createdAt = data.createdAt.toDate().toISOString();
    }
    if (data.updatedAt && data.updatedAt instanceof Timestamp) {
      convertedData.updatedAt = data.updatedAt.toDate().toISOString();
    }
    // This is the specific field causing the error. 
    // Only convert it if it exists on the source object.
    if (data.lastUpdated && data.lastUpdated instanceof Timestamp) {
      convertedData.lastUpdated = data.lastUpdated.toDate().toISOString();
    }
    
    return convertedData as T;
  }

  async saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshot.id);
    console.log(`FirestoreGameRepository: Attempting to setDoc for GameSnapshot ${snapshot.id} for user ${userId}.`);
    try {
      await setDoc(snapshotDocRef, {
        // Pass all snapshot data, including the new 'title'
        ...snapshot,
        updatedAt: serverTimestamp() // Always update timestamp on save
      }, { merge: true });
      console.log(`FirestoreGameRepository: Successfully setDoc for GameSnapshot ${snapshot.id}.`);
    } catch (e) {
      console.error(`FirestoreGameRepository: FAILED to setDoc for GameSnapshot ${snapshot.id}:`, e);
      throw e; // Re-throw the error for GameSession to catch
    }
  }

  async getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    const snapshotSnap = await getDoc(snapshotDocRef);

    if (snapshotSnap.exists()) {
      const data = snapshotSnap.data();
      // Ensure title is retrieved
      return this.convertTimestamps<GameSnapshot>(data) as GameSnapshot;
    } else {
      console.log(`No GameSnapshot found with ID: ${snapshotId} for user ${userId}`);
      return null;
    }
  }

  async getAllGameSnapshots(userId: string): Promise<GameSnapshot[]> {
    const q = query(
      this.getSnapshotsCollectionRef(userId),
      orderBy('updatedAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    const snapshots: GameSnapshot[] = [];
    querySnapshot.forEach((doc) => {
      // Ensure title is retrieved
      snapshots.push(this.convertTimestamps<GameSnapshot>(doc.data()) as GameSnapshot);
    });
    return snapshots;
  }

  async deleteGameSnapshot(userId: string, snapshotId: string): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    await deleteDoc(snapshotDocRef);
    console.log(`GameSnapshot ${snapshotId} deleted for user ${userId}`);
  }

  async getAiConnections(userId: string): Promise<AiConnection[]> {
    const q = query(
      this.getAiConnectionsCollectionRef(userId),
      orderBy('displayName', 'asc') // Order by display name
    );
    const querySnapshot = await getDocs(q);
    const connections: AiConnection[] = [];
    querySnapshot.forEach((docSnap) => {
      // Ensure the ID from the document is used
      connections.push(this.convertTimestamps<AiConnection>(docSnap.data()));
    });

    // Provide a default DeepSeek connection if no connections exist for the user.
    // This allows immediate testing without requiring users to manually add one.
    if (connections.length === 0) {
      console.log("No AI connections found, returning default.");
      return [
        {
          id: generateUuid(), // Use a generated UUID for the default
          displayName: 'DeepSeek Coder (Default)', // Added displayName
          modelName: 'DeepSeek Coder (Default)',
          modelSlug: 'deepseek-coder',
          apiUrl: 'https://api.deepseek.com/v1/',
          apiToken: 'YOUR_DEEPSEEK_API_KEY_HERE', // User should be able to edit this
          functionCallingEnabled: false, // Default value
          createdAt: new Date().toISOString(),
          lastUpdated: new Date().toISOString(),
          userAgent: 'StoryForge/1.0 (Default)'
        },
      ];
    }
    return connections;
  }

  async saveAiConnection(userId: string, connection: AiConnection): Promise<void> {
    const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connection.id);
    await setDoc(connectionDocRef, {
      ...connection,
      createdAt: connection.createdAt || serverTimestamp(), // Set createdAt only on initial creation
      lastUpdated: serverTimestamp(), // Always update lastUpdated
    }, { merge: true });
    console.log(`AI Connection ${connection.id} saved for user ${userId}`);
  }

  async deleteAiConnection(userId: string, connectionId: string): Promise<void> {
    const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connectionId);
    await deleteDoc(connectionDocRef);
    console.log(`AI Connection ${connectionId} deleted for user ${userId}`);
  }
}

// Export a singleton instance of the repository.
export const gameRepository = new FirestoreGameRepository();
@@FILE: src/data/repositories/promptCardRepository.ts
// src/data/repositories/promptCardRepository.ts

import {
  collection,
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  query,
  where,
  getDocs,
  serverTimestamp,
  orderBy
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient'; // Import our Firestore instance
import { PromptCard } from '../../models/PromptCard';

/**
 * Defines the contract for PromptCard data persistence operations.
 * This interface can be implemented by different concrete repositories
 * (e.g., FirestorePromptCardRepository, MockPromptCardRepository)
 * to allow for easy swapping of data sources.
 */
export interface IPromptCardRepository {
  /**
   * Saves a new or updates an existing PromptCard.
   * If the card already has an ID, it will update the existing document.
   * If not, it assumes the card object passed already has an ID generated (e.g., by cardManager).
   * @param userId The ID of the user owning the card.
   * @param card The PromptCard object to save.
   * @returns A Promise that resolves when the card is successfully saved.
   */
  savePromptCard(userId: string, card: PromptCard): Promise<void>;

  /**
   * Retrieves a single PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to retrieve.
   * @returns A Promise that resolves with the PromptCard object or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a specific user, ordered by updatedAt descending.
   * @param userId The ID of the user owning the cards.
   * @returns A Promise that resolves with an array of PromptCard objects.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Deletes a PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to delete.
   * @returns A Promise that resolves when the card is successfully deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Imports a collection of PromptCards. This method will likely involve
   * generating new IDs/hashes and setting ownerId upon import.
   * The actual logic for generating IDs/hashes and setting ownerId should be in cardManager.ts,
   * this repository method merely handles the bulk persistence.
   * @param userId The ID of the user importing the cards.
   * @param cards The array of PromptCard objects to import.
   * @returns A Promise that resolves when all cards are imported.
   */
  importPromptCards(userId: string, cards: PromptCard[]): Promise<void>;
}

/**
 * Concrete implementation of IPromptCardRepository using Firestore.
 */
export class FirestorePromptCardRepository implements IPromptCardRepository {

  private getCollectionRef(userId: string) {
    // Path: users/{userId}/promptCards
    return collection(db, 'users', userId, 'promptCards');
  }

  async savePromptCard(userId: string, card: PromptCard): Promise<void> {
    if (!card.id) {
      // This case should ideally be prevented by logic in cardManager or wherever cards are created
      // as PromptCard should always have an ID before reaching the repository.
      throw new Error("PromptCard must have an ID to be saved.");
    }
    const cardDocRef = doc(this.getCollectionRef(userId), card.id);
    await setDoc(cardDocRef, {
      ...card,
      updatedAt: serverTimestamp() // Firestore special value for server timestamp
    }, { merge: true }); // Use merge: true to update existing fields and add new ones without overwriting entire doc
    // Note: createdAt should only be set on initial creation, not on every update.
    // We'll manage createdAt in cardManager.ts before passing to repository.
    console.log(`PromptCard ${card.id} saved for user ${userId}`);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    const cardSnap = await getDoc(cardDocRef);

    if (cardSnap.exists()) {
      // Firestore `data()` method returns `any`. We cast it to PromptCard.
      // Note: serverTimestamp() will be an object like { seconds: ..., nanoseconds: ... }
      // when retrieved, not an ISO string. We might need a conversion layer if UI strictly expects ISO string.
      // However, Firestore handles this transparently for objects if saving back.
      // For display, formatIsoDateForDisplay will handle it correctly if it's Date or Timestamp object.
      const data = cardSnap.data() as PromptCard;

      // Firestore's serverTimestamp() retrieves as a Timestamp object.
      // To ensure our PromptCard interface holds string (ISO 8601), we convert it here.
      // This is a common pattern: store one way, retrieve/convert to match app's type.
      return {
        ...data,
        createdAt: data.createdAt instanceof Object && 'toDate' in data.createdAt
          ? (data.createdAt as any).toDate().toISOString()
          : data.createdAt,
        updatedAt: data.updatedAt instanceof Object && 'toDate' in data.updatedAt
          ? (data.updatedAt as any).toDate().toISOString()
          : data.updatedAt,
      };
    } else {
      console.log(`No PromptCard found with ID: ${cardId} for user ${userId}`);
      return null;
    }
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    const q = query(
      this.getCollectionRef(userId),
      orderBy('updatedAt', 'desc') // Order by last updated, newest first
    );
    const querySnapshot = await getDocs(q);
    const cards: PromptCard[] = [];
    querySnapshot.forEach((doc) => {
      // Same conversion for Timestamp objects as in getPromptCard
      const data = doc.data() as PromptCard;
      cards.push({
        ...data,
        createdAt: data.createdAt instanceof Object && 'toDate' in data.createdAt
          ? (data.createdAt as any).toDate().toISOString()
          : data.createdAt,
        updatedAt: data.updatedAt instanceof Object && 'toDate' in data.updatedAt
          ? (data.updatedAt as any).toDate().toISOString()
          : data.updatedAt,
      });
    });
    console.log(`Retrieved ${cards.length} prompt cards for user ${userId}`);
    return cards;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    await deleteDoc(cardDocRef);
    console.log(`PromptCard ${cardId} deleted for user ${userId}`);
  }

  async importPromptCards(userId: string, cards: PromptCard[]): Promise<void> {
    // Firestore transactions/batch writes are ideal for bulk operations.
    // For simplicity in MVP, we'll do individual setDoc calls in parallel.
    // A more robust solution might use writeBatch for atomicity.
    const importPromises = cards.map(async (card) => {
      // Assume cardManager has already processed these cards for import (new IDs, hashes, ownerId).
      const cardDocRef = doc(this.getCollectionRef(userId), card.id);
      await setDoc(cardDocRef, {
        ...card,
        // Ensure timestamps are correctly handled for imported cards.
        // If the imported card already has createdAt/updatedAt, use them.
        // Otherwise, serverTimestamp() is an option, but for imports,
        // it's often preferred to preserve original times or set a specific import time.
        // For now, assume the card object already has string ISO timestamps set by cardManager.
      });
    });
    await Promise.all(importPromises);
    console.log(`Successfully imported ${cards.length} prompt cards for user ${userId}`);
  }
}

// Export a singleton instance of the repository for use throughout the application
export const promptCardRepository = new FirestorePromptCardRepository();
@@FILE: src/index.css
/* Reset and base styles */
* {
  box-sizing: border-box;
}

html,
body,
#root {
  margin: 0;
  padding: 0;
  height: 100%;
  background-color: transparent;
  color: inherit;
}

/* Prevent default link styles from clashing */
a {
  color: inherit;
  text-decoration: none;
}

/* Smooth scrolling */
html {
  scroll-behavior: smooth;
}

@@FOLDER: src/logic
@@FILE: src/logic/ContextStackAssembler.ts
// src/logic/ContextStackAssembler.ts
import {
  PromptCard,
  GameState,
  LogEntry,
  Message,
  SceneState,
  StackMode,
  FilterMode,
  DigestLine,
} from '../models';
import { IContextStackAssembler } from './IContextStackAssembler';
import { getNestedValue } from '../utils/jsonUtils'; // Assuming you have this utility function

export class ContextStackAssembler implements IContextStackAssembler {
  public assembleContext(card: PromptCard, gameState: GameState, logEntries: LogEntry[]): Message[] {
    const messages: Message[] = [];
    const { stackInstructions } = card;

    // 1. World State Context
    if (stackInstructions.worldStatePolicy.enabled) {
      messages.push({ role: "system", content: `## Current World State\n\`\`\`json\n${JSON.stringify(gameState.worldState, null, 2)}\n\`\`\`` });
    }

    // 2. Known Entities
    if (stackInstructions.knownEntitiesPolicy.enabled) {
      const knownEntities = this.extractKnownEntities(gameState, stackInstructions.knownEntitiesPolicy.n);
      if (knownEntities.length > 0) {
        messages.push({ role: "system", content: `## Known Entities\n${knownEntities.join('\n')}` });
      }
    }

    // 3. Digest Context
    if (stackInstructions.digestPolicy.enabled) {
      const relevantDigests = this.getRelevantDigests(logEntries, gameState, card.stackInstructions);
      if (relevantDigests.length > 0) {
        messages.push({ role: "system", content: `## Game Summary Digest\n${relevantDigests.map(d => d.text).join('\n')}` });
      }
    }

    // 4. Expression Log
    if (stackInstructions.expressionLogPolicy.enabled) {
      // Placeholder for complex expression logic
    }

    return messages;
  }
  
  private getSceneTags(scene: SceneState, worldState: Record<string, any>): string[] {
    const tags = new Set<string>();
    if (scene.location?.startsWith('@')) tags.add(scene.location);
    scene.present.forEach(path => {
      const entity = getNestedValue(worldState, path.split('.'));
      if (entity?.tag) tags.add(entity.tag);
    });
    return Array.from(tags);
  }

  private extractKnownEntities(gameState: GameState, limit: number): string[] {
    const entities = new Set(this.getSceneTags(gameState.scene, gameState.worldState));
    return Array.from(entities).slice(0, limit);
  }

  private getRelevantDigests(logs: LogEntry[], gameState: GameState, instructions: PromptCard['stackInstructions']): DigestLine[] {
    const relevantDigests: DigestLine[] = [];
    const sceneTags = this.getSceneTags(gameState.scene, gameState.worldState);
    for (const log of logs) {
      for (const digest of log.digestLines) {
        const rule = instructions.digestEmission[digest.importance];
        if (!rule || rule.mode === StackMode.NEVER) continue;
        const meetsCondition = (rule.mode === StackMode.ALWAYS) || (rule.mode === StackMode.FIRST_N && log.turnNumber <= rule.n) || (rule.mode === StackMode.AFTER_N && log.turnNumber >= rule.n);
        if (meetsCondition) {
          let include = true;
          if (instructions.digestPolicy.filtering === FilterMode.SCENE_ONLY) include = digest.tags?.some(tag => sceneTags.includes(tag)) ?? false;
          else if (instructions.digestPolicy.filtering === FilterMode.TAGGED) include = (digest.tags?.length ?? 0) > 0;
          if (include) relevantDigests.push(digest);
        }
      }
    }
    return relevantDigests;
  }
}
@@FILE: src/logic/GameStateManager.ts
// src/logic/GameStateManager.ts

import { GameState, SceneState } from '../models/GameState';
import { DeltaMap } from '../models/DeltaInstruction';
import { IGameStateManager } from './IGameStateManager';
import { produce } from 'immer'; // For immutable updates
import { flattenJsonObject, getNestedValue } from '../utils/jsonUtils';

/**
 * Manages the mutable aspects of the game state (world state and scene).
 * All mutations here are designed to be immutable, returning new state objects.
 */
export class GameStateManager implements IGameStateManager {

  /**
   * Applies delta instructions to the worldState within a given GameState.
   * @param gameState The current game state to modify.
   * @param deltas The map of delta instructions to apply.
   * @returns A new GameState object with deltas applied (immutable update).
   */
  public applyDeltasToGameState(gameState: GameState, deltas: DeltaMap): GameState {
    return produce(gameState, draft => {
      const updatedWorld = draft.worldState; // immer makes this a mutable draft

      for (const fullKey in deltas) {
        const instruction = deltas[fullKey];
        const parts = instruction.key.split('.');

        let currentLevel: Record<string, any> = updatedWorld;
        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!currentLevel[part] || typeof currentLevel[part] !== 'object' || Array.isArray(currentLevel[part])) {
            currentLevel[part] = {};
          }
          currentLevel = currentLevel[part];
        }

        const lastPart = parts[parts.length - 1];

        switch (instruction.op) {
          case 'add':
            const prevAddValue = typeof currentLevel[lastPart] === 'number' ? currentLevel[lastPart] : 0;
            const addValue = typeof instruction.value === 'number' ? instruction.value : 0;
            currentLevel[lastPart] = prevAddValue + addValue;
            break;
          case 'assign':
            currentLevel[lastPart] = instruction.value;
            break;
          case 'declare':
            if (!(lastPart in currentLevel)) {
              currentLevel[lastPart] = instruction.value;
            }
            break;
          case 'delete':
            delete currentLevel[lastPart];
            break;
        }
      }
    });
  }

  /**
   * Updates the scene state within a given GameState based on parsed AI output or inferred deltas.
   * @param gameState The current game state to modify.
   * @param parsedScene The parsed scene object from AI output.
   * @param deltas The delta map (for inference if no explicit scene).
   * @returns A new GameState object with updated scene (immutable update).
   */
  public updateSceneState(
    gameState: GameState,
    parsedScene: Record<string, any> | null | undefined,
    deltas: DeltaMap
  ): GameState {
    return produce(gameState, draft => {
      let newLocation: string | null = draft.scene.location;
      let newPresent: string[] = [...draft.scene.present];

      if (parsedScene) {
        if (parsedScene.location !== undefined) {
          newLocation = typeof parsedScene.location === 'string' ? parsedScene.location : null;
        }
        if (Array.isArray(parsedScene.present)) {
          newPresent = parsedScene.present.filter((item: any) => typeof item === 'string');
        }
      } else {
        if ((!newLocation && newPresent.length === 0) && deltas) {
          const inferredPresent = new Set<string>();
          for (const fullKey in deltas) {
            const instruction = deltas[fullKey];
            if (instruction.op === 'declare') {
              const parts = instruction.key.split('.');
              if (parts.length >= 2) {
                const category = parts[0];
                const entity = parts[1];
                const valueObj = instruction.value as Record<string, any>;
                if (valueObj && (valueObj.tag === "character" || valueObj.tag === "location")) {
                  inferredPresent.add(`${category}.${entity}`);
                }
              }
              if (instruction.key === "world.location" && typeof instruction.value === 'string') {
                newLocation = instruction.value;
              }
            }
          }
          newPresent = Array.from(inferredPresent);
        }
      }

      draft.scene.location = newLocation;
      draft.scene.present = newPresent;
    });
  }

  // --- World State Direct Modification Methods (Immutable) ---

  public renameCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      if (draft[oldName]) {
        draft[newName] = draft[oldName];
        delete draft[oldName];
      }
    });

    const updatedPinnedKeys = currentPinnedKeys.map(key =>
      key.startsWith(oldName + '.') ? `${newName}${key.substring(oldName.length)}` : key
    );
    return { updatedWorldState, updatedPinnedKeys };
  }

  public renameEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const categoryObj = draft[category];
      if (categoryObj && categoryObj[oldName]) {
        categoryObj[newName] = categoryObj[oldName];
        delete categoryObj[oldName];
      }
    });

    const oldEntityPath = `${category}.${oldName}`;
    const newEntityPath = `${category}.${newName}`;
    const updatedPinnedKeys = currentPinnedKeys.map(key =>
      key.startsWith(oldEntityPath + '.') ? `${newEntityPath}${key.substring(oldEntityPath.length)}` : key
    );
    return { updatedWorldState, updatedPinnedKeys };
  }

  public deleteCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      delete draft[category];
    });
    const updatedPinnedKeys = currentPinnedKeys.filter(key => !key.startsWith(category + '.'));
    return { updatedWorldState, updatedPinnedKeys };
  }

  public deleteEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, entity: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const categoryObj = draft[category];
      if (categoryObj && categoryObj[entity]) {
        delete categoryObj[entity];
      }
    });
    const entityPath = `${category}.${entity}`;
    const updatedPinnedKeys = currentPinnedKeys.filter(key => !key.startsWith(entityPath + '.'));
    return { updatedWorldState, updatedPinnedKeys };
  }

  public editKeyValue(currentWorldState: Record<string, any>, key: string, value: any): Record<string, any> {
    return produce(currentWorldState, draft => {
      const parts = key.split('.');
      let current: any = draft;
      for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!current[part] || typeof current[part] !== 'object') {
          current[part] = {};
        }
        current = current[part];
      }
      current[parts[parts.length - 1]] = value;
    });
  }

  public deleteKey(currentWorldState: Record<string, any>, currentPinnedKeys: string[], key: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const parts = key.split('.');
      let current: any = draft;
      for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!(part in current)) {
          return; // Path doesn't exist, nothing to delete
        }
        current = current[part];
      }
      delete current[parts[parts.length - 1]];
    });
    const updatedPinnedKeys = currentPinnedKeys.filter(pk => pk !== key);
    return { updatedWorldState, updatedPinnedKeys };
  }
}
@@FILE: src/logic/IContextStackAssembler.ts
// src/logic/IContextStackAssembler.ts
import { PromptCard, GameState, LogEntry, Message } from '../models';

/**
 * Defines the contract for a service that assembles the dynamic parts
 * of an AI prompt's context based on StackInstructions.
 */
export interface IContextStackAssembler {
  /**
   * Assembles the full dynamic context stack based on the rules in the prompt card.
   * @param card The active PromptCard containing the StackInstructions.
   * @param gameState The current GameState.
   * @param logEntries The history of log entries for the session.
   * @returns An array of Message objects representing the assembled context.
   */
  assembleContext(
    card: PromptCard,
    gameState: GameState,
    logEntries: LogEntry[]
  ): Message[];
}```

#### **New File: `src/logic/ContextStackAssembler.ts`**
```typescript
// src/logic/ContextStackAssembler.ts
import {
  PromptCard,
  GameState,
  LogEntry,
  Message,
  SceneState,
  StackMode,
  FilterMode,
  DigestLine,
} from '../models';
import { IContextStackAssembler } from './IContextStackAssembler';

export class ContextStackAssembler implements IContextStackAssembler {
  public assembleContext(
    card: PromptCard,
    gameState: GameState,
    logEntries: LogEntry[]
  ): Message[] {
    const messages: Message[] = [];
    const { stackInstructions } = card;

    // 1. World State Context
    if (stackInstructions.worldStatePolicy.enabled) {
      const worldStateJson = JSON.stringify(gameState.worldState, null, 2);
      messages.push({ role: "system", content: `## Current World State\n\`\`\`json\n${worldStateJson}\n\`\`\`` });
    }

    // 2. Known Entities
    if (stackInstructions.knownEntitiesPolicy.enabled) {
      const knownEntities = this.extractKnownEntities(gameState, stackInstructions.knownEntitiesPolicy.n);
      if (knownEntities.length > 0) {
        messages.push({ role: "system", content: `## Known Entities\n${knownEntities.join('\n')}` });
      }
    }

    // 3. Digest Context
    if (stackInstructions.digestPolicy.enabled) {
      const relevantDigests = this.getRelevantDigests(logEntries, gameState, stackInstructions);
      if (relevantDigests.length > 0) {
        messages.push({ role: "system", content: `## Game Summary Digest\n${relevantDigests.map(d => d.text).join('\n')}` });
      }
    }

    // 4. Expression Log
    if (stackInstructions.expressionLogPolicy.enabled) {
      const expressionContent = this.getExpressionLogContent(logEntries, gameState, stackInstructions);
      if (expressionContent.length > 0) {
        messages.push({ role: "system", content: `## Character Expressions Log\n${expressionContent.join('\n')}` });
      }
    }

    return messages;
  }
  
  private getSceneTags(scene: SceneState, worldState: Record<string, any>): string[] {
    const tags = new Set<string>();
    if (scene.location && scene.location.startsWith('@')) {
      tags.add(scene.location);
    }
    scene.present.forEach(path => {
      const entity = this.getNestedValue(worldState, path.split('.'));
      if (entity?.tag) {
        tags.add(entity.tag);
      }
    });
    return Array.from(tags);
  }

  private getNestedValue(obj: Record<string, any>, pathParts: string[]): any {
    return pathParts.reduce((acc, part) => acc && acc[part], obj);
  }
  
  private extractTags(text: string): string[] {
    return text.match(/[#@$][a-zA-Z0-9_]+/g) || [];
  }

  private extractKnownEntities(gameState: GameState, limit: number): string[] {
    // A simplified entity extraction logic. Can be enhanced.
    const entities = new Set<string>();
    const sceneTags = this.getSceneTags(gameState.scene, gameState.worldState);
    sceneTags.forEach(tag => entities.add(tag));
    
    // Fallback: get some from world state if scene is empty
    if (entities.size === 0) {
        for (const category in gameState.worldState) {
            for (const entityKey in gameState.worldState[category]) {
                if (entityKey.startsWith('#') || entityKey.startsWith('@') || entityKey.startsWith('$')) {
                    entities.add(entityKey);
                    if (entities.size >= limit) break;
                }
            }
            if (entities.size >= limit) break;
        }
    }
    
    return Array.from(entities);
  }

  private getRelevantDigests(logs: LogEntry[], gameState: GameState, instructions: PromptCard['stackInstructions']): DigestLine[] {
    const relevantDigests: DigestLine[] = [];
    const sceneTags = this.getSceneTags(gameState.scene, gameState.worldState);

    for (const log of logs) {
      for (const digest of log.digestLines) {
        const rule = instructions.digestEmission[digest.importance];
        if (!rule || rule.mode === StackMode.NEVER) continue;

        const meetsCondition =
          (rule.mode === StackMode.ALWAYS) ||
          (rule.mode === StackMode.FIRST_N && log.turnNumber <= rule.n) ||
          (rule.mode === StackMode.AFTER_N && log.turnNumber >= rule.n);

        if (meetsCondition) {
          let include = true;
          if (instructions.digestPolicy.filtering === FilterMode.SCENE_ONLY) {
            include = digest.tags?.some(tag => sceneTags.includes(tag)) ?? false;
          } else if (instructions.digestPolicy.filtering === FilterMode.TAGGED) {
            include = (digest.tags?.length ?? 0) > 0;
          }
          if (include) {
            relevantDigests.push(digest);
          }
        }
      }
    }
    return relevantDigests.sort((a, b) => (a as any).turn - (b as any).turn); // `turn` might not be on DigestLine model
  }
  
  private getExpressionLogContent(logs: LogEntry[], gameState: GameState, instructions: PromptCard['stackInstructions']): string[] {
      // This is a placeholder for the complex expression log logic.
      // A full implementation would filter logs based on policy and extract relevant lines.
      return [];
  }
}
@@FILE: src/logic/IGameStateManager.ts
// src/logic/IGameStateManager.ts

import { GameState, SceneState } from '../models/GameState';
import { DeltaMap } from '../models/DeltaInstruction';
import { GameSnapshot } from '../models/GameSnapshot'; // To pass for worldStatePinnedKeys

/**
 * Defines the contract for managing the mutable state of the game (worldState and scene).
 * This manager operates on GameState objects and does not directly interact with repositories.
 */
export interface IGameStateManager {
  /**
   * Applies delta instructions to the worldState within a given GameState.
   * @param gameState The current game state to modify.
   * @param deltas The map of delta instructions to apply.
   * @returns A new GameState object with deltas applied (immutable update).
   */
  applyDeltasToGameState(gameState: GameState, deltas: DeltaMap): GameState;

  /**
   * Updates the scene state within a given GameState based on parsed AI output or inferred deltas.
   * @param gameState The current game state to modify.
   * @param parsedScene The parsed scene object from AI output.
   * @param deltas The delta map (for inference if no explicit scene).
   * @returns A new GameState object with updated scene (immutable update).
   */
  updateSceneState(gameState: GameState, parsedScene: Record<string, any> | null | undefined, deltas: DeltaMap): GameState;

  // Methods for direct world state modification (now immutable operations)
  renameCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  renameEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  deleteCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  deleteEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, entity: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  editKeyValue(currentWorldState: Record<string, any>, key: string, value: any): Record<string, any>;
  deleteKey(currentWorldState: Record<string, any>, currentPinnedKeys: string[], key: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
}
@@FILE: src/logic/ISnapshotUpdater.ts
// src/logic/ISnapshotUpdater.ts
import { GameSnapshot, ParsedNarrationOutput, LogEntry } from '../models';

export interface ITurnResult {
  parsedOutput: ParsedNarrationOutput;
  logEntry: LogEntry;
  playerAction?: string; // Include the player's action for conversation history
}

export interface ISnapshotUpdater {
  /**
   * Applies the result of a processed turn to a game snapshot.
   * This handles updating game state from deltas, scene changes, adding logs,
   * updating conversation history, and incrementing the turn counter.
   * @param snapshot The current GameSnapshot.
   * @param turnResult The result from the TurnProcessor.
   * @returns A new, updated GameSnapshot.
   */
  applyTurnResultToSnapshot(snapshot: GameSnapshot, turnResult: ITurnResult): GameSnapshot;

  /**
   * Applies a direct world state category rename to the snapshot.
   * @returns A new, updated GameSnapshot.
   */
  applyCategoryRename(snapshot: GameSnapshot, oldName: string, newName: string): GameSnapshot;

  /**
   * Applies a direct world state entity rename to the snapshot.
   * @returns A new, updated GameSnapshot.
   */
  applyEntityRename(snapshot: GameSnapshot, category: string, oldName: string, newName: string): GameSnapshot;
  
  // ... other direct edit methods
  applyCategoryDelete(snapshot: GameSnapshot, category: string): GameSnapshot;
  applyEntityDelete(snapshot: GameSnapshot, category: string, entity: string): GameSnapshot;
  applyKeyValueEdit(snapshot: GameSnapshot, key: string, value: any): GameSnapshot;
  applyKeyDelete(snapshot: GameSnapshot, key: string): GameSnapshot;
}
@@FILE: src/logic/ITurnProcessor.ts
// src/logic/ITurnProcessor.ts

import { PromptCard } from '../models/PromptCard';
import { GameState } from '../models/GameState';
import { LogEntry } from '../models/LogEntry';
import { Message } from '../models/Message';
import { AiConnection } from '../models/AiConnection';
import { ParsedNarrationOutput } from '../models/ParsedNarrationOutput';
import { TokenSummary } from '../models/LogEntryElements';

/**
 * Defines the contract for processing individual game turns, including AI interaction.
 */
export interface ITurnProcessor {
  /**
   * Processes the first turn of a new game, generating the initial AI response and log.
   * @param userId The ID of the current user.
   * @param card The PromptCard used for the game.
   * @param initialGameState The initial game state.
   * @param useDummyNarrator Flag to use a dummy AI.
   * @param aiConnections User's configured AI connections.
   * @returns A Promise resolving with the parsed AI output, the generated log entry, and token usage.
   */
  processFirstTurnNarratorResponse(
    userId: string,
    card: PromptCard,
    initialGameState: GameState,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[],
  ): Promise<{
    parsedOutput: ParsedNarrationOutput;
    logEntry: LogEntry;
    aiRawOutput: string;
    tokenUsage: TokenSummary | null;
  }>;

  /**
   * Processes a player's action, generating the AI response and updating conversation history/logs.
   * @param userId The ID of the current user.
   * @param card The PromptCard used for the game.
   * @param currentGameState The current game state before the turn.
   * @param logs The current game logs.
   * @param conversationHistory The current conversation history.
   * @param action The player's input string.
   * @param turnNumber The current turn number.
   * @param useDummyNarrator Flag to use a dummy AI.
   * @param aiConnections User's configured AI connections.
   * @returns A Promise resolving with the parsed AI output, the generated log entry, and token usage.
   */
  processPlayerTurn(
    userId: string,
    card: PromptCard,
    currentGameState: GameState,
    logs: LogEntry[],
    conversationHistory: Message[],
    action: string,
    turnNumber: number,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[],
  ): Promise<{
    parsedOutput: ParsedNarrationOutput;
    logEntry: LogEntry;
    aiRawOutput: string;
    tokenUsage: TokenSummary | null;
  }>;
}
@@FILE: src/logic/SnapshotUpdater.ts
// src/logic/SnapshotUpdater.ts
import { produce } from 'immer';
import { GameSnapshot, GameState } from '../models';
import { IGameStateManager } from './IGameStateManager';
import { ISnapshotUpdater, ITurnResult } from './ISnapshotUpdater';

export class SnapshotUpdater implements ISnapshotUpdater {
  constructor(private gameStateManager: IGameStateManager) {}

  public applyTurnResultToSnapshot(snapshot: GameSnapshot, turnResult: ITurnResult): GameSnapshot {
    const { parsedOutput, logEntry, playerAction } = turnResult;

    return produce(snapshot, draft => {
      // 1. Apply deltas and scene changes to get the next game state
      let stateAfterDeltas = this.gameStateManager.applyDeltasToGameState(draft.gameState, parsedOutput.deltas);
      let finalGameState = this.gameStateManager.updateSceneState(stateAfterDeltas, parsedOutput.scene, parsedOutput.deltas);

      // 2. Update the narration within the new game state
      finalGameState.narration = parsedOutput.prose;
      draft.gameState = finalGameState;

      // 3. Update conversation history
      if (playerAction) {
        draft.conversationHistory.push({ role: 'user', content: playerAction });
      }
      draft.conversationHistory.push({ role: 'assistant', content: parsedOutput.prose });
      
      // 4. Add the new log entry
      draft.logs.push(logEntry);

      // 5. Increment turn and update timestamp
      draft.currentTurn += 1;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyCategoryRename(snapshot: GameSnapshot, oldName: string, newName: string): GameSnapshot {
    return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.renameCategory(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        oldName,
        newName
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyEntityRename(snapshot: GameSnapshot, category: string, oldName: string, newName: string): GameSnapshot {
    return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.renameEntity(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category,
        oldName,
        newName
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }
  
  public applyCategoryDelete(snapshot: GameSnapshot, category: string): GameSnapshot {
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteCategory(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyEntityDelete(snapshot: GameSnapshot, category: string, entity: string): GameSnapshot {
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteEntity(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category,
        entity
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyKeyValueEdit(snapshot: GameSnapshot, key: string, value: any): GameSnapshot {
     return produce(snapshot, draft => {
      draft.gameState.worldState = this.gameStateManager.editKeyValue(
        draft.gameState.worldState,
        key,
        value
      );
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyKeyDelete(snapshot: GameSnapshot, key: string): GameSnapshot {
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteKey(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        key
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }
}
@@FILE: src/logic/TurnProcessor.ts
// src/logic/TurnProcessor.ts

import { AiConnection, GameState, LogEntry, Message, ParsedNarrationOutput, PromptCard, TokenSummary } from '../models';
import { AiSettings } from '../models/PromptCard';
import { IAiClient } from './aiClient';
import { parseNarratorOutput } from './deltaParser';
import { ILogManager } from './logManager';
import { IPromptBuilder } from './promptBuilder';
import { ITurnProcessor } from './ITurnProcessor';


// Define a simple DummyAiClient for testing and dev
class DummyAiClient implements IAiClient {
  async generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string> {
    console.log("Dummy Narrator: Simulating AI response...");
    // Find the LAST message with role 'user'
    const lastUserMessage = messages.slice().reverse().find(m => m.role === 'user')?.content || 'No user input.';
    const dummyResponse = {
      choices: [{
        message: {
          // MODIFIED: Dummy response to test all emits and match the expected structure with fences
          content: `The dummy narrator observes your action: "${lastUserMessage}". A ripple of arcane energy flows through the air, subtly shifting the very fabric of reality around you. You hear a distant chime, and a curious, ancient tome appears at your feet.

@digest
\`\`\`json
[
  { "text": "The world reacted to your input: '${lastUserMessage}'.", "importance": 2 },
  { "text": "Something new has manifested nearby: the $enchanted_quill.", "importance": 4, "tags": ["$enchanted_quill"] },
  { "text": "#Brom's disposition shifted slightly.", "importance": 3, "tags": ["#brom"] },
  { "text": "A critical system event occurred, requiring your attention!", "importance": 5 }
]
\`\`\`

@delta
\`\`\`json
{
  "=player.hp": 85,
  "+player.gold": 5,
  "!items.$enchanted_quill.description": "A quill that seems to hum with forgotten magic, vibrating faintly.",
  "-npcs.#old_sage.wisdom" : true,
  "=player.status": "observant"
}
\`\`\`

@scene
\`\`\`json
{
  "location": "@forest_clearing",
  "present": ["#you", "#lyrielle", "$enchanted_quill"],
  "weather": "clear and crisp"
}
\`\`\`
`
        }
      }],
      usage: {
        prompt_tokens: 10,
        completion_tokens: 150, // Increased for a longer response
        total_tokens: 160,
      }
    };
    return Promise.resolve(JSON.stringify(dummyResponse)); // Return as stringified JSON
  }

  async testConnection(connection: AiConnection): Promise<boolean> {
    return Promise.resolve(true); // Dummy always passes test
  }
}


export class TurnProcessor implements ITurnProcessor {
  private realAiClient: IAiClient;
  private dummyAiClient: IAiClient;
  private builder: IPromptBuilder;
  private logManager: ILogManager;

  constructor(
    aiClient: IAiClient,
    promptBuilder: IPromptBuilder,
    logManager: ILogManager
  ) {
    this.realAiClient = aiClient;
    this.builder = promptBuilder;
    this.logManager = logManager;
    this.dummyAiClient = new DummyAiClient();
  }

  private async executeAiCall(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings,
    useDummyNarrator: boolean
  ): Promise<{ aiRawOutput: string; tokenUsage: TokenSummary | null; fullResponse: string }> {
    const activeClient = useDummyNarrator ? this.dummyAiClient : this.realAiClient;
    const fullResponse = await activeClient.generateCompletion(connection, messages, settings);

    let aiRawOutput = '';
    let tokenUsage: TokenSummary | null = null;
    try {
      const parsedJson = JSON.parse(fullResponse);
      aiRawOutput = parsedJson.choices?.[0]?.message?.content?.trim() || fullResponse;
      tokenUsage = parsedJson.usage ? {
        inputTokens: parsedJson.usage.prompt_tokens || 0,
        outputTokens: parsedJson.usage.completion_tokens || 0,
        totalTokens: parsedJson.usage.total_tokens || 0,
      } : null;
    } catch (e) {
      aiRawOutput = fullResponse;
    }
    return { aiRawOutput, tokenUsage, fullResponse };
  }

  async processFirstTurnNarratorResponse(
    userId: string,
    card: PromptCard,
    initialGameState: GameState,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[]
  ): Promise<{ parsedOutput: ParsedNarrationOutput; logEntry: LogEntry; aiRawOutput: string; tokenUsage: TokenSummary | null; }> {
    const messagesToSend = this.builder.buildFirstTurnPrompt(card);
    const contextSnapshotForLog = JSON.stringify(messagesToSend, null, 2);
    const userInputForLog = card.firstTurnOnlyBlock || "Begin the story.";

    const connection = aiConnections.find(c => c.id === card.aiSettings.selectedConnectionId);
    if (!connection && !useDummyNarrator) {
      throw new Error(`AI connection ${card.aiSettings.selectedConnectionId} not found.`);
    }

    const startTime = performance.now();
    const { aiRawOutput, tokenUsage, fullResponse } = await this.executeAiCall(connection!, messagesToSend, card.aiSettings, useDummyNarrator);
    const latencyMs = Math.round(performance.now() - startTime);

    const parsedOutput = parseNarratorOutput(aiRawOutput);

    const logEntry = this.logManager.assembleTurnLogEntry({
      turnNumber: 0,
      userInput: userInputForLog,
      rawNarratorOutput: aiRawOutput,
      parsedOutput: parsedOutput,
      contextSnapshot: contextSnapshotForLog,
      tokenUsage: tokenUsage,
      aiSettings: card.aiSettings,
      apiRequestBody: JSON.stringify({ model: connection?.modelSlug, messages: "..." }, null, 2),
      apiResponseBody: fullResponse,
      apiUrl: connection ? new URL("chat/completions", connection.apiUrl).href : 'dummy-url',
      latencyMs: latencyMs,
      modelSlugUsed: connection?.modelSlug || 'dummy-model',
    });

    return { parsedOutput, logEntry, aiRawOutput, tokenUsage };
  }

  async processPlayerTurn(
    userId: string,
    card: PromptCard,
    currentGameState: GameState,
    logs: LogEntry[],
    conversationHistory: Message[],
    action: string,
    turnNumber: number,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[]
  ): Promise<{ parsedOutput: ParsedNarrationOutput; logEntry: LogEntry; aiRawOutput: string; tokenUsage: TokenSummary | null; }> {
    const messagesToSend = this.builder.buildEveryTurnPrompt(
      card,
      currentGameState,
      logs,
      conversationHistory,
      action,
      turnNumber
    );
    const contextSnapshotForLog = JSON.stringify(messagesToSend, null, 2);

    const connection = aiConnections.find(c => c.id === card.aiSettings.selectedConnectionId);
    if (!connection && !useDummyNarrator) {
      throw new Error(`AI connection ${card.aiSettings.selectedConnectionId} not found.`);
    }

    const startTime = performance.now();
    const { aiRawOutput, tokenUsage, fullResponse } = await this.executeAiCall(connection!, messagesToSend, card.aiSettings, useDummyNarrator);
    const latencyMs = Math.round(performance.now() - startTime);

    const parsedOutput = parseNarratorOutput(aiRawOutput);

    const logEntry = this.logManager.assembleTurnLogEntry({
      turnNumber: turnNumber,
      userInput: action,
      rawNarratorOutput: aiRawOutput,
      parsedOutput: parsedOutput,
      contextSnapshot: contextSnapshotForLog,
      tokenUsage: tokenUsage,
      aiSettings: card.aiSettings,
      apiRequestBody: JSON.stringify({ model: connection?.modelSlug, messages: "..." }, null, 2),
      apiResponseBody: fullResponse,
      apiUrl: connection ? new URL("chat/completions", connection.apiUrl).href : 'dummy-url',
      latencyMs: latencyMs,
      modelSlugUsed: connection?.modelSlug || 'dummy-model',
    });

    return { parsedOutput, logEntry, aiRawOutput, tokenUsage };
  }
}
@@FILE: src/logic/aiClient.ts
// src/logic/aiClient.ts

import type { Message } from '../models/Message';
import type { AiSettings } from '../models/PromptCard';
import type { AiConnection } from '../models/AiConnection';

/**
 * Interface defining the contract for an AI client.
 */
export interface IAiClient {
  /**
   * Sends a completion request to the AI API.
   * @param connection The AiConnection details (URL, API key).
   * @param messages The array of messages forming the conversation context.
   * @param settings The AI settings for this specific call (temperature, etc.).
   * @returns A Promise that resolves with the raw text content of the AI's response (or stringified JSON if full response).
   */
  generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string>; // Changed return type to string to hold raw JSON or content

  /**
   * Tests an AI connection by making a minimal API call.
   * @param connection The AiConnection details to test.
   * @returns A Promise that resolves to true if the connection is successful, false otherwise.
   */
  testConnection(connection: AiConnection): Promise<boolean>;
}

/**
 * Concrete implementation of IAiClient using the browser's fetch API.
 * This directly replaces the Retrofit/OkHttp logic from AINarrator.kt.
 */
class AiClient implements IAiClient {
  async generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string> { // Now returns raw string, expecting JSON from most APIs
    if (!connection.apiToken || connection.apiToken === "YOUR_DEEPSEEK_API_KEY_HERE" || connection.apiToken === "MISSING_API_KEY") {
      throw new Error("AI API key is missing or not configured. Please set it in Settings.");
    }

    const apiUrl = new URL("chat/completions", connection.apiUrl).href;

    const requestBody = {
      model: connection.modelSlug,
      messages: messages,
      temperature: settings.temperature,
      top_p: settings.topP,
      max_tokens: settings.maxTokens,
      presence_penalty: settings.presencePenalty,
      frequency_penalty: settings.frequencyPenalty,
      stream: false, // For now, we're not streaming
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.apiToken}`,
          // User-Agent if provided
          ...(connection.userAgent && { 'User-Agent': connection.userAgent }),
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        console.error("AI API Error Response:", errorBody);
        throw new Error(`AI API request failed with status ${response.status}: ${response.statusText}. Details: ${errorBody.substring(0, 200)}...`);
      }

      const responseJson = await response.json();
      // Return the full stringified JSON response for gameSession to parse token usage etc.
      return JSON.stringify(responseJson);
    } catch (error: unknown) {
        let errorMessage = "An unknown error occurred";
        if (error instanceof Error) {
            errorMessage = error.message;
        }
        console.error("Failed to make AI API call:", error);
        throw new Error(`Network error or AI API failure: ${errorMessage}`);
    }
  }

  async testConnection(connection: AiConnection): Promise<boolean> {
    if (!connection.apiToken || connection.apiToken === "YOUR_DEEPSEEK_API_KEY_HERE" || connection.apiToken === "MISSING_API_KEY") {
      return false; // Cannot test without a valid key
    }

    const apiUrl = new URL("chat/completions", connection.apiUrl).href;
    const testMessage: Message[] = [{ role: 'user', content: 'hello' }];

    const requestBody = {
      model: connection.modelSlug,
      messages: testMessage,
      max_tokens: 10, // Smallest possible request
      temperature: 0.1,
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${connection.apiToken}`,
          ...(connection.userAgent && { 'User-Agent': connection.userAgent }),
        },
        body: JSON.stringify(requestBody),
      });

      // A 2xx status code indicates success, even if the response content is minimal
      if (response.ok) {
        const responseJson = await response.json();
        // Optionally, check for expected content in the response.
        // For a basic test, just success status is enough.
        console.log("AI Connection Test Success:", responseJson);
        return true;
      } else {
        const errorBody = await response.text();
        console.warn(`AI Connection Test Failed (Status: ${response.status}):`, errorBody);
        return false;
      }
    } catch (error) {
      console.error("AI Connection Test Network Error:", error);
      return false;
    }
  }
}

// Export a singleton instance of the AI client.
export const aiClient = new AiClient();
@@FILE: src/logic/cardManager.ts
// src/logic/cardManager.ts

import { PromptCard, NewPromptCardData } from '../models/PromptCard';
import { generateUuid } from '../utils/uuid';
import { generateContentHash, getPromptCardContentForHash } from '../utils/hash';
import { promptCardRepository, IPromptCardRepository } from '../data/repositories/promptCardRepository';
import {
  defaultAiSettingsInCard,
  defaultStackInstructions,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../data/config/promptCardDefaults';

/**
 * Interface defining the contract for the Card Manager.
 * This can be useful for testing or providing different implementations (e.g., a mock manager).
 */
export interface ICardManager {
  /**
   * Creates a brand new PromptCard with default values for unspecified fields.
   * Generates new IDs and hash, sets creation/update timestamps.
   * @param userId The ID of the user creating the card.
   * @param data The initial data for the new card.
   * @returns A Promise resolving with the newly created PromptCard.
   */
  createNewPromptCard(userId: string, data: NewPromptCardData): Promise<PromptCard>;

  /**
   * Updates an existing PromptCard. Recalculates the content hash and updates the timestamp.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the card to update.
   * @param updates The partial PromptCard data to apply.
   * @returns A Promise resolving with the updated PromptCard or null if not found.
   */
  updatePromptCard(userId: string, cardId: string, updates: Partial<PromptCard>): Promise<PromptCard | null>;

  /**
   * Duplicates an existing PromptCard, creating a new card with a new ID
   * but linking it to the original's lineage (parentId, rootId).
   * @param userId The ID of the user performing the duplication.
   * @param sourceCardId The ID of the card to duplicate.
   * @returns A Promise resolving with the new, duplicated PromptCard or null if source not found.
   */
  duplicatePromptCard(userId: string, sourceCardId: string): Promise<PromptCard | null>;

  /**
   * Deletes a PromptCard.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the card to delete.
   * @returns A Promise resolving when the card is deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Retrieves a single PromptCard.
   * @param userId The ID of the user.
   * @param cardId The ID of the card.
   * @returns A Promise resolving with the PromptCard or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a user.
   * @param userId The ID of the user.
   * @returns A Promise resolving with an array of PromptCards.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Exports a single PromptCard for sharing/download.
   * This might involve stripping user-specific metadata like ownerId for public sharing.
   * For now, it simply returns the card, but can be extended.
   * @param userId The ID of the user exporting.
   * @param cardId The ID of the card to export.
   * @returns A Promise resolving with the PromptCard or null.
   */
  exportPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Imports PromptCards from a provided list (e.g., from a JSON file).
   * This involves generating new IDs, re-calculating hashes, setting ownerId,
   * and linking lineage appropriately.
   * @param userId The ID of the user importing.
   * @param importedCardsData An array of NewPromptCardData (or similar) from the import source.
   * @returns A Promise resolving with an array of the newly imported PromptCards.
   */
  importPromptCards(userId: string, importedCardsData: NewPromptCardData[]): Promise<PromptCard[]>;
}

/**
 * Concrete implementation of ICardManager.
 */
export class PromptCardManager implements ICardManager {
  constructor(private repo: IPromptCardRepository) {}

  private async buildPromptCard(userId: string, data: NewPromptCardData, existingCard?: PromptCard): Promise<PromptCard> {
    const now = new Date().toISOString();
    let cardId: string;
    let rootId: string;
    let parentId: string | null;
    let createdAt: string;

    if (existingCard) {
      // This path is for updates, or duplicating where we are basing off an existing structure
      cardId = existingCard.id;
      rootId = existingCard.rootId;
      parentId = existingCard.parentId; // Parent ID remains the same for updates
      createdAt = existingCard.createdAt;
    } else {
      // This path is for new creations or imports that need new IDs
      cardId = generateUuid();
      rootId = cardId; // For brand new cards, rootId is its own ID
      parentId = null; // No parent for brand new cards
      createdAt = now;
    }

    // Handle stackInstructions: if provided as string, parse it; otherwise use object or default.
    let parsedStackInstructions: StackInstructions;
    if (typeof data.stackInstructions === 'string') {
      try {
        parsedStackInstructions = JSON.parse(data.stackInstructions);
      } catch (e) {
        console.error("Error parsing stackInstructions string for new card, falling back to default:", e);
        parsedStackInstructions = defaultStackInstructions;
      }
    } else if (data.stackInstructions) {
      parsedStackInstructions = data.stackInstructions;
    } else {
      parsedStackInstructions = defaultStackInstructions;
    }

    // Construct the card with defaults applied where data is missing
    const tempCard: PromptCard = {
      id: cardId,
      rootId: rootId,
      parentId: parentId,
      ownerId: userId,
      createdAt: createdAt,
      updatedAt: now, // Always update timestamp on creation/modification
      title: data.title,
      prompt: data.prompt,
      description: data.description ?? null,
      firstTurnOnlyBlock: data.firstTurnOnlyBlock ?? DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: parsedStackInstructions,
      emitSkeleton: data.emitSkeleton ?? DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: data.worldStateInit ?? "",
      gameRules: data.gameRules ?? "",
      aiSettings: { ...defaultAiSettingsInCard, ...data.aiSettings },
      helperAiSettings: { ...defaultAiSettingsInCard, ...data.helperAiSettings },
      isHelperAiEnabled: data.isHelperAiEnabled ?? false, // NEW: Initialize with default false
      tags: data.tags ?? [],
      isExample: data.isExample ?? false,
      functionDefs: data.functionDefs ?? "",
      isPublic: data.isPublic ?? false, // Default to private for new user-created cards
      contentHash: '', // Will be calculated below
    };

    // Calculate content hash AFTER all content fields are finalized
    tempCard.contentHash = generateContentHash(getPromptCardContentForHash(tempCard));

    return tempCard;
  }

  async createNewPromptCard(userId: string, data: NewPromptCardData): Promise<PromptCard> {
    const newCard = await this.buildPromptCard(userId, data);
    await this.repo.savePromptCard(userId, newCard);
    return newCard;
  }

  async updatePromptCard(userId: string, cardId: string, updates: Partial<PromptCard>): Promise<PromptCard | null> {
    const existingCard = await this.repo.getPromptCard(userId, cardId);
    if (!existingCard) {
      return null;
    }

    // Apply updates
    const updatedCardData = { ...existingCard, ...updates };

    // Re-calculate hash based on potentially changed content fields
    const newContentHash = generateContentHash(getPromptCardContentForHash(updatedCardData));
    updatedCardData.contentHash = newContentHash;
    updatedCardData.updatedAt = new Date().toISOString(); // Update timestamp on modification

    await this.repo.savePromptCard(userId, updatedCardData);
    return updatedCardData;
  }

  async duplicatePromptCard(userId: string, sourceCardId: string): Promise<PromptCard | null> {
    const sourceCard = await this.repo.getPromptCard(userId, sourceCardId);
    if (!sourceCard) {
      console.warn(`Source card with ID ${sourceCardId} not found for duplication.`);
      return null;
    }

    const newId = generateUuid();
    const now = new Date().toISOString();

    const duplicatedCard: PromptCard = {
      ...sourceCard, // Copy all existing fields
      id: newId, // Assign new ID
      rootId: sourceCard.rootId, // Root remains the same
      parentId: sourceCard.id, // New parent is the source card
      ownerId: userId, // Ensure new owner is current user
      createdAt: now, // New creation timestamp for the duplicate
      updatedAt: now, // New update timestamp
      isExample: false, // Duplicates are user-owned, not examples
      isPublic: false, // Duplicates are private by default
      // isHelperAiEnabled will be copied correctly from sourceCard by the spread operator
    };

    // Recalculate hash for the duplicated card in case any content fields were implicitly changed
    // (e.g., if a previous source card had an older version of stack instructions that parsed differently).
    // Or just for robustness.
    duplicatedCard.contentHash = generateContentHash(getPromptCardContentForHash(duplicatedCard));

    await this.repo.savePromptCard(userId, duplicatedCard);
    console.log(`Card ${sourceCardId} duplicated to ${newId}`);
    return duplicatedCard;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    await this.repo.deletePromptCard(userId, cardId);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    return this.repo.getPromptCard(userId, cardId);
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    return this.repo.getAllPromptCards(userId);
  }

  async exportPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const card = await this.repo.getPromptCard(userId, cardId);
    if (card) {
      // For export, you might want to strip or transform sensitive/user-specific fields.
      // For MVP, we return the full card.
      // E.g., delete card.ownerId; // if it's meant for public template export
    }
    return card;
  }

  async importPromptCards(userId: string, importedCardsData: NewPromptCardData[]): Promise<PromptCard[]> {
    const importedAndProcessedCards: PromptCard[] = [];
    for (const data of importedCardsData) {
      // For imported cards, we generate a new UUID.
      // The parentId and rootId logic for imports needs careful consideration:
      // If the imported card explicitly defines a lineage, we might keep it.
      // If it's a "fresh" import, its rootId becomes its own new ID, parentId is null.
      // For now, let's treat all imports as new roots by default for simplicity,
      // and re-establish lineage if a more complex import format is defined later.
      // OR, if `NewPromptCardData` from import includes original IDs, we could preserve root/parent
      // For MVP, let's assume they are new root cards.
      const newCard = await this.buildPromptCard(userId, data);
      importedAndProcessedCards.push(newCard);
    }
    await this.repo.importPromptCards(userId, importedAndProcessedCards);
    console.log(`Imported ${importedAndProcessedCards.length} cards.`);
    return importedAndProcessedCards;
  }
}

// Export a singleton instance of the manager
export const promptCardManager = new PromptCardManager(promptCardRepository);
@@FILE: src/logic/deltaParser.ts
// src/logic/deltaParser.ts
import type { DeltaInstruction, DeltaMap } from '../models/DeltaInstruction.ts';
import type { DigestLine } from '../models/LogEntryElements.ts';
import type { ParsedNarrationOutput } from '../models/ParsedNarrationOutput.ts';

// Exported Marker constants
export const DELTA_MARKER = "@delta";
export const DIGEST_MARKER = "@digest";
export const SCENE_MARKER = "@scene";

/**
 * Extracts a JSON object from a string, handling potential parsing errors.
 * This function expects the *raw JSON string*, not lines including fences.
 * @param jsonString The raw JSON string.
 * @returns A JSON object, or an empty object on error.
 */
function extractJsonObject(jsonString: string): Record<string, unknown> {
  const text = jsonString.trim();
  if (!text) return {};
  try {
    const parsed = JSON.parse(text);
    return typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed) ? parsed : {};
  } catch (e: unknown) {
    console.error("Failed to parse JSON object:", e, "\nText:", text);
    return {};
  }
}

/**
 * Extracts a JSON array from a string, handling potential parsing errors.
 * This function expects the *raw JSON string*, not lines including fences.
 * @param jsonString The raw JSON string.
 * @returns A JSON array, or an empty array on error.
 */
function extractJsonArray(jsonString: string): unknown[] {
  const text = jsonString.trim();
  if (!text) return [];
  try {
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : [];
  } catch (e: unknown) {
    console.error("Failed to parse JSON array:", e, "\nText:", text);
    return [];
  }
}

/**
 * Extracts content from a markdown-fenced JSON block.
 * Looks for ```json and ```. Also includes a fallback for unfenced blocks
 * if a JSON start character is found immediately after the marker.
 * @param lines The full array of lines from AI output.
 * @param startIndex The index of the marker line (e.g., @delta).
 * @returns The raw JSON string content, or an empty string if not found.
 */
function extractFencedJsonBlock(lines: string[], startIndex: number): string {
    if (startIndex < 0 || startIndex >= lines.length) {
        return "";
    }

    let jsonLines: string[] = [];
    let inJsonBlock = false;
    let fenceFound = false;

    // Start searching from the line *after* the marker
    for (let i = startIndex + 1; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line.startsWith("```")) {
            if (!inJsonBlock) {
                // Found opening fence
                inJsonBlock = true;
                fenceFound = true;
                // If there's content *after* ```json on the same line
                const contentAfterFence = line.substring(line.indexOf('{'));
                if(contentAfterFence.startsWith('{') || contentAfterFence.startsWith('[')) {
                    jsonLines.push(contentAfterFence);
                }
                continue;
            } else {
                // Found closing fence
                break;
            }
        }

        if (inJsonBlock) {
            jsonLines.push(lines[i]);
        } else if (!fenceFound && (line.startsWith("{") || line.startsWith("["))) {
            // If no fence was found yet, but we encounter a JSON start,
            // assume it's an unfenced block and start capturing.
            // This is a fallback for AIs that don't use fences.
            inJsonBlock = true;
            jsonLines.push(lines[i]);
        } else if (inJsonBlock && !fenceFound && !line.startsWith("{") && !line.startsWith("[")) {
            // If we're in an unfenced block but encounter a non-JSON line, stop.
            break;
        }
    }

    return jsonLines.join('\n').trim();
}

/**
 * Parses a key-value pair from the AI's delta JSON into a DeltaInstruction.
 * Corresponds to `DeltaInstruction.fromJsonElement` from the old project.
 * The raw key is expected to be in the format `+player.gold` or `=npcs.goblin.hp`.
 * @param rawKey The raw key from the JSON, e.g., "+player.gold".
 * @param value The JSON value associated with the key.
 * @returns A DeltaInstruction object or null if parsing fails.
 */
function parseSingleDelta(rawKey: string, value: unknown): DeltaInstruction | null {
  const op = rawKey.charAt(0);
  const path = rawKey.substring(1); // The rest of the key, e.g., "player.gold"

  switch (op) {
    case '+':
      return { op: 'add', key: path, value: value };
    case '=':
      return { op: 'assign', key: path, value: value };
    case '!':
      return { op: 'declare', key: path, value: value };
    case '-':
      return { op: 'delete', key: path };
    default:
      console.warn(`Invalid delta operation character '${op}' in key '${rawKey}'`);
      return null;
  }
}

/**
 * Parses the raw AI response string into a structured ParsedNarrationOutput object.
 * This function replicates the logic of `NarrationParser.extractJsonAndCleanNarration`.
 * @param rawAiOutput The full, raw string from the AI model.
 * @returns A ParsedNarrationOutput object.
 */
export function parseNarratorOutput(rawAiOutput: string): ParsedNarrationOutput {
  const lines = rawAiOutput.split('\n');

  const deltaIndex = lines.findIndex(line => line.trim() === DELTA_MARKER);
  const digestIndex = lines.findIndex(line => line.trim() === DIGEST_MARKER);
  const sceneIndex = lines.findIndex(line => line.trim() === SCENE_MARKER);

  const firstMarkerIndex = [deltaIndex, digestIndex, sceneIndex]
    .filter(index => index !== -1)
    .reduce((min, current) => Math.min(min, current), lines.length);

  const prose = lines.slice(0, firstMarkerIndex).join('\n').trim();

  // Use the new helper to extract the raw JSON strings
  const deltaJsonString = extractFencedJsonBlock(lines, deltaIndex);
  const digestJsonString = extractFencedJsonBlock(lines, digestIndex);
  const sceneJsonString = extractFencedJsonBlock(lines, sceneIndex);

  const deltaJson = extractJsonObject(deltaJsonString);
  const digestJson = extractJsonArray(digestJsonString);
  const sceneJson = extractJsonObject(sceneJsonString);

  // --- Parse Deltas ---
  const deltas: DeltaMap = {};
  for (const key in deltaJson) {
    const instruction = parseSingleDelta(key, deltaJson[key]);
    if (instruction) {
      deltas[key] = instruction;
    }
  }

  // --- Parse Digest Lines ---
  const digestLines: DigestLine[] = digestJson.map((item) => {
    const { text = '', importance } = item as { text?: string; importance?: number };
    const finalImportance = typeof importance === 'number' ? importance : 3;
    // Extract tags from text using regex, as in original NarrationParser
    const tagPattern = /[#@$][a-zA-Z0-9_]+/g;
    const tags = text.match(tagPattern) || [];
    return { text, importance: finalImportance, tags };
  }).filter(line => line.text); // Filter out empty lines

  return {
    prose,
    deltas,
    digestLines,
    scene: sceneJson,
  };
}
@@FILE: src/logic/gameSession.ts
// src/logic/gameSession.ts
import { IGameRepository } from '../data/repositories/gameRepository';
import { IPromptCardRepository } from '../data/repositories/promptCardRepository';
import { GameSnapshot, GameState, LogEntry, Message, PromptCard } from '../models';
import { formatIsoDateForDisplay } from '../utils/formatDate';
import { generateUuid } from '../utils/uuid';
import { ITurnProcessor } from './ITurnProcessor';
import { ISnapshotUpdater } from './ISnapshotUpdater';

// NOTE: The IGameSession interface remains UNCHANGED, so it won't break the store.
export interface IGameSession {
  initializeGame(userId: string, cardId: string, existingSnapshotId?: string): Promise<void>;
  processPlayerAction(action: string, useDummyNarrator: boolean): Promise<GameSnapshot>;
  processFirstNarratorTurn(useDummyNarrator: boolean): Promise<GameSnapshot>;
  getCurrentGameSnapshot(): GameSnapshot | null;
  saveGame(snapshot: GameSnapshot): Promise<void>;
  loadGame(userId: string, snapshotId: string): Promise<void>;
  loadLastActiveGame(userId: string): Promise<boolean>;
  getCurrentPromptCard(): PromptCard | null;
  getCurrentGameState(): GameState | null;
  getGameLogs(): LogEntry[];
  gameRepo: IGameRepository;
  renameWorldCategory(oldName: string, newName: string): Promise<GameSnapshot | null>;
  renameWorldEntity(category: string, oldName: string, newName: string): Promise<GameSnapshot | null>;
  deleteWorldCategory(category: string): Promise<GameSnapshot | null>;
  deleteWorldEntity(category: string, entity: string): Promise<GameSnapshot | null>;
  editWorldKeyValue(key: string, value: any): Promise<GameSnapshot | null>;
  deleteWorldKey(key: string): Promise<GameSnapshot | null>;
}

export class GameSession implements IGameSession {
  private currentUserId: string | null = null;
  private currentSnapshot: GameSnapshot | null = null;
  private currentPromptCard: PromptCard | null = null;

  constructor(
    public gameRepo: IGameRepository, // Keep public for settings screen
    private cardRepo: IPromptCardRepository,
    private turnProcessor: ITurnProcessor,
    private snapshotUpdater: ISnapshotUpdater
  ) {}

  public async initializeGame(userId: string, cardId: string, existingSnapshotId?: string): Promise<void> {
    console.log(`GameSession: Initializing game. User: ${userId}, Card: ${cardId}, Snapshot: ${existingSnapshotId}`);
    this.currentUserId = userId;

    if (existingSnapshotId) {
      await this.loadGame(userId, existingSnapshotId);
      return;
    }

    const card = await this.cardRepo.getPromptCard(userId, cardId);
    if (!card) throw new Error(`PromptCard with ID ${cardId} not found.`);
    this.currentPromptCard = card;

    let initialWorldState = {};
    try {
      if (card.worldStateInit) initialWorldState = JSON.parse(card.worldStateInit);
    } catch (e) {
      console.error("Failed to parse worldStateInit JSON:", e);
    }
    
    const now = new Date().toISOString();
    const firstTurnProse = card.firstTurnOnlyBlock || "The story begins...";

    const initialSnapshot: GameSnapshot = {
      id: generateUuid(),
      userId: userId,
      promptCardId: cardId,
      title: `Game with ${card.title} - ${formatIsoDateForDisplay(now)}`,
      createdAt: now,
      updatedAt: now,
      currentTurn: 0,
      gameState: {
        narration: firstTurnProse,
        worldState: initialWorldState,
        scene: { location: null, present: [] },
      },
      conversationHistory: [{ role: 'assistant', content: firstTurnProse }],
      logs: [],
      worldStatePinnedKeys: [],
    };

    this.currentSnapshot = initialSnapshot;
    console.log(`GameSession: New game initialized with ID ${initialSnapshot.id}.`);
  }

  public async processFirstNarratorTurn(useDummyNarrator: boolean): Promise<GameSnapshot> {
    if (!this.currentSnapshot || !this.currentUserId || !this.currentPromptCard) {
      throw new Error("Cannot process first turn: Game not initialized correctly.");
    }
    
    const aiConnections = await this.gameRepo.getAiConnections(this.currentUserId);
    const turnResult = await this.turnProcessor.processFirstTurnNarratorResponse(
      this.currentUserId,
      this.currentPromptCard,
      this.currentSnapshot.gameState,
      useDummyNarrator,
      aiConnections
    );

    const newSnapshot = this.snapshotUpdater.applyTurnResultToSnapshot(this.currentSnapshot, turnResult);
    
    this.currentSnapshot = newSnapshot;
    await this.saveGame(newSnapshot);
    return newSnapshot;
  }

  public async processPlayerAction(action: string, useDummyNarrator: boolean): Promise<GameSnapshot> {
    if (!this.currentSnapshot || !this.currentUserId || !this.currentPromptCard) {
      throw new Error("Cannot process player action: Game not initialized correctly.");
    }

    const aiConnections = await this.gameRepo.getAiConnections(this.currentUserId);
    const turnResult = await this.turnProcessor.processPlayerTurn(
      this.currentUserId,
      this.currentPromptCard,
      this.currentSnapshot.gameState,
      this.currentSnapshot.logs,
      this.currentSnapshot.conversationHistory,
      action,
      this.currentSnapshot.currentTurn,
      useDummyNarrator,
      aiConnections
    );
    
    const newSnapshot = this.snapshotUpdater.applyTurnResultToSnapshot(this.currentSnapshot, { ...turnResult, playerAction: action });
    
    this.currentSnapshot = newSnapshot;
    await this.saveGame(newSnapshot);
    return newSnapshot;
  }

  private async updateAndSave(updater: (snapshot: GameSnapshot) => GameSnapshot): Promise<GameSnapshot | null> {
    if (!this.currentSnapshot) return null;
    const newSnapshot = updater(this.currentSnapshot);
    this.currentSnapshot = newSnapshot;
    await this.saveGame(newSnapshot);
    return newSnapshot;
  }

  public async renameWorldCategory(oldName: string, newName: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyCategoryRename(snap, oldName, newName));
  }

  public async renameWorldEntity(category: string, oldName: string, newName: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyEntityRename(snap, category, oldName, newName));
  }

  public async deleteWorldCategory(category: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyCategoryDelete(snap, category));
  }

  public async deleteWorldEntity(category: string, entity: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyEntityDelete(snap, category, entity));
  }

  public async editWorldKeyValue(key: string, value: any): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyKeyValueEdit(snap, key, value));
  }

  public async deleteWorldKey(key: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyKeyDelete(snap, key));
  }

  // --- Loading, Saving, and Getters (Largely Unchanged) ---

  public async loadGame(userId: string, snapshotId: string): Promise<void> {
    const snapshot = await this.gameRepo.getGameSnapshot(userId, snapshotId);
    if (!snapshot) throw new Error(`Game snapshot ${snapshotId} not found.`);
    const card = await this.cardRepo.getPromptCard(userId, snapshot.promptCardId);
    if (!card) throw new Error(`PromptCard ${snapshot.promptCardId} not found.`);
    
    this.currentUserId = userId;
    this.currentSnapshot = snapshot;
    this.currentPromptCard = card;
  }

  public async loadLastActiveGame(userId: string): Promise<boolean> {
    const allSnapshots = await this.gameRepo.getAllGameSnapshots(userId);
    if (allSnapshots.length > 0) {
      await this.loadGame(userId, allSnapshots[0].id);
      return true;
    }
    return false;
  }

  public async saveGame(snapshot: GameSnapshot): Promise<void> {
    if (!this.currentUserId) throw new Error("User not initialized.");
    await this.gameRepo.saveGameSnapshot(this.currentUserId, snapshot);
  }

  public getCurrentGameSnapshot = () => this.currentSnapshot;
  public getCurrentPromptCard = () => this.currentPromptCard;
  public getCurrentGameState = () => this.currentSnapshot?.gameState || null;
  public getGameLogs = () => this.currentSnapshot?.logs || [];
}
@@FILE: src/logic/gameSessionServices.ts
// src/logic/gameSessionServices.ts
import { GameStateManager } from './GameStateManager.ts';
import { SnapshotUpdater } from './SnapshotUpdater.ts'; // CORRECTED
import { TurnProcessor } from './TurnProcessor.ts';
import { aiClient } from './aiClient.ts';
import { logManager } from './logManager.ts';
import { promptBuilder } from './promptBuilder.ts';

// Instantiate all the core logic services here to be used by GameSession
const gameStateManager = new GameStateManager();
export const snapshotUpdater = new SnapshotUpdater(gameStateManager);
export const turnProcessor = new TurnProcessor(aiClient, promptBuilder, logManager);
@@FILE: src/logic/logManager.ts
// src/logic/logManager.ts

import type{ LogEntry } from '../models/LogEntry';
import type{ ParsedNarrationOutput } from '../models/ParsedNarrationOutput';
import type{ AiSettings, PromptCard } from '../models/PromptCard'; // For AI settings from the card
import type{ DeltaInstruction, DeltaMap } from '../models/DeltaInstruction'; // For the DeltaMap type
import type{ DigestLine, TokenSummary, LogErrorFlag } from '../models/LogEntryElements'; // For related types
import { DELTA_MARKER } from './deltaParser'; // Import DELTA_MARKER

/**
 * Interface defining the contract for the Log Manager.
 */
export interface ILogManager {
 /**
  * Assembles a complete LogEntry for a single turn of the game.
  * This centralizes the logic from TurnLogAssembler and DigestManager.addParsedLines.
  * @param params An object containing all necessary data for the log entry.
  * @returns A fully constructed LogEntry object.
  */
 assembleTurnLogEntry(params: {
  turnNumber: number;
  userInput: string;
  rawNarratorOutput: string;
  parsedOutput: ParsedNarrationOutput; // Output from deltaParser.ts
  contextSnapshot: string; // The full prompt string sent to AI
  tokenUsage: TokenSummary | null;
  aiSettings: AiSettings; // The AI settings used for this turn
  apiRequestBody: string | null;
  apiResponseBody: string | null;
  apiUrl: string | null;
  latencyMs: number | null;
  modelSlugUsed: string;
 }): LogEntry;

 /**
  * Infers digest lines from deltas if no explicit digest was provided by the AI.
  * Replicates logic from DigestManager.addParsedLines.
  * @param deltas The map of DeltaInstruction objects.
  * @param prose Optional: the prose of the turn, for extracting first line as digest.
  * @returns An array of inferred DigestLine objects.
  */
 inferDigestLinesFromDeltas(deltas: DeltaMap, prose?: string): DigestLine[];
}

/**
 * Concrete implementation of ILogManager.
 */
class LogManager implements ILogManager {

 inferDigestLinesFromDeltas(deltas: DeltaMap, prose?: string): DigestLine[] {
  const inferredDigests: DigestLine[] = [];

  if (Object.keys(deltas).length === 0) {
   return inferredDigests;
  }

  for (const rawKey in deltas) {
   const instruction = deltas[rawKey];
   let score = 1; // Default low importance

   // Logic from DigestManager.addParsedLines to infer importance
   if (rawKey.startsWith("player.")) {
    score = 5; // Player-related changes are critical
   } else if (rawKey.startsWith("world.")) {
    score = 5; // World-related changes are critical
   } else if (rawKey.includes(".flags.")) {
    score = 4;
   } else if (rawKey.includes(".status")) {
    score = 3;
   } else if (rawKey.startsWith("+") || rawKey.startsWith("!")) {
    score = 2; // Add or Declare operations
   }

   // Logic from DeltaInstruction.toLogValue() for summary text
   let summaryText = `Unknown delta operation: ${rawKey}`;
   if (instruction.op === 'assign') {
    summaryText = `Set ${instruction.key} = ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'add') {
    summaryText = `Added to ${instruction.key}: ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'declare') {
    // Inferred tag logic, similar to DigestManager
    let taggableKey = instruction.key;
    const pathParts = instruction.key.split(".");
    if (pathParts.length >= 2) {
      const category = pathParts[0];
      const entity = pathParts[1];
      // Infer if this is a character or location declaration for a summary
      const valueAsObject = instruction.value as Record<string, any>;
      if (valueAsObject && (valueAsObject.tag === "character" || valueAsObject.tag === "location")) {
        taggableKey = (valueAsObject.tag === "character" ? "#" : "@") + entity;
      }
    }
    summaryText = `Declared ${taggableKey} as ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'delete') {
    summaryText = `Removed ${instruction.key}`;
   }

  const tags = this.extractTags(summaryText); // Extract tags from the generated summary
    // MODIFIED: Use `importance: score` to match the DigestLine model
   inferredDigests.push({ text: summaryText, importance: score, tags });
  }

  // Optional prose line extraction from DigestManager.addParsedLines
  if (prose && prose.trim().length > 10) {
   const firstLine = prose.trim().split(/[.!?\n]/).find(line => line.trim().length > 10)?.trim();
   if (firstLine) {
    const tags = this.extractTags(firstLine);
      // MODIFIED: Use `importance: 3`
    inferredDigests.push({ text: firstLine, importance: 3, tags });
   }
  }

  // Assign consistent turn number AFTER all are collected
  // MODIFIED: Remove turn property, as it's not in the DigestLine model. It's part of the parent LogEntry.
  return inferredDigests;
}

 private extractTags(text: string): string[] {
  const tagPattern = /[#@$][a-zA-Z0-9_]+/g; // Global flag to find all matches
  const matches = text.match(tagPattern);
  return matches || [];
 }

 assembleTurnLogEntry(params: {
  turnNumber: number;
  userInput: string;
  rawNarratorOutput: string;
  parsedOutput: ParsedNarrationOutput;
  contextSnapshot: string;
  tokenUsage: TokenSummary | null;
  aiSettings: AiSettings;
  apiRequestBody: string | null;
  apiResponseBody: string | null;
  apiUrl: string | null;
  latencyMs: number | null;
  modelSlugUsed: string;
 }): LogEntry {
  const now = new Date().toISOString();
  const {
   turnNumber, userInput, rawNarratorOutput, parsedOutput,
   contextSnapshot, tokenUsage, aiSettings, apiRequestBody,
   apiResponseBody, apiUrl, latencyMs, modelSlugUsed
  } = params;

  let digestLines: DigestLine[] = parsedOutput.digestLines || [];
  if (digestLines.length === 0 && parsedOutput.deltas) {
   // If AI didn't provide digest, infer from deltas
   digestLines = this.inferDigestLinesFromDeltas(parsedOutput.deltas, parsedOutput.prose);
  }
  // Ensure correct turn number for inferred digests
  digestLines = digestLines.map(d => ({ ...d, turn: turnNumber }));


  const errorFlags: LogErrorFlag[] = [];
  // Basic error checking (can be expanded)
  if (!parsedOutput.prose) {
   errorFlags.push('MISSING_PROSE');
  }
  // Now using DELTA_MARKER imported from deltaParser
  if (parsedOutput.deltas && Object.keys(parsedOutput.deltas).length === 0 && rawNarratorOutput.includes(DELTA_MARKER)) {
    // If the delta marker was present but no deltas were parsed
    errorFlags.push('INVALID_JSON_DELTA');
  }
  if (!tokenUsage || tokenUsage.totalTokens <= 0) {
   errorFlags.push('INVALID_TOKEN_USAGE');
  }
  // Add more validation based on your `LogErrorFlag` enum/sealed class
  // e.g., if (rawNarratorOutput.length < 50) { errorFlags.push('AI_RESPONSE_TOO_SHORT'); }


  return {
   turnNumber: turnNumber,
   timestamp: now,
   userInput: userInput,
   narratorOutput: rawNarratorOutput,
   prose: parsedOutput.prose, // ADDED: Save the clean prose here
   digestLines: digestLines, // Now an array
   deltas: parsedOutput.deltas,
   contextSnapshot: contextSnapshot,
   tokenUsage: tokenUsage,
   apiRequestBody: apiRequestBody,
   apiResponseBody: apiResponseBody,
   apiUrl: apiUrl,
   latencyMs: latencyMs,
   aiSettings: aiSettings,
   errorFlags: errorFlags,
   modelSlugUsed: modelSlugUsed,
  };
 }
}

export const logManager = new LogManager();
@@FILE: src/logic/promptBuilder.ts
// src/logic/promptBuilder.ts
import { PromptCard, GameState, LogEntry, Message } from '../models';

import { IContextStackAssembler } from './IContextStackAssembler'; // <-- ADD THIS LINE
import { ContextStackAssembler } from './ContextStackAssembler';   // <-- AND THIS LINE


export interface IPromptBuilder {
  buildFirstTurnPrompt(card: PromptCard): Message[];
  buildEveryTurnPrompt(
    card: PromptCard,
    currentGameState: GameState,
    logEntries: LogEntry[],
    conversationHistory: Message[],
    currentUserAction: string,
  ): Message[];
}

export class PromptBuilder implements IPromptBuilder {
  private stackAssembler: IContextStackAssembler;

  constructor() {
    // The builder now owns an instance of the assembler
    this.stackAssembler = new ContextStackAssembler();
  }

  private buildCommonPromptParts(card: PromptCard): Message[] {
    const messages: Message[] = [];
    messages.push({ role: "system", content: `## Core Scenario / Persona\n${card.prompt}` });
    if (card.gameRules) {
      messages.push({ role: "system", content: `\n## Game Rules\n${card.gameRules}` });
    }
    if (card.emitSkeleton) {
      messages.push({ role: "system", content: `\n## AI Output Structure Rules\n${card.emitSkeleton}` });
    }
    if (card.functionDefs) {
      messages.push({ role: "system", content: `\n## Available Functions (JSON)\n\`\`\`json\n${card.functionDefs}\n\`\`\`` });
    }
    return messages;
  }

  public buildFirstTurnPrompt(card: PromptCard): Message[] {
    const messages = this.buildCommonPromptParts(card);

    if (card.worldStateInit) {
      messages.push({ role: "system", content: `\n## Initial World State (JSON)\n\`\`\`json\n${card.worldStateInit}\n\`\`\`` });
    }
    if (card.firstTurnOnlyBlock) {
      messages.push({ role: "system", content: `\n## First Turn Specifics\n${card.firstTurnOnlyBlock}` });
    }

    return messages;
  }

  public buildEveryTurnPrompt(
    card: PromptCard,
    currentGameState: GameState,
    logEntries: LogEntry[],
    conversationHistory: Message[],
    currentUserAction: string,
  ): Message[] {
    // 1. Get the static parts of the prompt
    const messages = this.buildCommonPromptParts(card);

    // 2. Delegate the complex part to the stack assembler
    const dynamicContextMessages = this.stackAssembler.assembleContext(
      card,
      currentGameState,
      logEntries
    );
    messages.push(...dynamicContextMessages);

    // 3. Append conversation history
    messages.push(...conversationHistory);

    // 4. Append the current user's action
    messages.push({ role: "user", content: currentUserAction });

    return messages;
  }
}

// Export a singleton instance for easy use across the app
export const promptBuilder = new PromptBuilder();
@@FILE: src/main.tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css';

// Import the new provider that encapsulates GameSession creation and store initialization
import { GameSessionAndStoreProvider } from './providers/GameSessionAndStoreProvider.tsx';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    {/* Wrap App with the provider */}
    <GameSessionAndStoreProvider>
      <App />
    </GameSessionAndStoreProvider>
  </React.StrictMode>,
);
@@FOLDER: src/models
@@FILE: src/models/AiConnection.ts
// src/models/AiConnection.ts

/**
 * Represents the configuration for a connection to an AI service.
 * Aligns with Android's AiConnection class.
 */
export interface AiConnection {
  id: string; // Unique ID for this connection
  displayName: string; // User-friendly name for the connection (e.g., "My OpenAI Key")
  modelName: string; // The full name of the model (e.g., "GPT-4 Turbo")
  modelSlug: string; // The API identifier for the model (e.g., "gpt-4-turbo", "deepseek-coder")
  apiUrl: string; // The base URL for the API (e.g., "https://api.openai.com/v1/")
  apiToken: string; // The user's API key (sensitive)
  functionCallingEnabled: boolean; // Whether this connection supports/uses function calling
  userAgent?: string | null; // Optional: User-Agent string for API calls (from Android)

  // Metadata
  createdAt: string; // ISO 8601 string
  lastUpdated: string; // ISO 8601 string
}
@@FILE: src/models/DeltaInstruction.ts
// src/models/DeltaInstruction.ts

/**
 * Represents a single instruction to modify the game world state, as per DeltaInstruction.kt.
 * This is a pure data definition, without logic or companion methods.
 * Corresponds to a discriminated union in TypeScript for Kotlin's sealed class.
 *
 * `value: any` corresponds to Kotlin's `JsonElement`, allowing any valid JSON value (string, number, boolean, object, array, null).
 */

export type DeltaInstruction =
  | { op: 'add'; key: string; value: any }      // Corresponds to Add data class
  | { op: 'assign'; key: string; value: any }   // Corresponds to Assign data class
  | { op: 'declare'; key: string; value: any }  // Corresponds to Declare data class
  | { op: 'delete'; key: string };              // Corresponds to Delete data class (no value)

// Helper type for the map of deltas
export type DeltaMap = { [fullKey: string]: DeltaInstruction };
@@FILE: src/models/GameSnapshot.ts
// src/models/GameSnapshot.ts

import { GameState } from './GameState';
import { LogEntry } from './LogEntry';
import { PromptCard } from './PromptCard';
import { Message } from './Message'; // For conversation history

/**
 * Represents a full, self-contained snapshot of a game session.
 * This is the primary object for saving and loading games.
 * Based on `StoryForgeViewModel.buildSnapshot()`.
 */
export interface GameSnapshot {
  // --- Core Identifiers ---
  id: string; // Unique ID for this snapshot/game session
  userId: string;
  promptCardId: string; // ID of the card used
  title: string; // NEW: A human-readable title for the saved game

  // --- Timestamps ---
  createdAt: string; // When the game session was started
  updatedAt: string; // When this snapshot was last saved

  // --- Core Game State ---
  currentTurn: number;
  gameState: GameState; // Contains worldState, scene, narration
  conversationHistory: Message[]; // Full user/assistant conversation history

  // --- Logs for Context & Debugging ---
  // Note: All "digests" are now just part of the logs.
  // We extract them for context building, but don't store them separately.
  logs: LogEntry[];

  // --- UI Preferences (Persisted with Snapshot) ---
  worldStatePinnedKeys: string[]; // Stores full variable paths, e.g., "npcs.#fox.hp"
}
@@FILE: src/models/GameState.ts
// src/models/GameState.ts

/**
 * Represents the current scene's location and present entities.
 * Corresponds to the state managed by SceneManager.
 */
export interface SceneState {
  location: string | null;
  present: string[]; // List of entity keys, e.g., ["player.#you", "npcs.#fox"]
}

/**
 * Defines the core mutable state of the game.
 * All game variables (like HP, gold) are expected to be dynamic and reside within `worldState`.
 */
export interface GameState {
  narration: string;
  worldState: Record<string, any>; // The dynamic game world
  scene: SceneState; // The current scene state
}
@@FILE: src/models/LogEntry.ts
// src/models/LogEntry.ts

import { DeltaMap } from './DeltaInstruction';
import { DigestLine, TokenSummary, LogErrorFlag } from './LogEntryElements';
import { AiSettingsInCard } from './PromptCard';

/**
 * Canonical structured log for a single turn or significant event in the game.
 * Corresponds to TurnLogEntry.kt, enhanced with insights from DigestManager.
 */
export interface LogEntry {
 turnNumber: number;
 timestamp: string;

 userInput: string;
 narratorOutput: string; // The raw, full output from the AI
 prose: string; 

 digestLines: DigestLine[];
 deltas?: DeltaMap | null;

 contextSnapshot?: string | null;
 tokenUsage?: TokenSummary | null;
 apiRequestBody?: string | null;
 apiResponseBody?: string | null;
 apiUrl?: string | null;
 latencyMs?: number | null;

 aiSettings?: AiSettingsInCard | null;
 errorFlags: LogErrorFlag[];
 modelSlugUsed: string;
}
@@FILE: src/models/LogEntryElements.ts
// src/models/LogEntryElements.ts

/**
 * Represents a single summary line for the digest, as per DigestLine.kt (implied by TurnLogEntry).
 */
export interface DigestLine {
  text: string;
  importance: number; // 1 (minor) to 5 (critical)
  tags?: string[];    // Optional, e.g., for filtering by specific entities
}

/**
 * Summarizes token usage for an AI call, as per TokenSummary.kt (implied by TurnLogEntry).
 */
export interface TokenSummary {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  cachedTokens?: number; // Optional: If some tokens were served from cache
}

/**
 * Represents a flag for a validation error or issue in the log entry.
 * Based on `LogErrorFlag` (implied enum/sealed class from `TurnLogEntry`).
 */
export type LogErrorFlag =
  | 'MISSING_PROSE'
  | 'MISSING_DELTAS'
  | 'INVALID_JSON_DELTA'
  | 'INVALID_TOKEN_USAGE'
  | 'AI_RESPONSE_TOO_SHORT'
  | 'AI_RESPONSE_TOO_LONG'
  | 'UNEXPECTED_AI_FORMAT'
  | 'API_ERROR'
  | 'UNKNOWN_ERROR';
// Add more flags as needed based on your LogErrorFlag enum/sealed class if it exists.
@@FILE: src/models/Message.ts
// src/models/Message.ts

/**
 * Represents a single message in a conversation with the AI.
 * Corresponds to Message.kt.
 */
export interface Message {
  role: 'system' | 'user' | 'assistant';
  content: string;
}
@@FILE: src/models/ParsedNarrationOutput.ts
// src/models/ParsedNarrationOutput.ts

import { DeltaMap } from './DeltaInstruction';
import { DigestLine } from './LogEntryElements';

/**
 * Represents the structured data extracted from a raw AI narrator response.
 * Corresponds to `NarrationParser.ParsedNarration` from the old project.
 *
 * @param prose The clean, human-readable narrative text.
 * @param deltas A map of world state changes to apply.
 * @param digestLines An array of summary lines.
 * @param scene A flexible JSON object describing the current scene (location, present characters, etc.).
 */
export interface ParsedNarrationOutput {
  prose: string;
  deltas: DeltaMap;
  digestLines: DigestLine[];
  scene?: Record<string, any> | null; // Corresponds to the JsonObject? for the @scene block
}
@@FILE: src/models/PromptCard.ts
// src/models/PromptCard.ts

import { StackInstructions } from './StackInstructions'; // Import the new StackInstructions

/**
 * Defines the configuration settings for an AI connection.
 * These fields are embedded directly within PromptCard.
 * This is a pure data definition, with no default values.
 */
export interface AiSettings {
  selectedConnectionId: string;
  temperature: number;
  topP: number;
  maxTokens: number;
  presencePenalty: number;
  frequencyPenalty: number;
  functionCallingEnabled: boolean;
}

/**
 * A self-contained prompt card that can be submitted to the AI to configure tone, rules, or scenario.
 * This version consolidates AiSettings and uses a structured StackInstructions object.
 * This is a pure data definition, with no default values or logic.
 */
export interface PromptCard {
  // Web-specific lineage and deduplication fields (as per initial migration plan)
  id: string;
  rootId: string;
  parentId: string | null; // Null for root cards
  contentHash: string; // Hash of significant content fields to detect duplicates

  // Fields directly from old PromptCard.kt
  title: string;
  description: string | null; // Optional in Kotlin, so `string | null`
  prompt: string;
  firstTurnOnlyBlock: string;
  stackInstructions: StackInstructions; // Now a structured object
  emitSkeleton: string;      // JSON string
  worldStateInit: string;    // JSON string
  gameRules: string;
  aiSettings: AiSettings;
  helperAiSettings: AiSettings;
  isHelperAiEnabled: boolean; // NEW: Controls whether helper AI is considered active
  tags: string[];            // Kotlin `List<String>` maps to `string[]`
  isExample: boolean;        // From Kotlin `isExample`
  functionDefs: string;      // JSON string

  // Additional web-specific metadata (as per initial migration plan)
  isPublic: boolean;
  createdAt: string; // ISO 8601 string
  updatedAt: string; // ISO 8601 string
  ownerId: string;   // Firebase User UID
}

/**
 * Represents the raw data needed when creating or updating a PromptCard.
 * This does not include generated fields like IDs, hashes, timestamps, or ownerId,
 * nor does it specify default values for optional fields.
 */
export interface NewPromptCardData {
  title: string;
  prompt: string;
  description?: string | null;
  firstTurnOnlyBlock?: string;
  // This is kept as 'string | StackInstructions' to allow raw JSON string input,
  // with parsing logic to convert it to StackInstructions handled elsewhere (e.g., in logic/cardManager or data repository).
  stackInstructions?: string | StackInstructions;
  emitSkeleton?: string;
  worldStateInit?: string;
  gameRules?: string;
  aiSettings?: AiSettings; // Changed from AiSettingsInCard to AiSettings for consistency
  helperAiSettings?: AiSettings; // Changed from AiSettingsInCard to AiSettings for consistency
  isHelperAiEnabled?: boolean; // NEW: Optional for new card data
  tags?: string[];
  isExample?: boolean;
  functionDefs?: string;
  isPublic?: boolean;
}
@@FILE: src/models/StackInstructions.ts
// src/models/StackInstructions.ts

/**
 * Defines the mode for including a stack element.
 * Now an enum to allow runtime access (e.g., Object.values).
 */
export enum StackMode {
  ALWAYS = 'always',
  FIRST_N = 'firstN',
  AFTER_N = 'afterN',
  NEVER = 'never',
  FILTERED = 'filtered', // Added if 'filtered' applies to modes
}

/**
 * Defines the filtering strategy for a stack element.
 * Now an enum to allow runtime access.
 */
export enum FilterMode {
  NONE = 'none',
  SCENE_ONLY = 'sceneOnly',
  TAGGED = 'tagged',
}

/**
 * Defines a policy for including prose or other list-based context.
 * Corresponds to `ProsePolicy`.
 */
export interface ProsePolicy {
  mode: StackMode; // Use the enum
  n: number;
  filtering: FilterMode; // Use the enum
  enabled?: boolean; // NEW: Added for toggling the entire section
}

/**
 * Defines a rule for emitting digest lines based on their importance score.
 * Corresponds to `EmissionRule`.
 */
export interface EmissionRule {
  mode: StackMode; // Use the enum
  n: number;
}

/**
 * Defines the policy for filtering digest lines.
 * Corresponds to `DigestFilterPolicy`.
 */
export interface DigestFilterPolicy {
  filtering: FilterMode; // Use the enum
  enabled?: boolean; // NEW: Added for toggling the entire section
}

/**
 * Defines the policy for token usage and fallback strategies.
 * Corresponds to `TokenPolicy`.
 */
export interface TokenPolicy {
  minTokens: number;
  maxTokens: number;
  fallbackPlan: string[];
}

/**
 * The full, structured stack instructions for a PromptCard.
 * Corresponds to `StackInstructions.kt`.
 */
export interface StackInstructions {
  narratorProseEmission: ProsePolicy;
  digestPolicy: DigestFilterPolicy;
  digestEmission: Record<number, EmissionRule>; // Map<Int, EmissionRule> -> Record<number, EmissionRule>

  expressionLogPolicy: ProsePolicy;
  expressionLinesPerCharacter: number;
  emotionWeighting: boolean;

  worldStatePolicy: ProsePolicy;
  knownEntitiesPolicy: ProsePolicy;

  // REMOVED: outputFormat: string; // This field is being removed
  tokenPolicy: TokenPolicy;
}
@@FILE: src/models/index.ts
// src/models/index.ts

// Re-export all models for easier importing
export * from './AiConnection';
export * from './DeltaInstruction';
export * from './GameSnapshot';
export * from './GameState.ts';
export * from './LogEntry';
export * from './LogEntryElements';
export * from './Message';
export * from './ParsedNarrationOutput';
export * from './PromptCard';
export * from './StackInstructions';
@@FOLDER: src/pages
@@FILE: src/pages/SourceDump.tsx
import React, { useEffect, useState } from 'react';

const SourceDump: React.FC = () => {
  const [code, setCode] = useState<string>('Loading...');

  useEffect(() => {
    fetch('/source-dump.txt')
      .then(res => res.text())
      .then(text => setCode(text))
      .catch(err => setCode('Error loading source dump: ' + err));
  }, []);

  return (
    <pre style={{
      whiteSpace: 'pre-wrap',
      background: '#1e1e1e',
      color: '#d4d4d4',
      padding: '1rem',
      overflowX: 'auto'
    }}>
      {code}
    </pre>
  );
};

export default SourceDump;

@@FOLDER: src/providers
@@FILE: src/providers/GameSessionAndStoreProvider.tsx
// src/providers/GameSessionAndStoreProvider.tsx
import React, { useRef } from 'react';
import { GameSession, IGameSession } from '../logic/gameSession';
import { gameRepository } from '../data/repositories/gameRepository';
import { promptCardRepository } from '../data/repositories/promptCardRepository';
import { initializeGameStateStore } from '../state/useGameStateStore';
import { GameSessionProvider } from '../contexts/GameSessionContext';

// Import the new centralized service singletons
import { turnProcessor, snapshotUpdater } from '../logic/gameSessionServices';

interface GameSessionAndStoreProviderProps {
  children: React.ReactNode;
}

export const GameSessionAndStoreProvider: React.FC<GameSessionAndStoreProviderProps> = ({ children }) => {
  const gameSessionInstanceRef = useRef<IGameSession | null>(null);

  if (!gameSessionInstanceRef.current) {
    console.log("GameSessionAndStoreProvider: Instantiating GameSession...");
    
    // The GameSession constructor is now much cleaner
    gameSessionInstanceRef.current = new GameSession(
      gameRepository,
      promptCardRepository,
      turnProcessor,
      snapshotUpdater
    );
    
    initializeGameStateStore(gameSessionInstanceRef.current);
  }

  return (
    <GameSessionProvider gameSession={gameSessionInstanceRef.current}>
      {children}
    </GameSessionProvider>
  );
};
@@FOLDER: src/state
@@FILE: src/state/useAuthStore.ts
// src/state/useAuthStore.ts

import { create } from 'zustand';
import { User } from 'firebase/auth'; // Import Firebase User type
import { subscribeToAuthChanges, signInWithGoogle, signOutUser } from '../data/repositories/authRepository'; // Import auth functions

// Define the shape of our authentication state
interface AuthState {
  user: User | null; // The current authenticated user or null
  isLoading: boolean; // True while checking initial auth state
  error: string | null; // Any error during auth operations

  // Actions
  // These are not directly implemented here, but exposed for components to call
  signIn: () => Promise<void>;
  signOut: () => Promise<void>;
}

// Create the Zustand store
export const useAuthStore = create<AuthState>((set, get) => ({
  user: null, // Initial state: no user
  isLoading: true, // Initially loading to check auth state
  error: null, // No error initially

  // Action to handle sign-in
  signIn: async () => {
    set({ error: null }); // Clear previous errors
    try {
      await signInWithGoogle();
      // The onAuthStateChanged listener will update the 'user' state,
      // so we don't need to manually set it here based on the signIn result.
    } catch (err: any) {
      console.error("AuthStore signIn error:", err);
      set({ error: err.message || "Failed to sign in." });
    }
  },

  // Action to handle sign-out
  signOut: async () => {
    set({ error: null }); // Clear previous errors
    try {
      await signOutUser();
    } catch (err: any) {
      console.error("AuthStore signOut error:", err);
      set({ error: err.message || "Failed to sign out." });
    }
  },
}));

// --- Initialize and Subscribe to Auth Changes ---
// This part ensures our store's 'user' state is always in sync with Firebase Auth.
// It runs only once when the module is loaded.
const unsubscribe = subscribeToAuthChanges((user) => {
  useAuthStore.setState({ user: user, isLoading: false }); // Update user and set loading to false
  console.log("Auth State Updated:", user ? user.uid : "No user");
});

// Optional: You might want to handle unsubscription if your app could unmount this module,
// but for a core global store, it often lives for the app's lifetime.
// If you were to integrate this into a React component's useEffect, you'd return the unsubscribe function.
// For a global store, we typically let it live.
@@FILE: src/state/useGameStateStore.ts
// src/state/useGameStateStore.ts

import { create } from 'zustand';
import { GameSnapshot, GameState, LogEntry, Message } from '../models/index';
import { flattenJsonObject, getNestedValue } from '../utils/jsonUtils';
import { produce } from 'immer';
import { useSettingsStore } from './useSettingsStore';

import { IGameSession } from '../logic/gameSession';

// Module-level variable to hold the injected GameSession instance
// Initialized to null, as it will be set later by initializeGameStateStore
let _gameSessionInstance: IGameSession | null = null;

/**
 * Initializes the GameStateStore with the GameSession instance.
 * This function should be called once, typically from a provider component (e.g., GameSessionAndStoreProvider).
 * It ensures that the Zustand store's actions can access the game session.
 */
export const initializeGameStateStore = (gameSession: IGameSession) => {
  if (_gameSessionInstance === null) {
    _gameSessionInstance = gameSession;
    console.log("GameStateStore: GameSession instance injected.");
  } else {
    console.warn("GameStateStore: Attempted to re-initialize GameSession instance. This should only happen once.");
  }
};

// Define types for pinning
type PinToggleType = 'variable' | 'entity' | 'category';

const initialState = {
  currentSnapshot: null,
  currentPromptCardId: null,
  currentGameState: null,
  gameLogs: [],
  conversationHistory: [],
  worldStatePinnedKeys: [],
  narratorInputText: '',
  narratorScrollPosition: 0,
  gameError: null,
  gameLoading: false,
  isProcessingTurn: false,
};

interface GameStateStore {
  currentSnapshot: GameSnapshot | null;
  currentPromptCardId: string | null;
  currentGameState: GameState | null;
  gameLogs: LogEntry[];
  conversationHistory: Message[];
  worldStatePinnedKeys: string[];
  narratorInputText: string;
  narratorScrollPosition: number;
  gameError: string | null;
  gameLoading: boolean;
  isProcessingTurn: boolean;

  initializeGame: (userId: string, cardId: string, existingSnapshotId?: string) => Promise<void>;
  processPlayerAction: (action: string) => Promise<void>;
  processFirstNarratorTurn: () => Promise<void>;
  saveGame: () => Promise<void>;
  loadGame: (userId: string, snapshotId: string) => Promise<void>;
  loadLastActiveGame: (userId: string) => Promise<boolean>;

  toggleWorldStatePin: (keyPath: string, type: PinToggleType) => void;
  unpinAllForEntity: (entityPath: string) => void;
  unpinIndividualVariable: (variablePath: string) => void;

  updateNarratorInputText: (text: string) => void;
  updateNarratorScrollPosition: (position: number) => void;

  renameWorldCategory: (oldName: string, newName: string) => Promise<void>;
  renameWorldEntity: (category: string, oldName: string, newName: string) => Promise<void>;
  deleteWorldCategory: (category: string) => Promise<void>;
  deleteWorldEntity: (category: string, entity: string) => Promise<void>;
  editWorldKeyValue: (key: string, value: any) => Promise<void>;
  deleteWorldKey: (key: string) => Promise<void>;
  reset: () => void;
}

export const useGameStateStore = create<GameStateStore>((set, get) => ({
  ...initialState,

  // Helper function to safely get the gameSession instance
  // This ensures we always get the *current* value of _gameSessionInstance
  // and centralizes the error handling for a missing instance.
  _getGameSession: (): IGameSession => {
    if (!_gameSessionInstance) {
      const errorMsg = "Game session instance not initialized. This is a critical error. Ensure GameSessionAndStoreProvider is rendering and initializeGameStateStore has been called.";
      console.error(errorMsg);
      // It's crucial to throw here to prevent further execution with a null instance
      throw new Error(errorMsg);
    }
    return _gameSessionInstance;
  },

  initializeGame: async (userId, cardId, existingSnapshotId) => {
    set({ gameLoading: true, gameError: null });
    try {
      const gameSession = get()._getGameSession(); // Get instance via helper
      await gameSession.initializeGame(userId, cardId, existingSnapshotId);
      const snapshot = gameSession.getCurrentGameSnapshot();
      if (snapshot) {
        set({
          currentSnapshot: snapshot,
          currentPromptCardId: snapshot.promptCardId,
          currentGameState: snapshot.gameState,
          gameLogs: snapshot.logs || [],
          conversationHistory: snapshot.conversationHistory || [],
          worldStatePinnedKeys: snapshot.worldStatePinnedKeys || [],
        });
      } else {
        set({ gameError: "Game state could not be loaded or initialized." });
      }
      set({ gameLoading: false });
    } catch (error: any) {
      set({ gameError: error.message, gameLoading: false });
      console.error("Error in initializeGame action:", error);
    }
  },

  processFirstNarratorTurn: async () => {
    set({ isProcessingTurn: true, gameError: null });
    const useDummyNarrator = useSettingsStore.getState().useDummyNarrator;
    try {
      const gameSession = get()._getGameSession(); // Get instance via helper
      const updatedSnapshot = await gameSession.processFirstNarratorTurn(useDummyNarrator);
      set({
        currentSnapshot: updatedSnapshot,
        currentGameState: updatedSnapshot.gameState,
        gameLogs: updatedSnapshot.logs,
        conversationHistory: updatedSnapshot.conversationHistory,
      });
      set({ isProcessingTurn: false });
    } catch (error: any) {
      set({ gameError: error.message, isProcessingTurn: false });
      console.error("Error processing first narrator turn:", error);
    }
  },

  processPlayerAction: async (action) => {
    set({ isProcessingTurn: true, gameError: null });
    const useDummyNarrator = useSettingsStore.getState().useDummyNarrator;
    try {
      const gameSession = get()._getGameSession(); // Get instance via helper
      const updatedSnapshot = await gameSession.processPlayerAction(action, useDummyNarrator);
      set({
        currentSnapshot: updatedSnapshot,
        currentGameState: updatedSnapshot.gameState,
        gameLogs: updatedSnapshot.logs,
        conversationHistory: updatedSnapshot.conversationHistory,
        narratorInputText: '',
        worldStatePinnedKeys: updatedSnapshot.worldStatePinnedKeys || [],
      });
      set({ isProcessingTurn: false });
    } catch (error: any) {
      set({ gameError: error.message, isProcessingTurn: false });
      console.error("Error processing player action:", error);
    }
  },

  saveGame: async () => {
    try {
      const gameSession = get()._getGameSession(); // Get instance via helper
      const currentSnapshot = get().currentSnapshot;
      if (currentSnapshot) {
        const snapshotToSave = produce(currentSnapshot, draft => {
          draft.worldStatePinnedKeys = get().worldStatePinnedKeys;
          draft.updatedAt = new Date().toISOString();
        });
        await gameSession.saveGame(snapshotToSave);
        console.log('useGameStateStore: saveGame() finished.');
      } else {
        console.warn("No current snapshot in store to save.");
      }
    } catch (error: any) {
        console.error("GameStateStore: Error saving game:", error);
        set({ gameError: error.message }); // Set error in store if save fails
    }
  },

  loadGame: async (userId, snapshotId) => {
    set({ gameLoading: true, gameError: null });
    try {
      const gameSession = get()._getGameSession(); // Get instance via helper
      await gameSession.loadGame(userId, snapshotId);
      const snapshot = gameSession.getCurrentGameSnapshot();
      if (snapshot) {
        set({
          currentSnapshot: snapshot,
          currentPromptCardId: snapshot.promptCardId,
          currentGameState: snapshot.gameState,
          gameLogs: snapshot.logs || [],
          conversationHistory: snapshot.conversationHistory || [],
          worldStatePinnedKeys: snapshot.worldStatePinnedKeys || [],
        });
      }
      set({ gameLoading: false });
    } catch (error: any) {
      set({ gameError: error.message, gameLoading: false });
      console.error("Error loading game:", error);
    }
  },

  loadLastActiveGame: async (userId: string): Promise<boolean> => {
    set({ gameLoading: true, gameError: null });
    try {
      const gameSession = get()._getGameSession(); // Get instance via helper
      const gameLoaded = await gameSession.loadLastActiveGame(userId);
      const loadedSnapshot = gameSession.getCurrentGameSnapshot();

      if (gameLoaded && loadedSnapshot) {
        set({
          currentSnapshot: loadedSnapshot,
          currentPromptCardId: loadedSnapshot.promptCardId,
          currentGameState: loadedSnapshot.gameState,
          gameLogs: loadedSnapshot.logs || [],
          conversationHistory: loadedSnapshot.conversationHistory || [],
          worldStatePinnedKeys: loadedSnapshot.worldStatePinnedKeys || [],
        });
        set({ gameLoading: false });
        return true;
      } else {
        set({ gameLoading: false, currentSnapshot: null, currentPromptCardId: null, currentGameState: null, gameLogs: [], conversationHistory: [], worldStatePinnedKeys: [] });
        return false;
      }
    } catch (error: any) {
      console.error("GameStateStore: Error loading last active game:", error);
      set({ gameError: error.message, gameLoading: false });
      return false;
    }
  },

  toggleWorldStatePin: (keyPath: string, type: PinToggleType) => {
    // This action directly manipulates `worldStatePinnedKeys` state,
    // it doesn't need to call GameSession for core game logic
    // but then calls saveGame, which uses gameSession.
    set(produce((state: GameStateStore) => {
      const currentWorldState = state.currentGameState?.worldState || {};
      const newPinnedKeys = new Set(state.worldStatePinnedKeys);

      const isCurrentlyPinned = (path: string) => newPinnedKeys.has(path);

      let relevantKeysToToggle: string[] = [];

      if (type === 'variable') {
        relevantKeysToToggle = [keyPath];
      } else if (type === 'entity') {
        const flattenedEntity = flattenJsonObject(getNestedValue(currentWorldState, keyPath.split('.')), keyPath);
        relevantKeysToToggle = Object.keys(flattenedEntity).filter(k => {
          return k.startsWith(keyPath) && k.split('.').length > keyPath.split('.').length;
        });
      } else if (type === 'category') {
        const flattenedCategory = flattenJsonObject(getNestedValue(currentWorldState, keyPath.split('.')), keyPath);
        relevantKeysToToggle = Object.keys(flattenedCategory).filter(k => {
          return k.startsWith(keyPath) && k.split('.').length > keyPath.split('.').length;
        });
      }

      const shouldPin = relevantKeysToToggle.length > 0
        ? !relevantKeysToToggle.every(isCurrentlyPinned)
        : true;

      relevantKeysToToggle.forEach(key => {
        if (shouldPin) {
          newPinnedKeys.add(key);
        } else {
          newPinnedKeys.delete(key);
        }
      });

      state.worldStatePinnedKeys = Array.from(newPinnedKeys);
      if (state.currentSnapshot) {
        state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
      }
    }));
    get().saveGame();
  },

  unpinAllForEntity: (entityPath: string) => {
    set(produce((state: GameStateStore) => {
      const newPinnedKeys = new Set(state.worldStatePinnedKeys);
      state.worldStatePinnedKeys.forEach(key => {
        if (key.startsWith(entityPath + '.')) {
          newPinnedKeys.delete(key);
        }
      });
      state.worldStatePinnedKeys = Array.from(newPinnedKeys);
      if (state.currentSnapshot) {
        state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
      }
    }));
    get().saveGame();
  },

  unpinIndividualVariable: (variablePath: string) => {
    set(produce((state: GameStateStore) => {
      state.worldStatePinnedKeys = state.worldStatePinnedKeys.filter(key => key !== variablePath);
      if (state.currentSnapshot) {
        state.currentSnapshot.worldStatePinnedKeys = state.worldStatePinnedKeys;
      }
    }));
    get().saveGame();
  },

  updateNarratorInputText: (text) => set({ narratorInputText: text }),
  updateNarratorScrollPosition: (position) => set({ narratorScrollPosition: position }),

  // Delegated World State modification actions
  renameWorldCategory: async (oldName, newName) => {
    try {
      const gameSession = get()._getGameSession(); // Get instance via helper
      const updatedSnapshot = await gameSession.renameWorldCategory(oldName, newName);
      if (updatedSnapshot) {
        set({ currentSnapshot: updatedSnapshot, currentGameState: updatedSnapshot.gameState, worldStatePinnedKeys: updatedSnapshot.worldStatePinnedKeys });
      }
    } catch (error: any) {
        console.error("GameStateStore: Error renaming category:", error);
        set({ gameError: error.message });
    }
  },
  renameWorldEntity: async (category, oldName, newName) => {
    try {
        const gameSession = get()._getGameSession();
        const updatedSnapshot = await gameSession.renameWorldEntity(category, oldName, newName);
        if (updatedSnapshot) {
            set({ currentSnapshot: updatedSnapshot, currentGameState: updatedSnapshot.gameState, worldStatePinnedKeys: updatedSnapshot.worldStatePinnedKeys });
        }
    } catch (error: any) {
        console.error("GameStateStore: Error renaming entity:", error);
        set({ gameError: error.message });
    }
  },
  deleteWorldCategory: async (category) => {
    try {
        const gameSession = get()._getGameSession();
        const updatedSnapshot = await gameSession.deleteWorldCategory(category);
        if (updatedSnapshot) {
            set({ currentSnapshot: updatedSnapshot, currentGameState: updatedSnapshot.gameState, worldStatePinnedKeys: updatedSnapshot.worldStatePinnedKeys });
        }
    } catch (error: any) {
        console.error("GameStateStore: Error deleting category:", error);
        set({ gameError: error.message });
    }
  },
  deleteWorldEntity: async (category, entity) => {
    try {
        const gameSession = get()._getGameSession();
        const updatedSnapshot = await gameSession.deleteWorldEntity(category, entity);
        if (updatedSnapshot) {
            set({ currentSnapshot: updatedSnapshot, currentGameState: updatedSnapshot.gameState, worldStatePinnedKeys: updatedSnapshot.worldStatePinnedKeys });
        }
    } catch (error: any) {
        console.error("GameStateStore: Error deleting entity:", error);
        set({ gameError: error.message });
    }
  },
  editWorldKeyValue: async (key, value) => {
    try {
        const gameSession = get()._getGameSession();
        const updatedSnapshot = await gameSession.editWorldKeyValue(key, value);
        if (updatedSnapshot) {
            set({ currentSnapshot: updatedSnapshot, currentGameState: updatedSnapshot.gameState, worldStatePinnedKeys: updatedSnapshot.worldStatePinnedKeys });
        }
    } catch (error: any) {
        console.error("GameStateStore: Error editing key-value:", error);
        set({ gameError: error.message });
    }
  },
  deleteWorldKey: async (key) => {
    try {
        const gameSession = get()._getGameSession();
        const updatedSnapshot = await gameSession.deleteWorldKey(key);
        if (updatedSnapshot) {
            set({ currentSnapshot: updatedSnapshot, currentGameState: updatedSnapshot.gameState, worldStatePinnedKeys: updatedSnapshot.worldStatePinnedKeys });
        }
    } catch (error: any) {
        console.error("GameStateStore: Error deleting key:", error);
        set({ gameError: error.message });
    }
  },
  reset: () => {
    console.log("Resetting GameStateStore.");
    set(initialState);
  },
}));
@@FILE: src/state/useLogStore.ts
// src/state/useLogStore.ts

import { create } from 'zustand';
import { LogEntry } from '../models/LogEntry'; // Assuming LogEntry model is available
import { LogViewMode } from '../utils/types'; // We'll define LogViewMode here

const initialState = {
  logEntries: [],
  isLoading: false,
  error: null,
};

interface LogState {
  logEntries: LogEntry[];
  selectedLogViewModes: LogViewMode[];
  isLoading: boolean;
  error: string | null;

  // Actions
  setLogEntries: (entries: LogEntry[]) => void; // To be called by useGameStateStore after a turn
  setSelectedLogViewModes: (modes: LogViewMode[]) => void;
  // Potentially fetch logs if we implement persistent log storage separate from GameSnapshot
  fetchLogs: (snapshotId: string) => Promise<void>;
  reset: () => void;
}

export const useLogStore = create<LogState>((set, get) => ({
  logEntries: [],
  selectedLogViewModes: [LogViewMode.NARRATOR_OUTPUT, LogViewMode.USER_INPUT, LogViewMode.DIGEST_LINES], // Default selection
  isLoading: false,
  error: null,

  setLogEntries: (entries) => set({ logEntries: entries }),

  setSelectedLogViewModes: (modes) => set({ selectedLogViewModes: modes }),

  fetchLogs: async (snapshotId) => {
    set({ isLoading: true, error: null });
    try {
      // In MVP, logs are part of GameSnapshot. So this would primarily
      // fetch the GameSnapshot and then extract its logs.
      // E.g., const snapshot = await gameRepository.getGameSnapshot(userId, snapshotId);
      // set({ logEntries: snapshot?.logs || [], isLoading: false });
      set({ isLoading: false }); // Placeholder
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error fetching logs:", error);
    }
  },
  reset: () => {
    console.log("Resetting LogStore.");
    set(initialState);
  },
}));
@@FILE: src/state/usePromptCardStore.ts
// src/state/usePromptCardStore.ts

import { create } from 'zustand';
import { PromptCard, NewPromptCardData, AiConnection } from '../models/index'; // Assuming index.ts exports these
import { promptCardManager } from '../logic/cardManager';
import { gameRepository } from '../data/repositories/gameRepository'; // For AI Connections

const initialState = {
  promptCards: [],
  activePromptCard: null,
  isLoading: false,
  error: null,
};

interface PromptCardState {
  promptCards: PromptCard[];
  activePromptCard: PromptCard | null;
  aiConnections: AiConnection[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchPromptCards: (userId: string) => Promise<void>;
  setActivePromptCard: (card: PromptCard | null) => void;
  addPromptCard: (userId: string, cardData: NewPromptCardData) => Promise<PromptCard | null>;
  updatePromptCard: (userId: string, cardId: string, updates: Partial<PromptCard>) => Promise<PromptCard | null>;
  duplicatePromptCard: (userId: string, cardId: string) => Promise<PromptCard | null>;
  deletePromptCard: (userId: string, cardId: string) => Promise<void>;
  fetchAiConnections: (userId: string) => Promise<void>;
  // Import/Export functionality will go here eventually
  importPromptCards: (userId: string, cards: NewPromptCardData[]) => Promise<PromptCard[]>;
  exportPromptCard: (userId: string, cardId: string) => Promise<PromptCard | null>;
  reset: () => void;
}

export const usePromptCardStore = create<PromptCardState>((set, get) => ({
  promptCards: [],
  activePromptCard: null,
  aiConnections: [],
  isLoading: false,
  error: null,

  fetchPromptCards: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const cards = await promptCardManager.getAllPromptCards(userId);
      set({ promptCards: cards, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error fetching prompt cards:", error);
    }
  },

  setActivePromptCard: (card) => {
    set({ activePromptCard: card });
  },

  addPromptCard: async (userId, cardData) => {
    set({ isLoading: true, error: null });
    try {
      const newCard = await promptCardManager.createNewPromptCard(userId, cardData);
      set((state) => ({
        promptCards: [...state.promptCards, newCard],
        isLoading: false,
      }));
      return newCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error adding prompt card:", error);
      return null;
    }
  },

  updatePromptCard: async (userId, cardId, updates) => {
    set({ isLoading: true, error: null });
    try {
      const updatedCard = await promptCardManager.updatePromptCard(userId, cardId, updates);
      if (updatedCard) {
        set((state) => ({
          promptCards: state.promptCards.map(card => card.id === updatedCard.id ? updatedCard : card),
          activePromptCard: state.activePromptCard?.id === updatedCard.id ? updatedCard : state.activePromptCard,
          isLoading: false,
        }));
      }
      return updatedCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error updating prompt card:", error);
      return null;
    }
  },

  duplicatePromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      const duplicatedCard = await promptCardManager.duplicatePromptCard(userId, cardId);
      if (duplicatedCard) {
        set((state) => ({
          promptCards: [...state.promptCards, duplicatedCard],
          isLoading: false,
        }));
      }
      return duplicatedCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error duplicating prompt card:", error);
      return null;
    }
  },

  deletePromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      await promptCardManager.deletePromptCard(userId, cardId);
      set((state) => ({
        promptCards: state.promptCards.filter(card => card.id !== cardId),
        activePromptCard: state.activePromptCard?.id === cardId ? null : state.activePromptCard,
        isLoading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error deleting prompt card:", error);
    }
  },

  fetchAiConnections: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const connections = await gameRepository.getAiConnections(userId);
      set({ aiConnections: connections, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error fetching AI connections:", error);
    }
  },

  importPromptCards: async (userId, cards) => {
    set({ isLoading: true, error: null });
    try {
      const imported = await promptCardManager.importPromptCards(userId, cards);
      set((state) => ({
        promptCards: [...state.promptCards, ...imported],
        isLoading: false,
      }));
      return imported;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error importing prompt cards:", error);
      return [];
    }
  },

  exportPromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      const exported = await promptCardManager.exportPromptCard(userId, cardId);
      set({ isLoading: false });
      return exported;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      console.error("Error exporting prompt card:", error);
      return null;
    }
  },

  reset: () => {
    console.log("Resetting PromptCardStore.");
    set(initialState);
  },
}));
@@FILE: src/state/useSettingsStore.ts
// src/state/useSettingsStore.ts

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { AiConnection } from '../models/AiConnection';
import { gameRepository } from '../data/repositories/gameRepository';
import { generateUuid } from '../utils/uuid';

interface SettingsState {
  aiConnections: AiConnection[];
  selectedConnectionId: string | null;
  isLoadingConnections: boolean;
  connectionsError: string | null;
  useDummyNarrator: boolean;
  themeMode: 'light' | 'dark';
  fetchAiConnections: (userId: string) => Promise<void>;
  addAiConnection: (userId: string, connection: Omit<AiConnection, 'id' | 'createdAt' | 'lastUpdated'>) => Promise<AiConnection | null>;
  updateAiConnection: (userId: string, connection: AiConnection) => Promise<AiConnection | null>;
  deleteAiConnection: (userId: string, connectionId: string) => Promise<void>;
  setSelectedConnectionId: (id: string | null) => void;
  setUseDummyNarrator: (enabled: boolean) => void;
  setThemeMode: (mode: 'light' | 'dark') => void;
  reset: () => void;
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set, get) => ({
      // --- Initial State Values ---
      aiConnections: [],
      selectedConnectionId: null,
      isLoadingConnections: false,
      connectionsError: null,
      useDummyNarrator: false,
      themeMode: 'light',

      // --- Actions ---
      fetchAiConnections: async (userId) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const connections = await gameRepository.getAiConnections(userId);
          set({
            aiConnections: connections,
            isLoadingConnections: false,
            selectedConnectionId: get().selectedConnectionId && connections.some(c => c.id === get().selectedConnectionId)
              ? get().selectedConnectionId
              : (connections.length > 0 ? connections[0].id : null)
          });
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
        }
      },
      addAiConnection: async (userId, newConnectionData) => {
        // ... (rest of the function is correct)
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const newId = generateUuid();
          const now = new Date().toISOString();
          const connection: AiConnection = {
            ...newConnectionData,
            id: newId,
            createdAt: now,
            lastUpdated: now,
          };
          await gameRepository.saveAiConnection(userId, connection);
          set(state => {
            const updatedConnections = [...state.aiConnections, connection].sort((a, b) => a.displayName.localeCompare(b.displayName));
            return {
              aiConnections: updatedConnections,
              isLoadingConnections: false,
              selectedConnectionId: state.selectedConnectionId || newId
            };
          });
          return connection;
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          return null;
        }
      },
      updateAiConnection: async (userId, updatedConnection) => {
        // ... (rest of the function is correct)
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const now = new Date().toISOString();
          const connectionToSave = { ...updatedConnection, lastUpdated: now };
          await gameRepository.saveAiConnection(userId, connectionToSave);
          set(state => {
            const updatedConnections = state.aiConnections.map(conn =>
              conn.id === updatedConnection.id ? connectionToSave : conn
            ).sort((a, b) => a.displayName.localeCompare(b.displayName));
            return {
              aiConnections: updatedConnections,
              isLoadingConnections: false,
            };
          });
          return connectionToSave;
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          return null;
        }
      },
      deleteAiConnection: async (userId, connectionId) => {
        // ... (rest of the function is correct)
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          await gameRepository.deleteAiConnection(userId, connectionId);
          set(state => {
            const updatedConnections = state.aiConnections.filter(conn => conn.id !== connectionId);
            let newSelectedId = state.selectedConnectionId;
            if (newSelectedId === connectionId) {
                newSelectedId = updatedConnections.length > 0 ? updatedConnections[0].id : null;
            }
            return {
              aiConnections: updatedConnections.sort((a, b) => a.displayName.localeCompare(b.displayName)),
              selectedConnectionId: newSelectedId,
              isLoadingConnections: false,
            };
          });
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
        }
      },
      setSelectedConnectionId: (id) => set({ selectedConnectionId: id }),
      setUseDummyNarrator: (enabled) => set({ useDummyNarrator: enabled }),
      setThemeMode: (mode) => set({ themeMode: mode }),
      
      // --- CORRECTED RESET ACTION ---
      reset: () => {
        console.log("Resetting SettingsStore.");
        // Set the non-persisted state back to initial values.
        // Persisted values will be handled by the middleware on next login/page load.
        set({
          aiConnections: [],
          isLoadingConnections: false,
          connectionsError: null,
          // We don't need to reset the persisted parts (selectedConnectionId, themeMode, etc.)
          // as they will be rehydrated or re-fetched on the next session.
        });
      },
    }),
    {
      name: 'storyforge-app-settings',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        selectedConnectionId: state.selectedConnectionId,
        useDummyNarrator: state.useDummyNarrator,
        themeMode: state.themeMode,
      }),
    }
  )
);
@@FOLDER: src/theme
@@FILE: src/theme/index.ts
// src/theme/index.ts
import { createTheme } from '@mui/material/styles';

/* --------------------------
   BRAND & COLOR VARIABLES
   -------------------------- */

// Backgrounds - Light
const BG_LIGHT_DEFAULT = '#FAFAFA'; // soft warm white
const BG_LIGHT_PAPER = '#FFFFFF';   // pure white

// Backgrounds - Dark
const BG_DARK_DEFAULT = '#121212';  // deep black
const BG_DARK_PAPER = '#1E1E1E';    // dark grey

// Text - Light
const TEXT_LIGHT_PRIMARY = '#1A1A1A'; // rich near-black
const TEXT_LIGHT_SECONDARY = '#555555'; // medium grey

// Text - Dark
const TEXT_DARK_PRIMARY = '#F5F5F5'; // soft white
const TEXT_DARK_SECONDARY = '#BBBBBB'; // medium light grey

// Primary Accent (actions, highlights)
const BRAND_PRIMARY_LIGHT = '#A84300'; // muted burnt orange
const BRAND_PRIMARY_DARK = '#FF8C42';  // warm muted orange

// Secondary Accent
const BRAND_SECONDARY_LIGHT = '#8B5E3C'; // warm brown
const BRAND_SECONDARY_DARK = '#D4A373';  // warm beige

// Dividers
const DIVIDER_LIGHT = '#E0E0E0';
const DIVIDER_DARK = '#333333';

// Custom UI colors
const PINNED_ENTITY_LIGHT = 'rgba(168, 67, 0, 0.85)'; // burnt orange translucent
// Much darker burnt orange, less opacity
const PINNED_ENTITY_DARK = 'rgba(140, 80, 40, 0.4)';


const CHIP_BG_LIGHT = 'rgba(255,255,255,0.7)';
const CHIP_BG_DARK = 'rgba(0,0,0,0.4)';

// Frosted translucency
const FROSTED_LIGHT = 'rgba(255,255,255,0.6)';
const FROSTED_DARK = 'rgba(30,30,30,0.4)';



/* --------------------------
   THEME EXTENSIONS
   -------------------------- */
declare module '@mui/material/styles' {
  interface Palette {
    pinnedEntity: Palette['primary'];
    chipBackground: Palette['primary'];
    frostedSurface: { light: string; dark: string };
  }
  interface PaletteOptions {
    pinnedEntity?: PaletteOptions['primary'];
    chipBackground?: PaletteOptions['primary'];
    frostedSurface?: { light: string; dark: string };
  }
}

/* --------------------------
   THEME FACTORY
   -------------------------- */
export const getAppTheme = (mode: 'light' | 'dark') => {
  const isLight = mode === 'light';

  return createTheme({
    palette: {
      mode,
      primary: {
        main: isLight ? BRAND_PRIMARY_LIGHT : BRAND_PRIMARY_DARK,
      },
      secondary: {
        main: isLight ? BRAND_SECONDARY_LIGHT : BRAND_SECONDARY_DARK,
      },
      background: {
        default: isLight ? BG_LIGHT_DEFAULT : BG_DARK_DEFAULT,
        paper: isLight ? BG_LIGHT_PAPER : BG_DARK_PAPER,
      },
      text: {
        primary: isLight ? TEXT_LIGHT_PRIMARY : TEXT_DARK_PRIMARY,
        secondary: isLight ? TEXT_LIGHT_SECONDARY : TEXT_DARK_SECONDARY,
      },

      // Custom palette extensions
      pinnedEntity: {
        main: isLight ? PINNED_ENTITY_LIGHT : PINNED_ENTITY_DARK
      },
      chipBackground: {
        main: isLight ? CHIP_BG_LIGHT : CHIP_BG_DARK,
      },
      frostedSurface: {
        light: FROSTED_LIGHT,
        dark: FROSTED_DARK,
      },
    },

    shape: {
      borderRadius: 8,
    },

    typography: {
      fontFamily: `"Roboto", "Arial", sans-serif`,
      h6: { fontWeight: 600 },
    },

    components: {
      MuiPaper: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiCard: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiDialog: {
        styleOverrides: {
          paper: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiChip: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.chipBackground.main,
            color: theme.palette.text.primary,
          }),
        },
      },
      MuiButton: {
        styleOverrides: {
          root: () => ({
            borderRadius: 8,
          }),
        },
      },
    },
  });
};

@@FOLDER: src/ui
@@FOLDER: src/ui/components
@@FILE: src/ui/components/AiSettingsEditor.tsx
// src/ui/components/AiSettingsEditor.tsx

import React from 'react';
import {
  Box,
  Typography,
  Slider,
  Switch,
  FormControlLabel,
  Divider,
  TextField,
  MenuItem,
} from '@mui/material';
import { AiSettings, AiConnection } from '../../models/index';
import { CollapsibleSection } from './CollapsibleSection';

interface AiSettingsEditorProps {
  label: string;
  settings: AiSettings;
  onSettingsChange: (updatedSettings: AiSettings) => void;
  availableConnections: AiConnection[];
}

export const AiSettingsEditor: React.FC<AiSettingsEditorProps> = ({
  label,
  settings,
  onSettingsChange,
  availableConnections,
}) => {
  const handleSliderChange = (
    prop: keyof AiSettings,
    newValue: number | number[]
  ) => {
    onSettingsChange({ ...settings, [prop]: newValue as number });
  };

  const handleSwitchChange = (prop: keyof AiSettings, checked: boolean) => {
    onSettingsChange({ ...settings, [prop]: checked });
  };

  const handleConnectionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onSettingsChange({ ...settings, selectedConnectionId: event.target.value });
  };

  return (
    <CollapsibleSection title={label} initiallyExpanded={false}>
      <TextField
        select
        fullWidth
        label="AI Connection"
        value={settings.selectedConnectionId}
        onChange={handleConnectionChange}
        variant="outlined"
        sx={{ mb: 2 }}
      >
        {availableConnections.map((conn) => (
          <MenuItem key={conn.id} value={conn.id}>
            {conn.modelName} ({conn.id})
          </MenuItem>
        ))}
      </TextField>

      <Typography gutterBottom>
        Temperature: {settings.temperature.toFixed(2)}
      </Typography>
      <Slider
        value={settings.temperature}
        onChange={(_e, val) => handleSliderChange('temperature', val)}
        min={0.0}
        max={1.5}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls randomness. Low = logical, high = creative. RPG-optimal:
        0.71.0.
      </Typography>

      <Typography gutterBottom>Top P: {settings.topP.toFixed(2)}</Typography>
      <Slider
        value={settings.topP}
        onChange={(_e, val) => handleSliderChange('topP', val)}
        min={0.0}
        max={1.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls diversity. Lower = focused, higher = expressive. RPG-optimal:
        0.81.0.
      </Typography>

      <Typography gutterBottom>Max Tokens: {settings.maxTokens}</Typography>
      <Slider
        value={settings.maxTokens}
        onChange={(_e, val) => handleSliderChange('maxTokens', val)}
        min={256}
        max={8192}
        step={256}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Maximum length of AI reply. Longer = more story depth. RPG-optimal:
        10244096.
      </Typography>

      <Typography gutterBottom>
        Presence Penalty: {settings.presencePenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.presencePenalty}
        onChange={(_e, val) => handleSliderChange('presencePenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages introducing new topics repeatedly. RPG-optimal: 0.00.5.
      </Typography>

      <Typography gutterBottom>
        Frequency Penalty: {settings.frequencyPenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.frequencyPenalty}
        onChange={(_e, val) => handleSliderChange('frequencyPenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages repeating phrases. Helps avoid spam. RPG-optimal: 0.20.8.
      </Typography>

      <Divider sx={{ my: 2 }} />

      <FormControlLabel
        control={
          <Switch
            checked={settings.functionCallingEnabled}
            onChange={(e) =>
              handleSwitchChange('functionCallingEnabled', e.target.checked)
            }
          />
        }
        label="Enable Function Calling"
      />
      <Typography variant="body2" color="text.secondary">
        Allows AI to call structured functions (if you've defined them in the
        prompt).
      </Typography>
    </CollapsibleSection>
  );
};
@@FILE: src/ui/components/AuthOrchestrator.tsx
// src/components/AuthOrchestrator.tsx
import React, { useState, useEffect } from 'react';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useNavigate, useLocation, Outlet } from 'react-router-dom';
import { Box, CircularProgress, Typography } from '@mui/material';

const AuthOrchestrator: React.FC = () => {
  const { user } = useAuthStore();
  const { loadLastActiveGame, gameLoading } = useGameStateStore();
  const navigate = useNavigate();
  const location = useLocation();
  const [initialLoadChecked, setInitialLoadChecked] = useState(false);

  useEffect(() => {
    if (!user || initialLoadChecked) {
      return;
    }

    console.log("AuthOrchestrator: User authenticated, loading last active game...");
    loadLastActiveGame(user.uid).then((gameLoaded) => {
      setInitialLoadChecked(true);
      // Redirect only if the user is at the root path after login.
      // This avoids overriding intentional navigation to other pages like /cards or /settings.
      if (location.pathname === '/') {
        if (gameLoaded) {
          navigate('/game', { replace: true });
        } else {
          navigate('/library', { replace: true });
        }
      }
    });
  }, [user, initialLoadChecked, loadLastActiveGame, navigate, location.pathname]);

  if (!initialLoadChecked || gameLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Session...</Typography>
      </Box>
    );
  }

  // Once the orchestration is complete, render the designated child route.
  return <Outlet />;
};

export default AuthOrchestrator;
@@FILE: src/ui/components/CollapsibleLogEntry.tsx
// src/ui/components/CollapsibleLogEntry.tsx

import React from 'react';
import { Box, Typography, Divider } from '@mui/material';
import { LogEntry } from '../../models/LogEntry';
import { LogViewMode } from '../../utils/types';
import { CollapsibleSection } from './CollapsibleSection';
import { LogEntryDisplay } from './LogEntryDisplay';

interface CollapsibleLogEntryProps {
  entry: LogEntry;
  selectedLogViewModes: LogViewMode[];
}

export const CollapsibleLogEntry: React.FC<CollapsibleLogEntryProps> = ({ entry, selectedLogViewModes }) => {
  // Determine if there's any content to show based on selected modes
  const hasContent = selectedLogViewModes.some(mode => {
    switch (mode) {
      case LogViewMode.NARRATOR_OUTPUT: return !!entry.narratorOutput;
      case LogViewMode.USER_INPUT: return !!entry.userInput;
      case LogViewMode.DIGEST_LINES: return (entry.digestLines?.length || 0) > 0;
      case LogViewMode.DELTAS: return entry.deltas && Object.keys(entry.deltas).length > 0;
      case LogViewMode.CONTEXT_SNAPSHOT: return !!entry.contextSnapshot;
      case LogViewMode.TOKEN_USAGE: return !!entry.tokenUsage;
      case LogViewMode.AI_SETTINGS: return !!entry.aiSettings;
      case LogViewMode.API_DETAILS: return !!entry.apiUrl || !!entry.modelSlugUsed || entry.latencyMs !== null;
      case LogViewMode.ERROR_FLAGS: return (entry.errorFlags?.length || 0) > 0;
      case LogViewMode.MODEL_SLUG_USED: return !!entry.modelSlugUsed;
      default: return false;
    }
  });

  if (!hasContent) {
    // Optionally return null or a placeholder if no content is selected to display
    // For now, if the main entry title is desired even without content, keep rendering.
    // If you want to hide the whole entry if nothing is selected, uncomment below.
    // return null;
  }

  return (
    <CollapsibleSection
      title={`Turn ${entry.turnNumber} - ${new Date(entry.timestamp).toLocaleTimeString()}`}
      initiallyExpanded={entry.turnNumber === 0} // Expand Turn 0 by default
    >
      <Box sx={{ p: 1 }}>
        {selectedLogViewModes.length === 0 ? (
          <Typography variant="body2" color="text.secondary">
            No log view modes selected for this entry. Please select modes from the "Log Views" menu.
          </Typography>
        ) : (
          selectedLogViewModes.map((mode, index) => (
            <React.Fragment key={mode}>
              <CollapsibleSection title={mode} initiallyExpanded={true}> {/* Inner collapsible for each mode */}
                <LogEntryDisplay mode={mode} entry={entry} hideTurnInfo={true} />
              </CollapsibleSection>
              {index < selectedLogViewModes.length - 1 && <Divider sx={{ my: 1 }} />}
            </React.Fragment>
          ))
        )}
      </Box>
    </CollapsibleSection>
  );
};
@@FILE: src/ui/components/CollapsibleSection.tsx
// src/ui/components/CollapsibleSection.tsx

import React from 'react';
import {
  Card,
  CardContent,
  Typography,
  IconButton,
  Collapse,
  Box,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';

interface CollapsibleSectionProps {
  title: string;
  children: React.ReactNode;
  initiallyExpanded?: boolean;
}

export const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  children,
  initiallyExpanded = false,
}) => {
  const [expanded, setExpanded] = React.useState(initiallyExpanded);

  const handleExpandClick = () => {
    setExpanded(!expanded);
  };

  return (
    <Card variant="outlined" sx={{ mb: 2 }}>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1.5,
          cursor: 'pointer',
          '&:hover': {
            backgroundColor: (theme) => theme.palette.action.hover,
          },
        }}
        onClick={handleExpandClick}
      >
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
        </Typography>
        <IconButton
          onClick={handleExpandClick}
          aria-expanded={expanded}
          aria-label="show more"
          size="small"
        >
          {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
      </Box>
      <Collapse in={expanded} timeout="auto" unmountOnExit>
        <CardContent sx={{ pt: 1 }}>{children}</CardContent>
      </Collapse>
    </Card>
  );
};
@@FILE: src/ui/components/InfoDialog.tsx
// src/ui/components/InfoDialog.tsx

import React, { useState } from 'react';
import { Dialog, DialogTitle, DialogContent, DialogActions, Button, IconButton, Tooltip, Box } from '@mui/material';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';

interface InfoDialogProps {
  title: string;
  content: string | React.ReactNode; // Can be a string or JSX
  iconSize?: 'small' | 'medium' | 'large';
  tooltipText?: string; // Optional text for the initial hover tooltip
}

export const InfoDialog: React.FC<InfoDialogProps> = ({ title, content, iconSize = 'small', tooltipText = "Click for more information" }) => {
  const [open, setOpen] = useState(false);

  const handleClickOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <>
      <Tooltip title={tooltipText}>
        <IconButton size={iconSize} onClick={handleClickOpen} sx={{ ml: 0.5, p: 0 }}>
          <InfoOutlinedIcon fontSize="small" />
        </IconButton>
      </Tooltip>
      <Dialog
        open={open}
        onClose={handleClose}
        aria-labelledby="info-dialog-title"
        fullWidth
        maxWidth="sm"
      >
        <DialogTitle id="info-dialog-title">{title}</DialogTitle>
        <DialogContent dividers>
          {/* Use Box with pre-wrap to respect line breaks in string content */}
          {typeof content === 'string' ? <Box sx={{ whiteSpace: 'pre-wrap' }}>{content}</Box> : content}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Close</Button>
        </DialogActions>
      </Dialog>
    </>
  );
};
@@FILE: src/ui/components/LogEntryDisplay.tsx
// src/ui/components/LogEntryDisplay.tsx

import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
import { LogEntry } from '../../models/LogEntry';
import { LogViewMode } from '../../utils/types';

interface LogEntryDisplayProps {
 mode: LogViewMode;
 entry: LogEntry;
 hideTurnInfo?: boolean; // New optional prop
}

export const LogEntryDisplay: React.FC<LogEntryDisplayProps> = ({ mode, entry, hideTurnInfo }) => {
 const renderContent = () => {
  switch (mode) {
   case LogViewMode.NARRATOR_OUTPUT:
    return entry.narratorOutput;
   case LogViewMode.USER_INPUT:
    return entry.userInput;
   case LogViewMode.DIGEST_LINES:
    // MODIFIED: Use `d.importance` which should now be correct
    return entry.digestLines.map(d => `${d.text} (Imp: ${d.importance})`).join('\n');
   case LogViewMode.DELTAS:
    return entry.deltas ? JSON.stringify(entry.deltas, null, 2) : 'No Deltas';
   case LogViewMode.CONTEXT_SNAPSHOT:
    return entry.contextSnapshot ? entry.contextSnapshot : 'No Context Snapshot';
   case LogViewMode.TOKEN_USAGE:
    return entry.tokenUsage ? `Input: ${entry.tokenUsage.inputTokens}, Output: ${entry.tokenUsage.outputTokens}, Total: ${entry.tokenUsage.totalTokens}` : 'No Token Usage Info';
   case LogViewMode.AI_SETTINGS:
    return entry.aiSettings ? JSON.stringify(entry.aiSettings, null, 2) : 'No AI Settings';
   case LogViewMode.API_DETAILS: {
      // MODIFIED: Build a more detailed API details string
     const details = [
      `URL: ${entry.apiUrl || 'N/A'}`,
      `Model: ${entry.modelSlugUsed || 'N/A'}`,
      `Latency: ${entry.latencyMs !== null ? `${entry.latencyMs}ms` : 'N/A'}`,
     ];
      if (entry.apiRequestBody) {
        details.push(`\n--- Request Body (without content) ---\n${entry.apiRequestBody}`);
      }
      if (entry.apiResponseBody) {
        details.push(`\n--- Response Body ---\n${entry.apiResponseBody}`);
      }
      return details.join('\n');
    }
   case LogViewMode.ERROR_FLAGS:
    return entry.errorFlags && entry.errorFlags.length > 0 ? entry.errorFlags.join(', ') : 'No Errors';
   case LogViewMode.MODEL_SLUG_USED:
     return entry.modelSlugUsed || 'N/A';
   default:
    return 'Select a view mode.';
  }
 };

  return (
    <Box sx={{ mb: 1.5 }}>
      {/* Conditionally render turn info based on new prop */}
      {!hideTurnInfo && (
        <Typography variant="caption" color="text.secondary">
          Turn {entry.turnNumber} - {new Date(entry.timestamp).toLocaleTimeString()}
        </Typography>
      )}
      <Typography variant="body2" component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word', mt: 0.5 }}>
        {renderContent()}
      </Typography>
    </Box>
  );
};
@@FILE: src/ui/components/LogView.tsx
// src/ui/components/LogView.tsx

import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
// MODIFIED: Import Message model instead of LogEntry
import { Message } from '../../models/Message';

interface LogViewProps {
 // MODIFIED: Expect conversationHistory of type Message[]
 conversationHistory: Message[];
}

export const LogView: React.FC<LogViewProps> = ({ conversationHistory }) => {
 return (
  <Box sx={{ flexGrow: 1, overflowY: 'auto' }}>
   {conversationHistory.length === 0 ? (
    <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mt: 4 }}>
     The story begins...
    </Typography>
   ) : (
    // MODIFIED: Map over conversationHistory
    conversationHistory.map((message, index) => (
     <Paper key={index} elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
      {message.role === 'user' ? (
       <>
        <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.primary.dark }}>
         You:
        </Typography>
        <Typography variant="body1" sx={{ mb: 1 }}>
         {message.content}
        </Typography>
       </>
      ) : message.role === 'assistant' ? (
       <>
        <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
         AI Narrator:
        </Typography>
        <Typography variant="body1">
         {message.content}
        </Typography>
       </>
        ) : null}
     </Paper>
    ))
   )}
  </Box>
 );
};
@@FILE: src/ui/components/MainLayout.tsx
// src/ui/components/MainLayout.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Drawer, List, ListItem, ListItemButton, ListItemIcon, ListItemText,
  CssBaseline, Box, Typography, Divider, IconButton
} from '@mui/material';
import LogoutIcon from '@mui/icons-material/Logout';
import MenuIcon from '@mui/icons-material/Menu';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { getNavItems } from '../../config/navigation';
import { LayoutProvider } from '../../contexts/LayoutContext';

const drawerWidth = 240;

const MainLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user, signOut } = useAuthStore();
  const { currentSnapshot } = useGameStateStore();
  const navigate = useNavigate();
  const [mobileOpen, setMobileOpen] = useState(false);

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleSignOut = async () => {
    await signOut();
    navigate('/login');
  };

  const navItems = getNavItems(currentSnapshot);

  const drawerContent = (
    <Box onClick={handleDrawerToggle} sx={{ textAlign: 'center' }}>
      <Typography variant="h6" sx={{ my: 2 }}>StoryForge</Typography>
      <Divider />
      <List>
        {navItems.filter(item => user ? true : !item.requiresAuth).map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton onClick={() => navigate(item.path)} disabled={item.disabled}>
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
        {user ? (
          <ListItem disablePadding>
            <ListItemButton onClick={handleSignOut}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItemButton>
          </ListItem>
        ) : (
          <ListItem disablePadding>
            <ListItemButton onClick={() => navigate('/login')}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Login" />
            </ListItemButton>
          </ListItem>
        )}
      </List>
    </Box>
  );

  return (
    <LayoutProvider>
      <Box sx={{ display: 'flex', height: '100vh' }}>
        <CssBaseline />
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{ keepMounted: true }}
          sx={{ '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth } }}
        >
          {drawerContent}
        </Drawer>

        <Box component="main" sx={{ flexGrow: 1, height: '100%', display: 'flex', flexDirection: 'column' }}>
          {user && (
            <IconButton
              color="inherit"
              aria-label="open drawer"
              onClick={handleDrawerToggle}
              edge="start"
              sx={{
                position: 'fixed',
                top: 16,
                right: 16,
                zIndex: (theme) => theme.zIndex.drawer + 1,
                backgroundColor: (theme) => theme.palette.background.paper,
                boxShadow: 2,
                '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
              }}
            >
              <MenuIcon />
            </IconButton>
          )}
          {children}
        </Box>
      </Box>
    </LayoutProvider>
  );
};

export default MainLayout;
@@FILE: src/ui/components/PinnedAttributeChip.tsx
// src/ui/components/PinnedAttributeChip.tsx

import React from 'react';
import { Chip, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';

interface PinnedAttributeChipProps {
  fullKey: string;
  label: string;
  value: any;
  onUnpin: (key: string) => void;
}

export const PinnedAttributeChip: React.FC<PinnedAttributeChipProps> = React.memo(
  ({ fullKey, label, value, onUnpin }) => {
    const longPressProps = useLongPress((e) => {
      e.stopPropagation();
      onUnpin(fullKey);
    });

    return (
      <Tooltip title={`Long-press to unpin '${label}'`} key={fullKey}>
        <Chip
          label={`${label}: ${JSON.stringify(value)}`}
          size="small"
          deleteIcon={<PushPinIcon />}
          sx={{
            backgroundColor: (theme) => theme.palette.chipBackground.main, // CHIP_BG_LIGHT/DARK
            color: (theme) => theme.palette.text.primary,
            fontSize: '0.8rem',
            height: '22px',
            '& .MuiChip-label': {
              px: 1,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
            },
            '& .MuiChip-deleteIcon': {
              opacity: 0.2,
            },
            '&:hover .MuiChip-deleteIcon': {
              opacity: 1,
            },
          }}
          {...longPressProps}
        />
      </Tooltip>
    );
  }
);

@@FILE: src/ui/components/PinnedEntityGroup.tsx
// src/ui/components/PinnedEntityGroup.tsx

import React from 'react';
import { Paper, Typography, Stack, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';
import { PinnedAttributeChip } from './PinnedAttributeChip';

interface Attribute {
  label: string;
  value: any;
  fullKey: string;
}

interface PinnedEntityGroupProps {
  entityPath: string;
  attributes: Attribute[];
  onUnpinEntity: (path: string) => void;
  onUnpinVariable: (key: string) => void;
}

export const PinnedEntityGroup: React.FC<PinnedEntityGroupProps> = ({
  entityPath,
  attributes,
  onUnpinEntity,
  onUnpinVariable,
}) => {
  const longPressEntityProps = useLongPress(() => {
    onUnpinEntity(entityPath);
  });

  const entityDisplayName = entityPath.includes('.')
    ? entityPath.split('.').pop()?.replace(/^[#@$]/, '')
    : entityPath;

  return (
    <Paper
      elevation={3}
      sx={{
        p: 1,
        minWidth: 150,
        backgroundColor: (theme) =>
          theme.palette.mode === 'light'
            ? theme.palette.pinnedEntity.main // Uses PINNED_ENTITY_LIGHT
            : theme.palette.pinnedEntity.main, // Uses PINNED_ENTITY_DARK
        backdropFilter: 'blur(4px)',
        color: (theme) => theme.palette.text.primary,
        flexShrink: 0,
        cursor: 'pointer',
        borderRadius: 3,
        boxShadow: (theme) => theme.shadows[4],
        transition: 'transform 0.15s ease, box-shadow 0.15s ease',
        '&:hover': {
          transform: 'translateY(-2px)',
          boxShadow: (theme) => theme.shadows[6],
        },
      }}
      {...longPressEntityProps}
    >

      <Typography variant="subtitle2" sx={{ fontWeight: 'bold' }}>
        {entityDisplayName}
        <Tooltip title="Long-press to unpin all for this group">
          <PushPinIcon fontSize="small" sx={{ verticalAlign: 'middle', ml: 0.5 }} />
        </Tooltip>
      </Typography>
      <Stack direction="column" spacing={0.5} sx={{ mt: 1 }}>
        {attributes.map((attr) => (
          <PinnedAttributeChip
            key={attr.fullKey}
            fullKey={attr.fullKey}
            label={attr.label}
            value={attr.value}
            onUnpin={onUnpinVariable}
          />
        ))}
      </Stack>
    </Paper>
  );
};

@@FILE: src/ui/components/PinnedItemsView.tsx
// src/ui/components/PinnedItemsView.tsx

import React, { useEffect } from 'react';
import { Box, Typography, Paper, Stack } from '@mui/material';
import { GameState } from '../../models/GameState';
import { useGameStateStore } from '../../state/useGameStateStore';
import { flattenJsonObject, getNestedValue } from '../../utils/jsonUtils'; // Ensure getNestedValue is imported
import { PinnedEntityGroup } from './PinnedEntityGroup';

interface PinnedItemsViewProps {
  gameState: GameState;
}

export const PinnedItemsView: React.FC<PinnedItemsViewProps> = ({ gameState }) => {
  // Directly select worldStatePinnedKeys and the actions from the store
  // Make sure currentGameState is destructured here if you use it in the component's render or memoized values.
  const { worldStatePinnedKeys, unpinAllForEntity, unpinIndividualVariable } = useGameStateStore();

  // IMPORTANT: Ensure this `worldState` is the actual, current GameState from the prop.
  // We're relying on `gameState` prop being updated by GameScreen
  const worldState = gameState?.worldState || {};

  // Memoize the flattened world state. This should only re-run if the gameState.worldState object reference changes.
  const flattenedWorld = React.useMemo(() => {
    return flattenJsonObject(worldState);
  }, [worldState]); // Depend on the worldState object itself


  // Memoize the list of items to be displayed (key-value pairs)
  // This is the array that feeds into the grouping logic.
  const pinnedItems = React.useMemo(() => {
    // Filter `worldStatePinnedKeys` directly from the store based on `flattenedWorld`'s existence
    const items = worldStatePinnedKeys
      .map(key => ({
        key,
        value: flattenedWorld[key], // Access value from the memoized flattened object
      }))
      .filter(item => {
          // This filter is critical. An item should only be considered if its value is not undefined.
          // This handles cases where a pinned item might no longer exist in the worldState.
          return item.value !== undefined;
      });

      console.log("[PinnedItemsView:pinnedItems] Calculated pinnedItems. Length:", items.length, "Items:", items);
      return items;
  }, [worldStatePinnedKeys, flattenedWorld]); // Depend on both for re-calculation

  // Grouped pinned items logic
  const groupedPinnedItems = React.useMemo(() => {
    const grouped: { [entityPath: string]: { label: string; value: any; fullKey: string }[] } = {};
    pinnedItems.forEach(item => {
      const parts = item.key.split('.');
      if (parts.length >= 2) {
        const secondPart = parts[1];
        const isTaggedEntity = secondPart.startsWith('#') || secondPart.startsWith('@') || secondPart.startsWith('$');
        let entityPath: string;
        let label: string;

        if (parts.length >= 3 && isTaggedEntity) {
          entityPath = parts.slice(0, 2).join('.');
          label = parts.slice(2).join('.');
        } else {
          entityPath = parts[0];
          label = parts.slice(1).join('.');
        }

        // This fallback might have been the source of the 31 vs 32 discrepancy if a root-level key was accidentally pinned as a variable
        // but based on your logs, all pinned keys seem deeply nested. Let's keep it robust.
        if (label === '') {
          label = parts[parts.length - 1]; // Fallback, e.g., if key is "world"
        }

        grouped[entityPath] = grouped[entityPath] || [];
        grouped[entityPath].push({ label, value: item.value, fullKey: item.key });
      }
    });
    // Sort attributes within each group for consistent rendering
    Object.keys(grouped).forEach(entityPath => {
      grouped[entityPath].sort((a, b) => a.label.localeCompare(b.label));
    });
    console.log("[PinnedItemsView] Grouped Pinned Items (re-calculated):", grouped); // Updated log message
    return grouped;
  }, [pinnedItems]); // Recalculate if pinnedItems array changes

  // Logging effect for re-renders and key count
  useEffect(() => {
    console.log("[PinnedItemsView] Component re-rendered. Current worldStatePinnedKeys (from store):", worldStatePinnedKeys);
    console.log("[PinnedItemsView] Number of pinned keys (from store):", worldStatePinnedKeys.length);
    console.log("[PinnedItemsView] Number of calculated pinnedItems (filtered):", pinnedItems.length);
    console.log("[PinnedItemsView] Number of grouped entities:", Object.keys(groupedPinnedItems).length);
    let totalGroupedItems = 0;
    Object.values(groupedPinnedItems).forEach(arr => totalGroupedItems += arr.length);
    console.log("[PinnedItemsView] Total items in groupedPinnedItems:", totalGroupedItems);

  }, [worldStatePinnedKeys, pinnedItems, groupedPinnedItems]); // Added pinnedItems to dependency

  if (pinnedItems.length === 0) { // Check length of `pinnedItems` (the filtered list)
    return (
      <Paper elevation={0} sx={{ p: 1.5, mt: 1, backgroundColor: (theme) => theme.palette.background.default }}>
        <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
          No items pinned. Right-click or long-press items in the World State screen to pin them here.
        </Typography>
      </Paper>
    );
  }

  return (
    <Stack
      direction="row"
      spacing={2}
      sx={{
        py: 1,
        overflowX: 'auto',
        backgroundColor: 'transparent',
      }}
    >
      {Object.entries(groupedPinnedItems).map(([entityPath, attributes]) => (
        <PinnedEntityGroup
          key={entityPath} // Keying by entityPath is correct for entity groups
          entityPath={entityPath}
          attributes={attributes}
          onUnpinEntity={unpinAllForEntity}
          onUnpinVariable={unpinIndividualVariable}
        />
      ))}
    </Stack>
  );
};
@@FILE: src/ui/components/ProtectedRoute.tsx
// src/ui/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../../state/useAuthStore';
import { Box, CircularProgress, Typography } from '@mui/material';

interface ProtectedRouteProps {
  children: JSX.Element;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { user, isLoading } = useAuthStore();
  const location = useLocation();

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Verifying Authentication...</Typography>
      </Box>
    );
  }

  if (!user) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to. This allows us to send them along to that page after they login.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default ProtectedRoute;
@@FILE: src/ui/components/StackInstructionsEditor.tsx
// src/ui/components/StackInstructionsEditor.tsx
import React from 'react';
import { Box, Typography, Divider, Checkbox, FormControlLabel, TextField } from '@mui/material';
import { CollapsibleSection } from './CollapsibleSection';
import { InfoDialog } from './InfoDialog';
import { StackInstructions, ProsePolicy, DigestFilterPolicy, TokenPolicy, EmissionRule } from '../../models';

// Import the new, smaller components
import { PolicyEditor } from './stackInstructions/PolicyEditor';
import { DigestPolicyEditor } from './stackInstructions/DigestPolicyEditor';
import { TokenPolicyEditor } from './stackInstructions/TokenPolicyEditor';

interface StackInstructionsEditorProps {
  stackInstructions: StackInstructions;
  onStackInstructionsChange: (updatedInstructions: StackInstructions) => void;
}

const StackInstructionsEditor: React.FC<StackInstructionsEditorProps> = ({
  stackInstructions,
  onStackInstructionsChange,
}) => {
  // Generic handler to update a top-level policy object in the main state
  const handlePolicyChange = (
    policyKey: keyof StackInstructions,
    value: ProsePolicy | DigestFilterPolicy | TokenPolicy | Record<number, EmissionRule> | boolean | number
  ) => {
    onStackInstructionsChange({
      ...stackInstructions,
      [policyKey]: value,
    });
  };

  return (
    <CollapsibleSection title=" Stack Instructions" initiallyExpanded={false}>
      <Box sx={{ mb: 3 }}>
        <Typography variant="body2" color="text.secondary">
          These settings control how previous game information (the 'context stack') is assembled
          and presented to the AI for each new turn.
          <InfoDialog
            title="Understanding the Context Stack"
            content={`The AI's 'memory' for each turn is built from a 'context stack'. The order and content of this stack significantly impact AI responses. Each section below can be individually enabled/disabled.`}
          />
        </Typography>
      </Box>

      {/* -- Use the new PolicyEditor for repeating patterns -- */}
      <PolicyEditor
        title="Narrator Prose Emission"
        policy={stackInstructions.narratorProseEmission}
        onPolicyChange={(p) => handlePolicyChange('narratorProseEmission', p)}
        infoContent={{
          main: "Controls how past narrator output (the main story text) is included in the AI's context.",
          mode: "- ALWAYS: Include all past narrator prose.\n- FIRST_N: Include prose only from the first 'N' turns.\n- AFTER_N: Include prose only from turns after 'N'.\n- NEVER: Do not include any past narrator prose.",
          filtering: "- NONE: Include all prose based on the selected mode.\n- SCENE_ONLY: Only include prose relevant to the current scene.\n- TAGGED: Only include prose that contains any recognized tags."
        }}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Use the new DigestPolicyEditor -- */}
      <DigestPolicyEditor
        digestPolicy={stackInstructions.digestPolicy}
        digestEmission={stackInstructions.digestEmission}
        onPolicyChange={(p) => handlePolicyChange('digestPolicy', p)}
        onEmissionChange={(e) => handlePolicyChange('digestEmission', e)}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Expression Log is another ProsePolicy, so reuse PolicyEditor -- */}
      <PolicyEditor
        title="Expression Log Policy"
        policy={stackInstructions.expressionLogPolicy}
        onPolicyChange={(p) => handlePolicyChange('expressionLogPolicy', p)}
        infoContent={{
          main: "Controls how character 'expression' (portions of past narrator prose related to character actions/emotions) is included.",
          mode: "Controls when expression logs are included (Always, First N turns, etc.).",
          filtering: "Filters which expression logs are included based on tags."
        }}
      />
      {/* Specific fields for Expression Log that aren't in the generic policy */}
      <Box sx={{ ml: 2, mt: -2, mb: 2 }}>
        <TextField
          label="Expression Lines Per Character"
          type="number"
          value={stackInstructions.expressionLinesPerCharacter}
          onChange={(e) => handlePolicyChange('expressionLinesPerCharacter', parseInt(e.target.value))}
          sx={{ my: 2, width: '250px' }}
          inputProps={{ min: 0 }}
          InputProps={{
            endAdornment: <InfoDialog title="Expression Lines Per Character" content="The maximum number of lines of narrative prose to extract and summarize for character expressions." />
          }}
        />
        <FormControlLabel
          control={
            <Checkbox
              checked={stackInstructions.emotionWeighting}
              onChange={(e) => handlePolicyChange('emotionWeighting', e.target.checked)}
            />
          }
          label="Emotion Weighting"
        />
      </Box>

      <Divider sx={{ my: 3 }} />

      <PolicyEditor
        title="World State Policy"
        policy={stackInstructions.worldStatePolicy}
        onPolicyChange={(p) => handlePolicyChange('worldStatePolicy', p)}
        infoContent={{
          main: "Controls how the current world state JSON is included in the AI's context.",
          mode: "Controls when the world state is included.",
          filtering: "Filters which parts of the world state are included (e.g., scene-only)."
        }}
      />

      <Divider sx={{ my: 3 }} />

      <PolicyEditor
        title="Known Entities Policy"
        policy={stackInstructions.knownEntitiesPolicy}
        onPolicyChange={(p) => handlePolicyChange('knownEntitiesPolicy', p)}
        infoContent={{
          main: "Controls how a list of 'known entities' (tagged items, characters, locations) is included. This list reminds the AI of important things without sending the full world state.",
          mode: "Controls when the known entities list is included.",
          filtering: "Filters which known entities are listed."
        }}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Use the new TokenPolicyEditor -- */}
      <TokenPolicyEditor
        tokenPolicy={stackInstructions.tokenPolicy}
        onPolicyChange={(p) => handlePolicyChange('tokenPolicy', p)}
      />
    </CollapsibleSection>
  );
};

export { StackInstructionsEditor };
@@FILE: src/ui/components/WorldStateItemRow.tsx
// src/ui/components/WorldStateItemRow.tsx

import React, { useState } from 'react';
import {
  Box,
  Typography,
  IconButton,
  TextField,
  InputAdornment,
  Checkbox,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import PushPinIcon from '@mui/icons-material/PushPin';
import PushPinOutlinedIcon from '@mui/icons-material/PushPinOutlined';
import { parseJsonPrimitive } from '../../utils/jsonUtils';

interface WorldStateItemRowProps {
  itemKey: string; // Full key, e.g., "npcs.goblin_1.hp"
  value: any; // The raw value, JsonElement equivalent
  onDelete: (key: string) => Promise<void>; // Make it async as store actions might be async
  onEdit: (key: string, value: any) => Promise<void>; // Make it async
  isPinned: boolean;
  onTogglePin: (key: string) => void; // This will call the store's toggleWorldStatePin with 'variable' type
}

export const WorldStateItemRow: React.FC<WorldStateItemRowProps> = ({
  itemKey,
  value,
  onDelete,
  onEdit,
  isPinned,
  onTogglePin,
}) => {
  const [editMode, setEditMode] = useState(false);
  const [editText, setEditText] = useState(JSON.stringify(value)); // Use JSON.stringify for complex values

  // Extract the last part of the key for display name
  const displayName = itemKey.substring(itemKey.lastIndexOf('.') + 1);

  const handleEditConfirm = async () => {
    try {
      const parsedValue = parseJsonPrimitive(editText);
      await onEdit(itemKey, parsedValue); // Await the async edit operation
      setEditMode(false);
    } catch (e) {
      console.error("Failed to parse input for world state edit:", e);
      // TODO: Provide user feedback (e.g., Snackbar) for parsing errors
    }
  };

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        mb: 1,
        p: 1,
        borderRadius: 1,
        backgroundColor: (theme) => (editMode ? theme.palette.action.hover : 'transparent'),
      }}
    >
      <Typography variant="body2" sx={{ fontWeight: 'bold', flexShrink: 0 }}>
        {displayName}:
      </Typography>
      <Box sx={{ flexGrow: 1 }}>
        {editMode ? (
          <TextField
            fullWidth
            size="small"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onBlur={handleEditConfirm}
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleEditConfirm();
              }
            }}
            InputProps={{
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton size="small" onClick={handleEditConfirm}>
                    <EditIcon fontSize="small" />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        ) : (
          <Typography
            variant="body2"
            sx={{
              cursor: 'pointer',
              border: '1px solid',
              borderColor: (theme) => theme.palette.divider,
              borderRadius: 1,
              p: 0.8,
              '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
            }}
            onClick={() => setEditMode(true)}
          >
            {JSON.stringify(value)}
          </Typography>
        )}
      </Box>
      <Checkbox
        icon={<PushPinOutlinedIcon fontSize="small" />}
        checkedIcon={<PushPinIcon fontSize="small" />}
        checked={isPinned}
        onChange={() => onTogglePin(itemKey)} // Pass the full itemKey
        size="small"
        sx={{ p: 0.5 }}
      />
      <IconButton size="small" onClick={() => onDelete(itemKey)} sx={{ p: 0.5 }}>
        <DeleteIcon fontSize="small" color="error" />
      </IconButton>
    </Box>
  );
};
@@FOLDER: src/ui/components/promptCardEditorParts
@@FILE: src/ui/components/promptCardEditorParts/CorePromptEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  prompt: string;
  onPromptChange: (prompt: string) => void;
}

export const CorePromptEditor: React.FC<Props> = ({ prompt, onPromptChange }) => (
  <CollapsibleSection title="AI Prompt" initiallyExpanded={true}>
    <TextField
      fullWidth
      multiline
      minRows={5}
      label={
        <>
          Core Scenario / Persona Prompt
          <InfoDialog
            title="Core Scenario / Persona Prompt"
            content="This is the most important part of your prompt card. It defines the core scenario, the AI's persona, the setting, and any foundational rules. This text is ALWAYS sent to the AI."
          />
        </>
      }
      value={prompt}
      onChange={(e) => onPromptChange(e.target.value)}
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/EmitSkeletonEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';
import { DEFAULT_EMIT_SKELETON_STRING } from '../../../data/config/promptCardDefaults';

interface Props {
  emitSkeleton: string;
  onEmitSkeletonChange: (value: string) => void;
}

export const EmitSkeletonEditor: React.FC<Props> = ({ emitSkeleton, onEmitSkeletonChange }) => (
  <CollapsibleSection title="Emit & Tagging Skeleton" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={6}
      label={
        <>
          Emit/Tagging Rules (JSON/Text)
          <InfoDialog
            title="Emit & Tagging Skeleton"
            content={`This section provides the AI with strict rules on how to output structured data (@delta, @digest, @scene) as part of its response.`}
          />
        </>
      }
      value={emitSkeleton}
      onChange={(e) => onEmitSkeletonChange(e.target.value)}
      placeholder={DEFAULT_EMIT_SKELETON_STRING}
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/FirstTurnEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';
import { DEFAULT_FIRST_TURN_PROMPT_BLOCK } from '../../../data/config/promptCardDefaults';

interface Props {
  firstTurnOnlyBlock: string;
  onFirstTurnChange: (value: string) => void;
}

export const FirstTurnEditor: React.FC<Props> = ({ firstTurnOnlyBlock, onFirstTurnChange }) => (
  <CollapsibleSection title="First Turn Scene Setup" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={4}
      label={
        <>
          Intro scene shown only on turn 1
          <InfoDialog
            title="First Turn Only Block"
            content={`This text is added to the AI's prompt ONLY for the very first turn of a new game. It's ideal for setting an initial scene.`}
          />
        </>
      }
      value={firstTurnOnlyBlock}
      onChange={(e) => onFirstTurnChange(e.target.value)}
      placeholder={DEFAULT_FIRST_TURN_PROMPT_BLOCK}
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/FunctionDefsEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  functionDefs: string;
  onFunctionDefsChange: (value: string) => void;
}

export const FunctionDefsEditor: React.FC<Props> = ({ functionDefs, onFunctionDefsChange }) => (
  <CollapsibleSection title="Function Definitions" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={6}
      label={
        <>
          Function Definitions (JSON)
          <InfoDialog
            title="Function Definitions"
            content={`Provide JSON schemas for functions the AI can 'call'. This enables structured interaction with game systems.`}
          />
        </>
      }
      value={functionDefs}
      onChange={(e) => onFunctionDefsChange(e.target.value)}
      placeholder="e.g., { 'name': 'action', 'parameters': { ... } }"
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/GameRulesEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  gameRules: string;
  onGameRulesChange: (value: string) => void;
}

export const GameRulesEditor: React.FC<Props> = ({ gameRules, onGameRulesChange }) => (
  <CollapsibleSection title="Game Rules Skeleton" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={5}
      label={
        <>
          Game Rules
          <InfoDialog
            title="Game Rules"
            content="Textual rules or guidelines for the AI to follow throughout the game. This is always included in the AI prompt."
          />
        </>
      }
      value={gameRules}
      onChange={(e) => onGameRulesChange(e.target.value)}
      placeholder="Rules for the AI to follow during gameplay."
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/MetadataEditor.tsx
import React from 'react';
import { Box, Checkbox, FormControlLabel } from '@mui/material';
import { InfoDialog } from '../InfoDialog';

interface Props {
  isPublic: boolean;
  isExample: boolean;
  onCardChange: (updates: { isPublic: boolean; isExample: boolean }) => void;
}

export const MetadataEditor: React.FC<Props> = ({ isPublic, isExample, onCardChange }) => (
  <Box sx={{ mt: 3, display: 'flex', flexDirection: 'column', gap: 1 }}>
    <FormControlLabel
      control={
        <Checkbox
          checked={isPublic}
          onChange={(e) => onCardChange({ isPublic: e.target.checked, isExample })}
        />
      }
      label={
        <>
          Make Public (visible to others)
          <InfoDialog
            title="Public Card"
            content="If checked, this prompt card will be visible and potentially usable by other users."
          />
        </>
      }
    />
    <FormControlLabel
      control={
        <Checkbox
          checked={isExample}
          onChange={(e) => onCardChange({ isPublic, isExample: e.target.checked })}
        />
      }
      label={
        <>
          Is Example Card (for showcase)
          <InfoDialog
            title="Example Card"
            content="Mark this card as an official example. This is usually for built-in, curated content."
          />
        </>
      }
    />
  </Box>
);
@@FILE: src/ui/components/promptCardEditorParts/TitleAndDescriptionEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  title: string;
  description: string | null;
  onCardChange: (updates: { title: string; description: string | null }) => void;
}

export const TitleAndDescriptionEditor: React.FC<Props> = ({ title, description, onCardChange }) => (
  <CollapsibleSection title="Title & Description" initiallyExpanded={true}>
    <TextField
      fullWidth
      label={
        <>
          Title
          <InfoDialog
            title="Prompt Card Title"
            content="A short, descriptive name for this prompt card. Used for display in the game library and manager."
          />
        </>
      }
      value={title}
      onChange={(e) => onCardChange({ title: e.target.value, description })}
      sx={{ mb: 2 }}
    />
    <TextField
      fullWidth
      label={
        <>
          Description
          <InfoDialog
            title="Prompt Card Description"
            content="An optional, longer explanation of what this prompt card is about. It is NOT sent to the AI."
          />
        </>
      }
      multiline
      minRows={2}
      value={description || ''}
      onChange={(e) => onCardChange({ title, description: e.target.value || null })}
      placeholder="Optional: A short description for this prompt card."
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/WorldStateInitEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  worldStateInit: string;
  onWorldStateInitChange: (value: string) => void;
}

export const WorldStateInitEditor: React.FC<Props> = ({ worldStateInit, onWorldStateInitChange }) => (
  <CollapsibleSection title="World State Initialization" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={5}
      label={
        <>
          Initial World State (JSON)
          <InfoDialog
            title="Initial World State (JSON)"
            content={`A JSON object defining the starting state of your game world. This is loaded once at the beginning of a new game session.`}
          />
        </>
      }
      value={worldStateInit}
      onChange={(e) => onWorldStateInitChange(e.target.value)}
      placeholder="{}"
    />
  </CollapsibleSection>
);
@@FOLDER: src/ui/components/stackInstructions
@@FILE: src/ui/components/stackInstructions/DigestPolicyEditor.tsx
// src/ui/components/stackInstructions/DigestPolicyEditor.tsx
import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  RadioGroup,
  FormControlLabel,
  Radio,
  Grid,
  Switch,
} from '@mui/material';
import {
  DigestFilterPolicy,
  EmissionRule,
  StackMode,
  FilterMode,
} from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface DigestPolicyEditorProps {
  digestPolicy: DigestFilterPolicy;
  digestEmission: Record<number, EmissionRule>;
  onPolicyChange: (updatedPolicy: DigestFilterPolicy) => void;
  onEmissionChange: (updatedEmission: Record<number, EmissionRule>) => void;
}

export const DigestPolicyEditor: React.FC<DigestPolicyEditorProps> = ({
  digestPolicy,
  digestEmission,
  onPolicyChange,
  onEmissionChange,
}) => {
  const handleEmissionRuleChange = (score: number, field: keyof EmissionRule, value: any) => {
    const currentRule = digestEmission[score] || { mode: StackMode.NEVER, n: 0 };
    onEmissionChange({
      ...digestEmission,
      [score]: { ...currentRule, [field]: value },
    });
  };

  return (
    <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          Digest Lines Emission & Policy
        </Typography>
        <FormControlLabel
          control={
            <Switch
              checked={digestPolicy.enabled ?? false}
              onChange={(e) => onPolicyChange({ ...digestPolicy, enabled: e.target.checked })}
            />
          }
          label="Enable"
          labelPlacement="start"
        />
      </Box>
      <Box sx={{ opacity: digestPolicy.enabled ? 1 : 0.5, pointerEvents: digestPolicy.enabled ? 'auto' : 'none' }}>
        <Typography gutterBottom>
          Global Digest Filtering Policy
          <InfoDialog
            title="Global Digest Filtering Policy"
            content={`Applies a filter to ALL digest lines before their individual emission rules are checked.\n\n- NONE: No global filtering.\n- SCENE_ONLY: Only consider digests relevant to the current scene.\n- TAGGED: Only consider digests that have any tags.`}
          />
        </Typography>
        <FormControl component="fieldset" fullWidth margin="normal">
          <RadioGroup
            row
            value={digestPolicy.filtering}
            onChange={(e) => onPolicyChange({ ...digestPolicy, filtering: e.target.value as FilterMode })}
          >
            {Object.values(FilterMode).map((mode) => (
              <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
            ))}
          </RadioGroup>
        </FormControl>

        <Grid container spacing={2} sx={{ mt: 2 }}>
          {[5, 4, 3, 2, 1].map((score) => (
            <Grid item xs={12} sm={6} md={4} key={score}>
              <Box sx={{ border: '1px solid #ccc', p: 1.5, borderRadius: 1, height: '100%' }}>
                <Typography variant="subtitle2">
                  Importance {score} Digests
                  <InfoDialog
                    title={`Digest Importance Score ${score} Rule`}
                    content={`Determines how digest lines with an importance score of ${score} are included.`}
                  />
                </Typography>
                <FormControl component="fieldset" fullWidth size="small">
                  <RadioGroup
                    row
                    value={digestEmission[score]?.mode || StackMode.NEVER}
                    onChange={(e) => handleEmissionRuleChange(score, 'mode', e.target.value as StackMode)}
                  >
                    {Object.values(StackMode).filter(m => m !== StackMode.FILTERED).map((mode) => (
                      <FormControlLabel key={mode} value={mode} control={<Radio size="small" />} label={mode} sx={{ mb: -1 }}/>
                    ))}
                  </RadioGroup>
                  {(digestEmission[score]?.mode === StackMode.FIRST_N ||
                    digestEmission[score]?.mode === StackMode.AFTER_N) && (
                      <TextField
                        label="N"
                        type="number"
                        value={digestEmission[score]?.n || 0}
                        onChange={(e) => handleEmissionRuleChange(score, 'n', parseInt(e.target.value))}
                        size="small"
                        sx={{ mt: 1, width: '100px' }}
                        inputProps={{ min: 0 }}
                      />
                    )}
                </FormControl>
              </Box>
            </Grid>
          ))}
        </Grid>
      </Box>
    </Box>
  );
};
@@FILE: src/ui/components/stackInstructions/PolicyEditor.tsx
// src/ui/components/stackInstructions/PolicyEditor.tsx
import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  RadioGroup,
  FormControlLabel,
  Radio,
  InputLabel,
  Select,
  MenuItem,
  Switch,
} from '@mui/material';
import { ProsePolicy, StackMode, FilterMode } from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface PolicyEditorProps {
  title: string;
  policy: ProsePolicy;
  onPolicyChange: (updatedPolicy: ProsePolicy) => void;
  infoContent: {
    main: string;
    mode: string;
    filtering: string;
  };
}

export const PolicyEditor: React.FC<PolicyEditorProps> = ({
  title,
  policy,
  onPolicyChange,
  infoContent,
}) => {
  const handleFieldChange = (field: keyof ProsePolicy, value: any) => {
    onPolicyChange({ ...policy, [field]: value });
  };

  return (
    <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
          <InfoDialog title={title} content={infoContent.main} />
        </Typography>
        <FormControlLabel
          control={
            <Switch
              checked={policy.enabled ?? false}
              onChange={(e) => handleFieldChange('enabled', e.target.checked)}
            />
          }
          label="Enable"
          labelPlacement="start"
        />
      </Box>
      <Box sx={{ opacity: policy.enabled ? 1 : 0.5, pointerEvents: policy.enabled ? 'auto' : 'none' }}>
        <Typography gutterBottom>
          Mode
          <InfoDialog title={`${title} Mode`} content={infoContent.mode} />
        </Typography>
        <FormControl component="fieldset" fullWidth margin="normal">
          <RadioGroup
            row
            value={policy.mode}
            onChange={(e) => handleFieldChange('mode', e.target.value as StackMode)}
          >
            {Object.values(StackMode).filter(m => m !== StackMode.FILTERED).map((mode) => (
              <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
            ))}
          </RadioGroup>
          {(policy.mode === StackMode.FIRST_N || policy.mode === StackMode.AFTER_N) && (
            <TextField
              label="N (Turns)"
              type="number"
              value={policy.n}
              onChange={(e) => handleFieldChange('n', parseInt(e.target.value))}
              sx={{ mt: 1, width: '150px' }}
              inputProps={{ min: 0 }}
            />
          )}
        </FormControl>

        <Typography gutterBottom sx={{ mt: 2 }}>
          Filtering
          <InfoDialog title={`${title} Filtering`} content={infoContent.filtering} />
        </Typography>
        <FormControl fullWidth>
          <InputLabel id={`${title}-filtering-label`}>Filtering</InputLabel>
          <Select
            labelId={`${title}-filtering-label`}
            value={policy.filtering}
            label="Filtering"
            onChange={(e) => handleFieldChange('filtering', e.target.value as FilterMode)}
          >
            {Object.values(FilterMode).map((mode) => (
              <MenuItem key={mode} value={mode}>{mode}</MenuItem>
            ))}
          </Select>
        </FormControl>
      </Box>
    </Box>
  );
};
@@FILE: src/ui/components/stackInstructions/TokenPolicyEditor.tsx
// src/ui/components/stackInstructions/TokenPolicyEditor.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';
import { TokenPolicy } from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface TokenPolicyEditorProps {
  tokenPolicy: TokenPolicy;
  onPolicyChange: (updatedPolicy: TokenPolicy) => void;
}

export const TokenPolicyEditor: React.FC<TokenPolicyEditorProps> = ({
  tokenPolicy,
  onPolicyChange,
}) => {
  const handleFieldChange = (field: keyof TokenPolicy, value: any) => {
    onPolicyChange({ ...tokenPolicy, [field]: value });
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Token Policy
      </Typography>
      <TextField
        fullWidth
        label="Min Tokens"
        type="number"
        value={tokenPolicy.minTokens}
        onChange={(e) => handleFieldChange('minTokens', parseInt(e.target.value))}
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
        InputProps={{
          endAdornment: <InfoDialog title="Min Tokens" content="The AI will attempt to generate a response of at least this many tokens." />
        }}
      />
      <TextField
        fullWidth
        label="Max Tokens"
        type="number"
        value={tokenPolicy.maxTokens}
        onChange={(e) => handleFieldChange('maxTokens', parseInt(e.target.value))}
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
        InputProps={{
          endAdornment: <InfoDialog title="Max Tokens" content="The absolute maximum number of tokens the AI can generate." />
        }}
      />
      <TextField
        fullWidth
        label="Fallback Plan"
        value={tokenPolicy.fallbackPlan.join(', ')}
        onChange={(e) => handleFieldChange('fallbackPlan', e.target.value.split(',').map((s) => s.trim()))}
        sx={{ mb: 2 }}
        InputProps={{
          endAdornment: <InfoDialog title="Fallback Plan" content={`A prioritized, comma-separated list of strategies the system will use to reduce the *input prompt's* token count if it exceeds the AI model's context window.\n\nCommon Strategies:\ndrop_known_entities, drop_low_importance_digest, truncate_expression_logs, drop_narrator_prose, truncate_conversation_history`} />
        }}
      />
    </Box>
  );
};
@@FOLDER: src/ui/screens
@@FILE: src/ui/screens/CardLibraryScreen.tsx
// src/ui/screens/PromptCardLibraryScreen.tsx
// RENAMED from GameLibraryScreen.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  TextField,
  InputAdornment,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { PromptCard } from '../../models/index';
import Snackbar from '@mui/material/Snackbar';
import { useNavigate } from 'react-router-dom';


interface PromptCardLibraryScreenProps { // RENAMED interface
  onNavToggle: () => void;
  // onNavigateToEditor: (cardId?: string) => void; // To navigate to editor with a specific card
}

const PromptCardLibraryScreen: React.FC<PromptCardLibraryScreenProps> = ({ onNavToggle }) => { // RENAMED component
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const {
    promptCards,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    deletePromptCard,
  } = usePromptCardStore();
  const { initializeGame } = useGameStateStore();

  const [searchTerm, setSearchTerm] = useState('');
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info'>('info');


  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
    }
  }, [user?.uid, fetchPromptCards]);

  const filteredCards = promptCards.filter(card =>
    card.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  const handleEditCard = (card: PromptCard) => {
    setActivePromptCard(card);
    // Navigate to PromptCardManager/Editor screen
    navigate('/cards'); // Navigate to the PromptCardManager
    setSnackbarMessage(`Editing "${card.title}"`);
    setSnackbarSeverity('info');
    console.log(`Navigating to editor for card: ${card.id}`);
  };

  const handleDeleteCard = async (cardId: string) => {
    if (!user?.uid) return;
    try {
      await deletePromptCard(user.uid, cardId);
      setSnackbarMessage('Card deleted successfully!');
      setSnackbarSeverity('success');
    } catch (e) {
      setSnackbarMessage(`Failed to delete card: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };

  const handleStartGame = async (card: PromptCard) => {
    if (!user?.uid) {
      setSnackbarMessage('Must be logged in to start a game.');
      setSnackbarSeverity('error');
      return;
    }
    try {
      // First, set the active card, then initialize game
      setActivePromptCard(card);
      await initializeGame(user.uid, card.id);
      setSnackbarMessage(`Game "${card.title}" initialized! Navigating to game...`);
      setSnackbarSeverity('success');
      navigate('/game'); // Navigate to the GameScreen
      console.log(`Game "${card.title}" started! Navigating to GameScreen.`);
    } catch (e) {
      setSnackbarMessage(`Failed to start game: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };


  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Card Library...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Prompt Card Library
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {error && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {error}
        </Alert>
      )}

      <Box sx={{ p: 2 }}>
        <TextField
          fullWidth
          label="Search Cards"
          variant="outlined"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon />
              </InputAdornment>
            ),
          }}
          sx={{ mb: 2 }}
        />
      </Box>

      <Paper elevation={1} sx={{ flexGrow: 1, m: 2, overflowY: 'auto' }}>
        {filteredCards.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              {searchTerm ? "No cards match your search." : "No cards available. Go to Prompt Cards Manager to create one!"}
            </Typography>
            <Button variant="contained" startIcon={<AddIcon />} sx={{ mt: 2 }} onClick={() => navigate('/cards')}>
              Go to Prompt Card Manager
            </Button>
          </Box>
        ) : (
          <List>
            {filteredCards.map((card) => (
              <React.Fragment key={card.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="start-game" onClick={() => handleStartGame(card)}>
                        <PlayArrowIcon color="primary" />
                      </IconButton>
                      <IconButton edge="end" aria-label="edit-card" onClick={() => handleEditCard(card)}>
                        <EditIcon />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete-card" onClick={() => handleDeleteCard(card.id)}>
                        <DeleteIcon color="error" />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={card.title}
                    secondary={card.description || 'No description'}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>
      <Snackbar
        open={!!snackbarMessage}
        autoHideDuration={6000}
        onClose={() => setSnackbarMessage(null)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={() => setSnackbarMessage(null)} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardLibraryScreen;
@@FILE: src/ui/screens/GameLibraryScreen.tsx
// src/ui/screens/GameLibraryScreen.tsx
// NEW: This screen lists saved games (snapshots)

import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import DeleteIcon from '@mui/icons-material/Delete';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { gameRepository } from '../../data/repositories/gameRepository';
import { GameSnapshot } from '../../models/GameSnapshot';
import { useNavigate } from 'react-router-dom';
import Snackbar from '@mui/material/Snackbar';
import { formatIsoDateForDisplay } from '../../utils/formatDate';

interface GameLibraryScreenProps {
  onNavToggle: () => void;
}

const GameLibraryScreen: React.FC<GameLibraryScreenProps> = ({ onNavToggle }) => {
  const { user } = useAuthStore(); // Ensure user is available here
  const navigate = useNavigate();
  const { loadGame, gameLoading } = useGameStateStore();

  const [savedGames, setSavedGames] = useState<GameSnapshot[]>([]);
  const [loadingSavedGames, setLoadingSavedGames] = useState(true);
  const [savedGamesError, setSavedGamesError] = useState<string | null>(null);
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info' | 'warning'>('info');
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  const fetchSavedGames = async (userId: string) => {
    setLoadingSavedGames(true);
    setSavedGamesError(null);
    try {
      const games = await gameRepository.getAllGameSnapshots(userId);
      setSavedGames(games);
    } catch (e: any) {
      setSavedGamesError(e.message || 'Failed to fetch saved games.');
    } finally {
      setLoadingSavedGames(false);
    }
  };

  useEffect(() => {
    if (user?.uid) {
      fetchSavedGames(user.uid);
    }
  }, [user?.uid]);

  const showSnackbar = (
    message: string,
    severity: 'success' | 'error' | 'info' | 'warning' = 'info'
  ) => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };

  const handleSnackbarClose = (event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') {
      return;
    }
    setSnackbarOpen(false);
  };

  const handleLoadGame = async (snapshotId: string) => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to load a game.', 'error');
      return;
    }
    try {
      // MODIFIED: Pass user.uid as the first argument
      await loadGame(user.uid, snapshotId); 
      showSnackbar('Game loaded successfully! Navigating to game...', 'success');
      navigate('/game');
    } catch (e) {
      showSnackbar(
        `Failed to load game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  const handleDeleteGame = async (snapshotId: string) => {
    if (!user?.uid) return;
    try {
      await gameRepository.deleteGameSnapshot(user.uid, snapshotId);
      fetchSavedGames(user.uid);
      showSnackbar('Game deleted successfully!', 'success');
    } catch (e) {
      showSnackbar(
        `Failed to delete game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  if (loadingSavedGames || gameLoading) {
    return (
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh',
        }}
      >
        <CircularProgress />
        <Typography variant="h6" ml={2}>
          Loading Games...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" color="default" elevation={1}
        sx={{
          backgroundColor: (theme) => theme.palette.background.paper,
          color: (theme) => theme.palette.text.primary,
        }}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Game Library (Saved Games)
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {savedGamesError && (
        <Alert
          severity="error"
          sx={{
            m: 2,
            backgroundColor: (theme) => theme.palette.background.paper,
            color: (theme) => theme.palette.text.primary,
          }}
        >
          Error: {savedGamesError}
        </Alert>
      )}

      <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
        <Button
          variant="contained"
          color="primary"
          sx={{ mt: 2 }}
        >
          Start New Game (Select Prompt Card)
        </Button>
      </Box>

      <Paper
        elevation={1}
        sx={{
          flexGrow: 1,
          m: 2,
          overflowY: 'auto',
          backgroundColor: (theme) => theme.palette.background.paper,
        }}
      >
        {savedGames.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              No saved games found. Start a new one!
            </Typography>
          </Box>
        ) : (
          <List>
            {savedGames.map((game) => (
              <React.Fragment key={game.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton
                        edge="end"
                        aria-label="load-game"
                        onClick={() => handleLoadGame(game.id)}
                      >
                        <PlayArrowIcon sx={{ color: (theme) => theme.palette.primary.main }} />
                      </IconButton>
                      <IconButton
                        edge="end"
                        aria-label="delete-game"
                        onClick={() => handleDeleteGame(game.id)}
                      >
                        <DeleteIcon sx={{ color: (theme) => theme.palette.error.main }} />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={game.title}
                    secondary={`Turn: ${game.currentTurn} | Last Saved: ${formatIsoDateForDisplay(
                      game.updatedAt
                    )}`}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>

      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default GameLibraryScreen;

@@FILE: src/ui/screens/GameScreen.tsx
// src/ui/screens/GameScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, TextField, Paper, IconButton, CircularProgress,
  Dialog, DialogTitle, DialogContent, DialogActions, Snackbar, Alert, Tooltip,
} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import CasinoIcon from '@mui/icons-material/Casino';
import MenuIcon from '@mui/icons-material/Menu';
import { useGameScreenLogic } from '../../utils/hooks/useGameScreenLogic';
import { LogView } from '../components/LogView';
import { PinnedItemsView } from '../components/PinnedItemsView';

interface GameScreenProps {
  onNavToggle: () => void;
}

const GameScreen: React.FC<GameScreenProps> = ({ onNavToggle }) => {
  const {
    isReady,
    isLoading,
    isProcessingTurn,
    gameError,
    gameState,
    conversationHistory,
    narratorInputText,
    logContainerRef,
    snackbar,
    rollDialog,
    handleGoToLogin,
    handleSendAction,
    handleInputChange,
    handleKeyPress,
    handleRollDice,
    handleOpenRollDialog,
    handleCloseRollDialog,
    handleRollFormulaChange,
    closeSnackbar,
  } = useGameScreenLogic();

  // --- Render Logic ---

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Game...</Typography>
      </Box>
    );
  }

  if (!isReady) {
    return (
      <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
        <Typography variant="h6" color="error">Game Not Initialized</Typography>
        <Typography variant="body1" sx={{ my: 2 }}>
          There is no active game session. Please start a new game from the library.
        </Typography>
        <Button variant="contained" onClick={handleGoToLogin}>Go to Game Library</Button>
        {gameError && <Alert severity="error" sx={{ mt: 2 }}>{gameError}</Alert>}
      </Box>
    );
  }

  // The main game UI is rendered here, now that we know we are `isReady`
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2, position: 'relative' }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1, flexShrink: 0 }}>
        <Typography variant="h5" component="h1">Narrator</Typography>
        <IconButton onClick={onNavToggle} aria-label="menu"><MenuIcon /></IconButton>
      </Box>

      {/* Pinned Items View floats on top */}
      <Box sx={{ position: 'relative', zIndex: 10, flexShrink: 0 }}>
        <PinnedItemsView gameState={gameState} />
      </Box>

      {/* Log/Chat View */}
      <Paper ref={logContainerRef} elevation={1} sx={{ flexGrow: 1, mt: 1, p: 2, overflowY: 'auto' }}>
        <LogView conversationHistory={conversationHistory} />
      </Paper>

      {/* Input Field Section */}
      <Box sx={{ display: 'flex', mt: 2, gap: 1, flexShrink: 0 }}>
        <TextField
          fullWidth
          multiline
          maxRows={4}
          variant="outlined"
          placeholder="What do you do?"
          value={narratorInputText}
          onChange={(e) => handleInputChange(e.target.value)}
          onKeyPress={handleKeyPress}
          disabled={isProcessingTurn}
        />
        <Button
          variant="contained"
          onClick={handleSendAction}
          endIcon={<SendIcon />}
          disabled={isProcessingTurn || narratorInputText.trim() === ''}
          sx={{ height: 'fit-content', alignSelf: 'flex-end' }}
        >
          {isProcessingTurn ? <CircularProgress size={24} color="inherit" /> : 'Send'}
        </Button>
        <Tooltip title="Roll Dice (Right-click to change formula)">
          <IconButton
            color="primary"
            onClick={handleRollDice}
            onContextMenu={(e) => { e.preventDefault(); handleOpenRollDialog(); }}
            aria-label="roll dice"
            sx={{ height: 'fit-content', alignSelf: 'flex-end' }}
          >
            <CasinoIcon />
          </IconButton>
        </Tooltip>
      </Box>

      {/* Dice Roller Dialog */}
      <Dialog open={rollDialog.open} onClose={handleCloseRollDialog}>
        <DialogTitle>Dice Roll</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Dice Formula"
            type="text"
            fullWidth
            variant="standard"
            value={rollDialog.formula}
            onChange={(e) => handleRollFormulaChange(e.target.value)}
            helperText="e.g., 2d6, 1d20+5, 3d8-2"
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseRollDialog}>Cancel</Button>
          <Button onClick={handleRollDice}>Roll & Send</Button>
        </DialogActions>
      </Dialog>

      {/* Snackbar for feedback */}
      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={closeSnackbar}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default GameScreen;
@@FILE: src/ui/screens/LogViewerScreen.tsx
// src/ui/screens/LogViewerScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, AppBar, Toolbar, IconButton, Menu, MenuItem,
  Checkbox, FormControlLabel, Paper, CircularProgress, Alert,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { useLogViewerLogic } from '../../utils/hooks/useLogViewerLogic';
import { LogViewMode } from '../../utils/types';
import { CollapsibleLogEntry } from '../components/CollapsibleLogEntry';

interface LogViewerScreenProps {
  onNavToggle: () => void;
}

const LogViewerScreen: React.FC<LogViewerScreenProps> = ({ onNavToggle }) => {
  const {
    logEntries, selectedLogViewModes, isLoading, error,
    menuAnchorEl, isMenuOpen, handleMenuClick, handleMenuClose, handleCheckboxChange,
  } = useLogViewerLogic();

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress /> <Typography variant="h6" ml={2}>Loading Logs...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>Log Review</Typography>
          <Button color="inherit" onClick={handleMenuClick}>Log Views </Button>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}><MenuIcon /></IconButton>
        </Toolbar>
      </AppBar>

      <Menu anchorEl={menuAnchorEl} open={isMenuOpen} onClose={handleMenuClose}>
        {Object.values(LogViewMode).map((mode) => (
          <MenuItem key={mode} onClick={() => handleCheckboxChange(mode)}>
            <FormControlLabel
              control={<Checkbox checked={selectedLogViewModes.includes(mode)} />}
              label={mode}
              sx={{ pointerEvents: 'none' }} // Let the MenuItem handle the click
            />
          </MenuItem>
        ))}
      </Menu>

      {error && <Alert severity="error" sx={{ m: 2 }}>Error: {error}</Alert>}

      <Paper elevation={1} sx={{ flexGrow: 1, m: 2, overflowY: 'auto' }}>
        {logEntries.length === 0 ? (
          <Box sx={{ textAlign: 'center', p: 4 }}><Typography color="text.secondary">No log entries for this game yet.</Typography></Box>
        ) : (
          logEntries.map((entry) => (
            <CollapsibleLogEntry
              key={entry.turnNumber}
              entry={entry}
              selectedLogViewModes={selectedLogViewModes}
            />
          ))
        )}
      </Paper>
    </Box>
  );
};

export default LogViewerScreen;
@@FILE: src/ui/screens/LoginScreen.tsx
// src/ui/screens/LoginScreen.tsx

import React from 'react';
import { useAuthStore } from '../../state/useAuthStore'; // Import our Zustand auth store

const LoginScreen: React.FC = () => {
  // Destructure state and actions from the auth store
  const { user, isLoading, error, signIn, signOut } = useAuthStore();

  if (isLoading) {
    return (
      <div style={styles.container}>
        <h2>Loading Authentication Status...</h2>
      </div>
    );
  }

  if (user) {
    // User is logged in
    return (
      <div style={styles.container}>
        <h2>Welcome, {user.displayName || user.email}!</h2>
        <p>Your User ID: {user.uid}</p>
        <button onClick={signOut} style={styles.button}>
          Sign Out
        </button>
      </div>
    );
  } else {
    // No user logged in
    return (
      <div style={styles.container}>
        <h2>Please Log In to StoryForge</h2>
        {error && <p style={styles.errorText}>Error: {error}</p>}
        <button onClick={signIn} style={styles.button}>
          Sign in with Google
        </button>
      </div>
    );
  }
};

const styles: { [key: string]: React.CSSProperties } = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: '100vh', // Take full viewport height
    backgroundColor: '#f0f2f5',
    fontFamily: 'Arial, sans-serif',
    padding: '20px',
  },
  button: {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#4285F4', // Google blue
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    marginTop: '20px',
    transition: 'background-color 0.3s ease',
  },
  errorText: {
    color: 'red',
    marginTop: '10px',
  }
};

export default LoginScreen;
@@FILE: src/ui/screens/PromptCardEditor.tsx
// src/ui/screens/PromptCardEditor.tsx
import React from 'react';
import { Box, Divider, FormControlLabel, Switch } from '@mui/material';
import { PromptCard, AiConnection, StackInstructions, AiSettings } from '../../models/index';

// Import the existing modular editors
import { AiSettingsEditor } from '../components/AiSettingsEditor';
import { StackInstructionsEditor } from '../components/StackInstructionsEditor';
import { CollapsibleSection } from '../components/CollapsibleSection';
import { InfoDialog } from '../components/InfoDialog';

// Import the new decomposed parts
import { TitleAndDescriptionEditor } from '../components/promptCardEditorParts/TitleAndDescriptionEditor';
import { CorePromptEditor } from '../components/promptCardEditorParts/CorePromptEditor';
import { FirstTurnEditor } from '../components/promptCardEditorParts/FirstTurnEditor';
import { EmitSkeletonEditor } from '../components/promptCardEditorParts/EmitSkeletonEditor';
import { WorldStateInitEditor } from '../components/promptCardEditorParts/WorldStateInitEditor';
import { GameRulesEditor } from '../components/promptCardEditorParts/GameRulesEditor';
import { FunctionDefsEditor } from '../components/promptCardEditorParts/FunctionDefsEditor';
import { MetadataEditor } from '../components/promptCardEditorParts/MetadataEditor';


interface PromptCardEditorProps {
  card: PromptCard;
  onCardChange: (updatedCard: PromptCard) => void;
  availableConnections: AiConnection[];
}

const PromptCardEditor: React.FC<PromptCardEditorProps> = ({
  card,
  onCardChange,
  availableConnections,
}) => {
  // Create specific change handlers for children to call
  const handleFieldChange = (updates: Partial<PromptCard>) => {
    onCardChange({ ...card, ...updates });
  };

  return (
    <Box sx={{ p: 1, pb: 4 }}>
      <TitleAndDescriptionEditor
        title={card.title}
        description={card.description}
        onCardChange={(updates) => handleFieldChange(updates)}
      />

      <CorePromptEditor
        prompt={card.prompt}
        onPromptChange={(prompt) => handleFieldChange({ prompt })}
      />

      <FirstTurnEditor
        firstTurnOnlyBlock={card.firstTurnOnlyBlock}
        onFirstTurnChange={(firstTurnOnlyBlock) => handleFieldChange({ firstTurnOnlyBlock })}
      />

      <EmitSkeletonEditor
        emitSkeleton={card.emitSkeleton}
        onEmitSkeletonChange={(emitSkeleton) => handleFieldChange({ emitSkeleton })}
      />

      <WorldStateInitEditor
        worldStateInit={card.worldStateInit}
        onWorldStateInitChange={(worldStateInit) => handleFieldChange({ worldStateInit })}
      />

      <GameRulesEditor
        gameRules={card.gameRules}
        onGameRulesChange={(gameRules) => handleFieldChange({ gameRules })}
      />

      <AiSettingsEditor
        label="Primary AI Settings"
        settings={card.aiSettings}
        onSettingsChange={(aiSettings) => handleFieldChange({ aiSettings })}
        availableConnections={availableConnections}
      />

      <CollapsibleSection title="Helper AI Settings" initiallyExpanded={false}>
        <FormControlLabel
          control={
            <Switch
              checked={card.isHelperAiEnabled}
              onChange={(e) => handleFieldChange({ isHelperAiEnabled: e.target.checked })}
            />
          }
          label={<>Enable Helper AI <InfoDialog title="Enable Helper AI" content="Toggle to enable a secondary AI call for specific tasks."/></>}
          sx={{ mb: 2 }}
        />
        <Divider sx={{ mb: 2 }} />
        <Box sx={{ opacity: card.isHelperAiEnabled ? 1 : 0.5, pointerEvents: card.isHelperAiEnabled ? 'auto' : 'none' }}>
          <AiSettingsEditor
            label=""
            settings={card.helperAiSettings}
            onSettingsChange={(helperAiSettings) => handleFieldChange({ helperAiSettings })}
            availableConnections={availableConnections}
          />
        </Box>
      </CollapsibleSection>

      <FunctionDefsEditor
        functionDefs={card.functionDefs}
        onFunctionDefsChange={(functionDefs) => handleFieldChange({ functionDefs })}
      />

      <StackInstructionsEditor
        stackInstructions={card.stackInstructions}
        onStackInstructionsChange={(stackInstructions) => handleFieldChange({ stackInstructions })}
      />

      <MetadataEditor
        isPublic={card.isPublic}
        isExample={card.isExample}
        onCardChange={(updates) => handleFieldChange(updates)}
      />
    </Box>
  );
};

export default PromptCardEditor;
@@FILE: src/ui/screens/PromptCardManager.tsx
// src/ui/screens/PromptCardManager.tsx
import React from 'react';
import {
  Box,
  Typography,
  Button,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Snackbar,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import FileUploadIcon from '@mui/icons-material/FileUpload';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import { useAuthStore } from '../../state/useAuthStore';
import { usePromptCardManagerLogic } from '../../utils/hooks/usePromptCardManagerLogic';
import PromptCardEditor from './PromptCardEditor';
import { PromptCard } from '../../models';

interface PromptCardManagerProps {
  onNavToggle: () => void;
}

const PromptCardManager: React.FC<PromptCardManagerProps> = ({ onNavToggle }) => {
  const { user } = useAuthStore();
  const {
    isLoading,
    error,
    promptCards,
    activePromptCard,
    localEditedCard,
    isCardDirty,
    aiConnections,
    saveDialog,
    snackbar,
    handleCardSelect,
    handleLocalCardChange,
    handleSaveCard,
    handleRevert,
    handleNewCard,
    handleDeleteCard,
    handleDuplicateCard,
    handleImport,
    handleExport,
    handleStartGame,
    setSaveDialog,
    setSaveAsNewTitle,
    closeSnackbar,
  } = usePromptCardManagerLogic(user);

  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Cards...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h5" component="h1">
          Prompt Cards
        </Typography>
        <IconButton onClick={onNavToggle} aria-label="menu">
          <MenuIcon />
        </IconButton>
      </Box>

      <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
        <Button variant="contained" onClick={handleNewCard} startIcon={<AddIcon />}>
          New Card
        </Button>
        <Button variant="outlined" component="label" startIcon={<FileUploadIcon />}>
          Import Cards
          <input type="file" hidden accept=".json" onChange={handleImport} multiple/>
        </Button>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          Error: {error}
        </Alert>
      )}

      <Box sx={{ display: 'flex', flex: 1, overflow: 'hidden', gap: 2 }}>
        <Paper elevation={1} sx={{ flex: 1, minWidth: 250, maxWidth: 350, overflowY: 'auto' }}>
          <Typography variant="h6" sx={{ p: 2, pb: 1 }}>Your Cards</Typography>
          <Divider />
          <List>
            {promptCards.length === 0 ? (
              <ListItem><ListItemText primary="No cards yet. Create one!" sx={{ textAlign: 'center' }} /></ListItem>
            ) : (
              promptCards.map((card: PromptCard) => (
                <ListItem
                  key={card.id}
                  selected={activePromptCard?.id === card.id}
                  onClick={() => handleCardSelect(card)}
                  sx={{ py: 1, pr: 0, cursor: 'pointer', '&:hover': { backgroundColor: (theme) => theme.palette.action.hover } }}
                >
                  <ListItemText primary={card.title} secondary={card.description || 'No description'} primaryTypographyProps={{ noWrap: true }} secondaryTypographyProps={{ noWrap: true }} />
                  <IconButton edge="end" aria-label="duplicate" onClick={(e) => { e.stopPropagation(); handleDuplicateCard(card.id); }}><ContentCopyIcon fontSize="small" /></IconButton>
                  <IconButton edge="end" aria-label="delete" onClick={(e) => { e.stopPropagation(); handleDeleteCard(card.id); }}><DeleteIcon fontSize="small" color="error" /></IconButton>
                  <IconButton edge="end" aria-label="export" onClick={(e) => { e.stopPropagation(); handleExport(card.id); }}><FileDownloadIcon fontSize="small" /></IconButton>
                </ListItem>
              ))
            )}
          </List>
        </Paper>

        <Paper elevation={1} sx={{ flex: 2, minWidth: 400, overflowY: 'auto' }}>
          {!activePromptCard || !localEditedCard ? (
            <Box sx={{ textAlign: 'center', p: 4, mt: 4 }}>
              <Typography variant="h6" color="text.secondary">Select a card or create a new one to start editing.</Typography>
            </Box>
          ) : (
            <Box>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', p: 2, borderBottom: '1px solid', borderColor: 'divider', position: 'sticky', top: 0, backgroundColor: 'background.paper', zIndex: 1 }}>
                <Typography variant="h6" component="h2">{localEditedCard.title}</Typography>
                <Box sx={{ display: 'flex', gap: 1 }}>
                  {isCardDirty && (
                    <>
                      <Button variant="outlined" onClick={handleRevert}>Revert</Button>
                      <Button variant="contained" onClick={() => handleSaveCard(false)}>Save Changes</Button>
                    </>
                  )}
                  <Button variant="outlined" onClick={() => setSaveDialog(true)}>Save As...</Button>
                  <Button variant="contained" color="primary" onClick={handleStartGame} startIcon={<PlayArrowIcon />} disabled={isCardDirty}>
                    Start Game
                  </Button>
                </Box>
              </Box>
              <PromptCardEditor card={localEditedCard} onCardChange={handleLocalCardChange} availableConnections={aiConnections} />
            </Box>
          )}
        </Paper>
      </Box>

      <Dialog open={saveDialog.open} onClose={() => setSaveDialog(false)}>
        <DialogTitle>Save Prompt Card As New</DialogTitle>
        <DialogContent><TextField autoFocus margin="dense" label="New Card Title" type="text" fullWidth variant="outlined" value={saveDialog.title} onChange={(e) => setSaveAsNewTitle(e.target.value)} placeholder={`${localEditedCard?.title} (Copy)`} /></DialogContent>
        <DialogActions>
          <Button onClick={() => setSaveDialog(false)}>Cancel</Button>
          <Button onClick={() => handleSaveCard(true)}>Save</Button>
        </DialogActions>
      </Dialog>

      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={closeSnackbar} anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardManager;
@@FILE: src/ui/screens/SettingsScreen.tsx
// src/ui/screens/SettingsScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, AppBar, Toolbar, IconButton, List, ListItem, ListItemText,
  Paper, Divider, CircularProgress, Alert, TextField, Switch, FormControlLabel,
  Snackbar, Dialog, DialogTitle, DialogContent, DialogActions, ListItemButton,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import WifiIcon from '@mui/icons-material/Wifi';
import { useSettingsLogic } from '../../utils/hooks/useSettingsLogic';

interface SettingsScreenProps {
  onNavToggle: () => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onNavToggle }) => {
  const {
    aiConnections, selectedConnectionId, isLoadingConnections, connectionsError,
    useDummyNarrator, themeMode, setUseDummyNarrator, setThemeMode,
    isDialogOpen, editingConnection, testStatus, snackbar,
    handleOpenDialog, handleCloseDialog, handleUpdateEditingConnection,
    handleSave, handleDelete, handleTest, closeSnackbar, setSelectedConnectionId,
  } = useSettingsLogic();

  if (isLoadingConnections && aiConnections.length === 0) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress /> <Typography variant="h6" ml={2}>Loading Settings...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>Settings</Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}><MenuIcon /></IconButton>
        </Toolbar>
      </AppBar>

      {connectionsError && <Alert severity="error" sx={{ m: 2 }}>Error: {connectionsError}</Alert>}

      <Paper sx={{ mt: 2, p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
        <Typography variant="h6" gutterBottom>Application Settings</Typography>
        <FormControlLabel control={<Switch checked={useDummyNarrator} onChange={(e) => setUseDummyNarrator(e.target.checked)} />} label="Use Dummy Narrator (for testing)" />
        <Divider sx={{ my: 2 }} />
        <FormControlLabel control={<Switch checked={themeMode === 'dark'} onChange={(e) => setThemeMode(e.target.checked ? 'dark' : 'light')} />} label="Dark Mode" />
      </Paper>

      <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>AI Connections</Typography>
      <Paper elevation={1} sx={{ flexGrow: 1, overflowY: 'auto', mb: 2 }}>
        <List>
          {aiConnections.map((conn) => (
            <React.Fragment key={conn.id}>
              <ListItem
                disablePadding
                secondaryAction={
                  <Box>
                    <IconButton edge="end" aria-label="edit" onClick={() => handleOpenDialog(conn)}><EditIcon fontSize="small" /></IconButton>
                    <IconButton edge="end" aria-label="delete" onClick={() => handleDelete(conn.id)}><DeleteIcon fontSize="small" color="error" /></IconButton>
                  </Box>
                }
              >
                <ListItemButton selected={selectedConnectionId === conn.id} onClick={() => setSelectedConnectionId(conn.id)}>
                  <ListItemText primary={conn.displayName} secondary={`${conn.modelName} (${conn.apiUrl.substring(0, 30)}...)`} />
                </ListItemButton>
              </ListItem>
              <Divider />
            </React.Fragment>
          ))}
        </List>
      </Paper>

      <Button variant="contained" startIcon={<AddIcon />} onClick={() => handleOpenDialog(null)} sx={{ mb: 2 }}>Add New Connection</Button>

      {editingConnection && (
        <Dialog open={isDialogOpen} onClose={handleCloseDialog} fullWidth maxWidth="sm">
          <DialogTitle>{editingConnection.id ? 'Edit AI Connection' : 'Add New AI Connection'}</DialogTitle>
          <DialogContent>
            <TextField autoFocus margin="dense" label="Connection Name" type="text" fullWidth value={editingConnection.displayName} onChange={(e) => handleUpdateEditingConnection({ displayName: e.target.value })} sx={{ mb: 2 }} />
            <TextField margin="dense" label="API URL" type="url" fullWidth value={editingConnection.apiUrl} onChange={(e) => handleUpdateEditingConnection({ apiUrl: e.target.value })} sx={{ mb: 2 }} />
            <TextField margin="dense" label="API Token" type="password" fullWidth value={editingConnection.apiToken} onChange={(e) => handleUpdateEditingConnection({ apiToken: e.target.value })} sx={{ mb: 2 }} />
            <TextField margin="dense" label="Model Name (Display)" type="text" fullWidth value={editingConnection.modelName} onChange={(e) => handleUpdateEditingConnection({ modelName: e.target.value })} sx={{ mb: 2 }} />
            <TextField margin="dense" label="Model Slug (API ID)" type="text" fullWidth value={editingConnection.modelSlug} onChange={(e) => handleUpdateEditingConnection({ modelSlug: e.target.value })} sx={{ mb: 2 }} />
            <TextField margin="dense" label="User Agent (Optional)" type="text" fullWidth value={editingConnection.userAgent || ''} onChange={(e) => handleUpdateEditingConnection({ userAgent: e.target.value })} sx={{ mb: 2 }} />
            <FormControlLabel control={<Switch checked={editingConnection.functionCallingEnabled} onChange={(e) => handleUpdateEditingConnection({ functionCallingEnabled: e.target.checked })} />} label="Enable Function Calling" />
            <Box sx={{ mt: 2, display: 'flex', alignItems: 'center', gap: 1 }}>
              <Button variant="outlined" startIcon={<WifiIcon />} onClick={handleTest}>Test</Button>
              {testStatus && <Typography variant="body2">{testStatus}</Typography>}
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleCloseDialog}>Cancel</Button>
            <Button onClick={handleSave} variant="contained">Save</Button>
          </DialogActions>
        </Dialog>
      )}

      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={closeSnackbar} anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>{snackbar.message}</Alert>
      </Snackbar>
    </Box>
  );
};

export default SettingsScreen;
@@FILE: src/ui/screens/SourceDump.tsx
import React, { useEffect, useState } from 'react';

// Small reusable copy button
function CopyButton({ text }: { text: string }) {
  const [copied, setCopied] = useState(false);
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch (err) {
      console.error('Copy failed', err);
    }
  };
  return (
    <button
      onClick={handleCopy}
      style={{
        marginLeft: '6px',
        fontSize: '0.8rem',
        cursor: 'pointer',
        background: 'none',
        border: '1px solid #ccc',
        borderRadius: '4px',
        padding: '2px 5px',
      }}
    >
      {copied ? '' : ''}
    </button>
  );
}

function FolderView({
  name,
  node,
  level = 0,
}: {
  name: string;
  node: any;
  level?: number;
}) {
  const [open, setOpen] = useState(true);

  const isFolder = typeof node === 'object';
  if (!isFolder) return null;

  const folderIndent = { paddingLeft: `${level * 1.2}rem` };

  // Gather folder text for copy
  const folderText = node.__files
    ? node.__files.map((f: any) => f.content).join('\n')
    : '';

  return (
    <div style={{ ...folderIndent }}>
      <div
        style={{
          cursor: 'pointer',
          userSelect: 'none',
          fontWeight: 'bold',
        }}
        onClick={() => setOpen(!open)}
      >
        {open ? '' : ''} {name}
        {folderText && <CopyButton text={folderText} />}
      </div>

      {open && (
        <>
          {node.__files &&
            node.__files.map((file: any) => (
              <div key={file.name} style={{ paddingLeft: '1.5rem' }}>
                 {file.name}
                <CopyButton text={file.content} />
              </div>
            ))}
          {Object.entries(node)
            .filter(([k]) => k !== '__files')
            .map(([childName, childNode]) => (
              <FolderView
                key={childName}
                name={childName}
                node={childNode}
                level={level + 1}
              />
            ))}
        </>
      )}
    </div>
  );
}

export default function SourceDump() {
  const [dumpText, setDumpText] = useState('');
  const [tree, setTree] = useState<any>(null);

  useEffect(() => {
    fetch(`/source-dump.txt?_=${Date.now()}`)
      .then((res) => res.text())
      .then((text) => {
        setDumpText(text);
        setTree(parseDumpToTree(text));
      });
  }, []);

  if (!dumpText) return <div>Loading...</div>;

  return (
    <div style={{ padding: '1rem', fontFamily: 'monospace' }}>
      <h2>
         Copy Entire Repo
        <CopyButton text={dumpText} />
      </h2>

      {tree && <FolderView name="src" node={tree.src || tree} />}

      <hr style={{ margin: '2rem 0' }} />
      <h3>Full Dump:</h3>
      <pre
        style={{
          whiteSpace: 'pre-wrap',
          fontSize: '0.85rem',
          maxHeight: '400px',
          overflow: 'auto',
        }}
      >
        {dumpText}
      </pre>
    </div>
  );
}

function parseDumpToTree(dump: string) {
  const lines = dump.split('\n');
  const root: any = { __files: [] };;
  let currentFolder: string[] = [];
  let currentFile: { name: string; content: string } | null = null;

  const ensureFolder = (pathParts: string[]) => {
    let node = root;
    for (const part of pathParts) {
      if (!node[part]) node[part] = { __files: [] };
      node = node[part];
    }
    return node;
  };

  for (let line of lines) {
    if (line.startsWith('@@FOLDER:')) {
      const folderPath = line.replace('@@FOLDER: ', '').trim();
      currentFolder = folderPath.split('/').slice(1); // remove 'src'
      ensureFolder(currentFolder);
    } else if (line.startsWith('@@FILE:')) {
      const filePath = line.replace('@@FILE: ', '').trim();
      const parts = filePath.split('/');
      const fileName = parts.pop()!;
      currentFolder = parts.slice(1);
      const folderNode = ensureFolder(currentFolder);
      currentFile = { name: fileName, content: '' };
      folderNode.__files.push(currentFile);
    } else {
      if (currentFile) currentFile.content += line + '\n';
    }
  }

  return root;
}

@@FILE: src/ui/screens/WorldStateScreen.tsx
// src/ui/screens/WorldStateScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, AppBar, Toolbar, IconButton, Paper, CircularProgress,
  Alert, List, Collapse, Checkbox, TextField, Dialog, DialogTitle, DialogContent,
  DialogActions, Divider,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useWorldStateViewLogic } from '../../utils/hooks/useWorldStateViewLogic';
import { WorldStateItemRow } from '../components/WorldStateItemRow';

interface WorldStateScreenProps {
  onNavToggle: () => void;
}

const WorldStateScreen: React.FC<WorldStateScreenProps> = ({ onNavToggle }) => {
  const { currentGameState, gameLoading, gameError } = useGameStateStore();
  const {
    groupedByCategory,
    worldStatePinnedKeys,
    isAnyChildPinned,
    areAllChildrenPinned,
    expandedCategories,
    expandedEntities,
    editingCategory,
    newCategoryName,
    editingEntity,
    newEntityName,
    deleteWorldCategory,
    deleteWorldEntity,
    editWorldKeyValue,
    deleteWorldKey,
    toggleWorldStatePin,
    handleToggleCategoryExpand,
    handleToggleEntityExpand,
    handleToggleCategoryPin,
    handleToggleEntityPin,
    handleStartRenameCategory,
    handleConfirmRenameCategory,
    setNewCategoryName,
    handleStartRenameEntity,
    handleConfirmRenameEntity,
    setNewEntityName,
    cancelEdit,
  } = useWorldStateViewLogic(currentGameState);

  if (gameLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading World State...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>World State</Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}><MenuIcon /></IconButton>
        </Toolbar>
      </AppBar>

      {gameError && (<Alert severity="error" sx={{ m: 2 }}>Error: {gameError}</Alert>)}

      {Object.keys(groupedByCategory).length === 0 ? (
        <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
          <Typography variant="body1" color="text.secondary">No world state data available.</Typography>
        </Box>
      ) : (
        <Paper elevation={1} sx={{ flexGrow: 1, m: 2, p: 2, overflowY: 'auto' }}>
          {Object.entries(groupedByCategory).map(([category, entities]) => (
            <Box key={category} sx={{ mb: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', p: 1.5, cursor: 'pointer', backgroundColor: 'action.hover' }} onClick={() => handleToggleCategoryExpand(category)}>
                <IconButton size="small" sx={{ mr: 1 }}>{expandedCategories.has(category) ? <ExpandLessIcon /> : <ExpandMoreIcon />}</IconButton>
                <Typography variant="h6" sx={{ flexGrow: 1 }}>{category}</Typography>
                <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleStartRenameCategory(category); }}><EditIcon fontSize="small" /></IconButton>
                <Checkbox checked={areAllChildrenPinned(category)} indeterminate={isAnyChildPinned(category) && !areAllChildrenPinned(category)} onClick={(e) => { e.stopPropagation(); handleToggleCategoryPin(category); }} />
                <IconButton size="small" onClick={(e) => { e.stopPropagation(); deleteWorldCategory(category); }}><DeleteIcon fontSize="small" color="error" /></IconButton>
              </Box>
              <Collapse in={expandedCategories.has(category)}>
                <Divider />
                <List component="div" disablePadding sx={{ pl: 2 }}>
                  {Object.entries(entities).map(([entity, variables]) => {
                    const entityPath = `${category}.${entity}`;
                    if (entity === '@@_direct') {
                      return Object.entries(variables).map(([varName, value]) => (
                        <WorldStateItemRow key={`${category}.${varName}`} itemKey={`${category}.${varName}`} value={value} onDelete={deleteWorldKey} onEdit={editWorldKeyValue} isPinned={worldStatePinnedKeys.includes(`${category}.${varName}`)} onTogglePin={(key) => toggleWorldStatePin(key, 'variable')} />
                      ));
                    }
                    return (
                      <Box key={entity} sx={{ mb: 1, border: '1px dashed', borderColor: 'divider', borderRadius: 1, mt: 1 }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', p: 1, cursor: 'pointer' }} onClick={() => handleToggleEntityExpand(category, entity)}>
                          <IconButton size="small" sx={{ mr: 1 }}>{expandedEntities.has(entityPath) ? <ExpandLessIcon /> : <ExpandMoreIcon />}</IconButton>
                          <Typography variant="subtitle1" sx={{ flexGrow: 1 }}>{entity}</Typography>
                          <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleStartRenameEntity([category, entity]); }}><EditIcon fontSize="small" /></IconButton>
                          <Checkbox checked={areAllChildrenPinned(entityPath)} indeterminate={isAnyChildPinned(entityPath) && !areAllChildrenPinned(entityPath)} onClick={(e) => { e.stopPropagation(); handleToggleEntityPin(entityPath); }} />
                          <IconButton size="small" onClick={(e) => { e.stopPropagation(); deleteWorldEntity(category, entity); }}><DeleteIcon fontSize="small" color="error" /></IconButton>
                        </Box>
                        <Collapse in={expandedEntities.has(entityPath)}>
                          <Divider />
                          <Box sx={{ p: 1.5 }}>
                            {Object.entries(variables).map(([varName, value]) => (
                              <WorldStateItemRow key={varName} itemKey={`${entityPath}.${varName}`} value={value} onDelete={deleteWorldKey} onEdit={editWorldKeyValue} isPinned={worldStatePinnedKeys.includes(`${entityPath}.${varName}`)} onTogglePin={(key) => toggleWorldStatePin(key, 'variable')} />
                            ))}
                          </Box>
                        </Collapse>
                      </Box>
                    );
                  })}
                </List>
              </Collapse>
            </Box>
          ))}
        </Paper>
      )}

      <Dialog open={!!editingCategory} onClose={cancelEdit}>
        <DialogTitle>Rename Category</DialogTitle>
        <DialogContent><TextField autoFocus margin="dense" label="New Category Name" type="text" fullWidth variant="outlined" value={newCategoryName} onChange={(e) => setNewCategoryName(e.target.value)} /></DialogContent>
        <DialogActions><Button onClick={cancelEdit}>Cancel</Button><Button onClick={handleConfirmRenameCategory}>Rename</Button></DialogActions>
      </Dialog>

      <Dialog open={!!editingEntity} onClose={cancelEdit}>
        <DialogTitle>Rename Entity</DialogTitle>
        <DialogContent><TextField autoFocus margin="dense" label="New Entity Name" type="text" fullWidth variant="outlined" value={newEntityName} onChange={(e) => setNewEntityName(e.target.value)} /></DialogContent>
        <DialogActions><Button onClick={cancelEdit}>Cancel</Button><Button onClick={handleConfirmRenameEntity}>Rename</Button></DialogActions>
      </Dialog>
    </Box>
  );
};

export default WorldStateScreen;
@@FOLDER: src/utils
@@FILE: src/utils/diceRoller.ts
// src/utils/diceRoller.ts

/**
 * Represents the result of a dice roll.
 */
interface DiceRollResult {
  rolls: number[];
  sum: number;
  modifier: number;
  formula: string;
}

export const DiceRoller = {
  /**
   * Rolls dice based on a formula (e.g., "1d20", "2d6+3").
   * Supports basic NdN and optional +M or -M.
   * @param formula The dice rolling formula string.
   * @returns A DiceRollResult object.
   */
  roll: (formula: string): DiceRollResult => {
    const parts = formula.match(/^(\d*)d(\d+)([\+\-]\d+)?$/i);
    if (!parts) {
      throw new Error(`Invalid dice formula: ${formula}. Expected format: NdN[+M|-M]`);
    }

    const numDice = parseInt(parts[1] || '1', 10);
    const numSides = parseInt(parts[2], 10);
    const modifier = parts[3] ? parseInt(parts[3], 10) : 0;

    const rolls: number[] = [];
    let sum = 0;

    for (let i = 0; i < numDice; i++) {
      const roll = Math.floor(Math.random() * numSides) + 1;
      rolls.push(roll);
      sum += roll;
    }

    return {
      rolls,
      sum: sum + modifier,
      modifier,
      formula,
    };
  },

  /**
   * Formats a DiceRollResult into a human-readable string.
   * @param result The DiceRollResult to format.
   * @returns A formatted string (e.g., "Roll: 2d6 -> [3, 5] = 8").
   */
  format: (result: DiceRollResult): string => {
    let summary = `Roll: ${result.formula} -> [${result.rolls.join(', ')}]`;
    if (result.modifier !== 0) {
      summary += `${result.modifier >= 0 ? '+' : ''}${result.modifier}`;
    }
    summary += ` = ${result.sum}`;
    return summary;
  },
};
@@FILE: src/utils/formatDate.ts
// src/utils/formatDate.ts

/**
 * Formats an ISO 8601 date string into a more human-readable local date and time.
 * @param isoString The date string in ISO 8601 format (e.g., "2023-10-27T10:00:00Z").
 * @returns A formatted date string (e.g., "October 27, 2023, 10:00 AM").
 */
export function formatIsoDateForDisplay(isoString: string): string {
  try {
    const date = new Date(isoString);
    if (isNaN(date.getTime())) {
      // Invalid date string
      return "Invalid Date";
    }
    // Options for a readable format. Adjust as needed.
    const options: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: true, // Use 12-hour clock with AM/PM
    };
    return new Intl.DateTimeFormat(undefined, options).format(date);
  } catch (error) {
    console.error("Error formatting date:", error);
    return "Error formatting date";
  }
}

@@FILE: src/utils/hash.test.ts
// src/utils/hash.test.ts

import { generateContentHash, getPromptCardContentForHash } from './hash';
import { PromptCard, AiSettingsInCard, StackInstructions } from '../models/PromptCard';
import { defaultAiSettingsInCard, defaultStackInstructions, DEFAULT_FIRST_TURN_PROMPT_BLOCK, DEFAULT_EMIT_SKELETON_STRING } from '../data/config/promptCardDefaults';

describe('hash utilities', () => {

  // Test for generateContentHash
  it('generateContentHash should produce consistent hashes for the same input', () => {
    const str1 = 'Hello, world!';
    const str2 = 'Hello, world!';
    const str3 = 'Goodbye, world!';

    expect(generateContentHash(str1)).toBe(generateContentHash(str2));
    expect(generateContentHash(str1)).not.toBe(generateContentHash(str3));
  });

  it('generateContentHash should produce different hashes for inputs with different casing or whitespace', () => {
    const str1 = 'Test String';
    const str2 = 'test string';
    const str3 = 'TestString';
    const str4 = 'Test String ';

    expect(generateContentHash(str1)).not.toBe(generateContentHash(str2));
    expect(generateContentHash(str1)).not.toBe(generateContentHash(str3));
    expect(generateContentHash(str1)).not.toBe(generateContentHash(str4));
  });

  // Test for getPromptCardContentForHash
  it('getPromptCardContentForHash should produce consistent string for identical card content', () => {
    const card1: PromptCard = {
      id: '1', rootId: '1', parentId: null, contentHash: '', ownerId: 'user1', createdAt: 'iso', updatedAt: 'iso',
      title: 'Test Card',
      description: 'A simple card for testing.',
      prompt: 'This is the main prompt.',
      firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: defaultStackInstructions,
      emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: '',
      gameRules: 'No rules.',
      aiSettings: { ...defaultAiSettingsInCard, temperature: 0.8 },
      helperAiSettings: { ...defaultAiSettingsInCard, temperature: 0.9 },
      tags: ['tagA', 'tagB'],
      isExample: false,
      isPublic: false,
      functionDefs: '{}',
    };

    const card2: PromptCard = { ...card1 }; // Create a deep copy or equivalent content
    // Ensure that order of tags doesn't affect hash string
    const card3: PromptCard = { ...card1, tags: ['tagB', 'tagA'] };

    expect(getPromptCardContentForHash(card1)).toBe(getPromptCardContentForHash(card2));
    expect(getPromptCardContentForHash(card1)).toBe(getPromptCardContentForHash(card3)); // Tags should be sorted internally
  });

  it('getPromptCardContentForHash should produce different string for different card content', () => {
    const baseCard: PromptCard = {
      id: '1', rootId: '1', parentId: null, contentHash: '', ownerId: 'user1', createdAt: 'iso', updatedAt: 'iso',
      title: 'Test Card',
      description: 'A simple card for testing.',
      prompt: 'This is the main prompt.',
      firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: defaultStackInstructions,
      emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: '',
      gameRules: 'No rules.',
      aiSettings: { ...defaultAiSettingsInCard, temperature: 0.7 },
      helperAiSettings: { ...defaultAiSettingsInCard, temperature: 0.7 },
      tags: ['fantasy'],
      isExample: false,
      isPublic: false,
      functionDefs: '{}',
    };

    // Change title
    const changedTitle = { ...baseCard, title: 'New Title' };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedTitle));

    // Change prompt
    const changedPrompt = { ...baseCard, prompt: 'A new main prompt.' };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedPrompt));

    // Change description
    const changedDescription = { ...baseCard, description: 'Updated description.' };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedDescription));

    // Change AI settings
    const changedAiSettings = { ...baseCard, aiSettings: { ...baseCard.aiSettings, temperature: 0.9 } };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedAiSettings));

    // Change stack instructions (by object change)
    const changedStackInstructions = { ...baseCard, stackInstructions: { ...baseCard.stackInstructions, outputFormat: 'new_format' } };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedStackInstructions));

    // Change tags
    const changedTags = { ...baseCard, tags: ['scifi'] };
    expect(getPromptCardContentForHash(baseCard)).not.toBe(getPromptCardContentForHash(changedTags));
  });

  it('getPromptCardContentForHash should handle null/empty strings consistently', () => {
    const cardWithNulls: PromptCard = {
      id: '1', rootId: '1', parentId: null, contentHash: '', ownerId: 'user1', createdAt: 'iso', updatedAt: 'iso',
      title: 'Empty Card',
      description: null, // Null description
      prompt: '', // Empty prompt
      firstTurnOnlyBlock: '', // Empty first turn block
      stackInstructions: defaultStackInstructions,
      emitSkeleton: '',
      worldStateInit: '',
      gameRules: '',
      aiSettings: defaultAiSettingsInCard,
      helperAiSettings: defaultAiSettingsInCard,
      tags: [], // Empty tags array
      isExample: false,
      isPublic: false,
      functionDefs: '',
    };

    const cardWithEmptyStrings: PromptCard = {
      id: '2', rootId: '2', parentId: null, contentHash: '', ownerId: 'user1', createdAt: 'iso', updatedAt: 'iso',
      title: 'Empty Card',
      description: '', // Empty string description
      prompt: '',
      firstTurnOnlyBlock: '',
      stackInstructions: defaultStackInstructions,
      emitSkeleton: '',
      worldStateInit: '',
      gameRules: '',
      aiSettings: defaultAiSettingsInCard,
      helperAiSettings: defaultAiSettingsInCard,
      tags: [],
      isExample: false,
      isPublic: false,
      functionDefs: '',
    };

    // Should produce the same content hash string
    expect(getPromptCardContentForHash(cardWithNulls)).toBe(getPromptCardContentForHash(cardWithEmptyStrings));
  });
});
@@FILE: src/utils/hash.ts
// src/utils/hash.ts

import { PromptCard, AiSettingsInCard, StackInstructions } from '../models/PromptCard';
import { StackInstructions as StackInstructionsModel } from '../models/StackInstructions';


/**
 * Generates a simple, non-cryptographic hash from a string.
 * This is suitable for content deduplication checks within the application.
 *
 * Based on the 'sdbm' hash algorithm.
 * @param str The input string to hash.
 * @returns A string representation of the hash.
 */
export function generateContentHash(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = char + (hash << 6) + (hash << 16) - hash; // sdbm hash algorithm
  }
  // Convert to unsigned 32-bit integer and then to hex string
  return (hash >>> 0).toString(16);
}

/**
 * Creates a normalized string representation of key PromptCard content for hashing.
 * This function defines which fields are considered for deduplication.
 * It's important that this function is deterministic: the same input should always
 * produce the same output string.
 * @param card The PromptCard object (or partial object containing relevant fields).
 * @returns A string representing the key content of the card.
 */
export function getPromptCardContentForHash(card: {
  title: string;
  description: string | null;
  prompt: string;
  firstTurnOnlyBlock: string;
  stackInstructions: StackInstructions | string; // Can be object or string, needs to be stringified
  emitSkeleton: string;
  worldStateInit: string;
  gameRules: string;
  tags: string[];
  functionDefs: string;
  aiSettings: AiSettingsInCard; // Include AI settings in hash as they affect "content"
  helperAiSettings: AiSettingsInCard; // Include helper AI settings
}): string {
  // Use a consistent order and join method to ensure same content yields same hash
  // Sort tags for consistent hashing regardless of input order
  const sortedTags = [...(card.tags || [])].sort().join(',');

  // Stringify complex objects for consistent hashing.
  // We need to handle both the structured StackInstructions object and a potential raw JSON string input.
  const stackInstructionsString = typeof card.stackInstructions === 'object'
    ? JSON.stringify(card.stackInstructions)
    : (card.stackInstructions || '');

  // Stringify AI settings objects consistently
  const aiSettingsString = JSON.stringify(card.aiSettings);
  const helperAiSettingsString = JSON.stringify(card.helperAiSettings);

  // Concatenate all relevant content fields.
  // Order matters here for deterministic hashing.
  return [
    card.title,
    card.description || '', // Treat null as empty string for hashing
    card.prompt,
    card.firstTurnOnlyBlock,
    stackInstructionsString,
    card.emitSkeleton,
    card.worldStateInit,
    card.gameRules,
    aiSettingsString,
    helperAiSettingsString,
    sortedTags,
    card.functionDefs,
  ].join('|||'); // Use a distinctive separator to avoid accidental matches
}
@@FOLDER: src/utils/hooks
@@FILE: src/utils/hooks/useGameScreenLogic.ts
// src/utils/hooks/useGameScreenLogic.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { DiceRoller } from '../../utils/diceRoller';
import { GameState } from '../../models';

export const useGameScreenLogic = () => {
  const navigate = useNavigate();
  const { user } = useAuthStore();

  // 1. Consume the global state stores
  const {
    currentSnapshot,
    currentGameState,
    conversationHistory,
    narratorInputText,
    gameLoading,
    isProcessingTurn,
    gameError,
    processPlayerAction,
    updateNarratorInputText,
    processFirstNarratorTurn,
  } = useGameStateStore();

  // 2. All local UI state is moved here
  const [showRollDialog, setShowRollDialog] = useState(false);
  const [rollFormula, setRollFormula] = useState("2d6");
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' | 'info' | 'warning' }>({ open: false, message: '', severity: 'info' });

  // 3. All refs are moved here
  const logContainerRef = useRef<HTMLDivElement>(null);
  const initialTurnTriggeredForSnapshot = useRef<string | null>(null);

  // 4. All useEffects are moved here
  useEffect(() => {
    // Auto-scroll to the bottom of the log on new messages
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [conversationHistory]);

  useEffect(() => {
    // This effect intelligently triggers the AI's first turn response only once
    // when a new game is started (turn 0).
    if (!currentSnapshot || gameLoading) return;

    const needsFirstTurn =
      currentSnapshot.currentTurn === 0 &&
      currentSnapshot.conversationHistory?.length === 1 &&
      initialTurnTriggeredForSnapshot.current !== currentSnapshot.id;

    if (needsFirstTurn) {
      initialTurnTriggeredForSnapshot.current = currentSnapshot.id;
      console.log("GameScreenLogic: Detected start of Turn 0. Triggering narrator's first response.");
      processFirstNarratorTurn();
    }
  }, [currentSnapshot, gameLoading, processFirstNarratorTurn]);

  // 5. All handler functions are moved here and wrapped in useCallback
  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbar({ open: true, message, severity });
  }, []);

  const handleSendAction = useCallback(async () => {
    if (narratorInputText.trim() === '' || isProcessingTurn) return;
    try {
      await processPlayerAction(narratorInputText);
      // Success message is optional, as the UI updates with the AI response
    } catch (e) {
      showSnackbar(`Failed to process action: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  }, [narratorInputText, isProcessingTurn, processPlayerAction, showSnackbar]);

  const handleRollDice = useCallback(async () => {
    try {
      const result = DiceRoller.roll(rollFormula);
      const summary = DiceRoller.format(result);
      await processPlayerAction(`I roll the dice (${rollFormula}) and get the following result:\n${summary}`);
      showSnackbar(`Rolled ${rollFormula}: ${summary}`, 'success');
      setShowRollDialog(false);
    } catch (e) {
      showSnackbar(`Failed to roll dice: ${e instanceof Error ? e.message : 'Invalid formula'}`, 'error');
    }
  }, [rollFormula, processPlayerAction, showSnackbar]);

  const handleOpenRollDialog = useCallback(() => {
      setShowRollDialog(true);
  }, []);

  const handleKeyPress = useCallback((event: React.KeyboardEvent) => {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      handleSendAction();
    }
  }, [handleSendAction]);

  const closeSnackbar = useCallback(() => {
    setSnackbar(prev => ({ ...prev, open: false }));
  }, []);

  // 6. Return a clean API for the component
  return {
    // State and Data for Rendering
    isReady: !!user && !!currentSnapshot && !!currentGameState,
    isLoading: gameLoading,
    isProcessingTurn,
    gameError,
    gameState: currentGameState as GameState, // Assert non-null for the component
    conversationHistory,
    narratorInputText,
    logContainerRef,
    snackbar,

    // Dialog State
    rollDialog: {
      open: showRollDialog,
      formula: rollFormula,
    },

    // Handlers for UI Events
    handleGoToLogin: () => navigate('/login'),
    handleSendAction,
    handleInputChange: updateNarratorInputText,
    handleKeyPress,
    handleRollDice,
    handleOpenRollDialog,
    handleCloseRollDialog: () => setShowRollDialog(false),
    handleRollFormulaChange: setRollFormula,
    closeSnackbar,
  };
};
@@FILE: src/utils/hooks/useLogViewerLogic.ts
// src/utils/hooks/useLogViewerLogic.ts
import { useState, useEffect, useCallback } from 'react';
import { useLogStore } from '../../state/useLogStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { LogViewMode } from '../../utils/types';

export const useLogViewerLogic = () => {
  // 1. Consume global stores
  const { logEntries, selectedLogViewModes, isLoading, error, setLogEntries, setSelectedLogViewModes } = useLogStore();
  const { currentSnapshot } = useGameStateStore();

  // 2. Local UI state
  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
  const isMenuOpen = Boolean(menuAnchorEl);

  // 3. Data synchronization effect
  useEffect(() => {
    // When the game snapshot changes, update the logs in the log store
    setLogEntries(currentSnapshot?.logs || []);
  }, [currentSnapshot, setLogEntries]);

  // 4. Handlers
  const handleMenuClick = useCallback((event: React.MouseEvent<HTMLButtonElement>) => {
    setMenuAnchorEl(event.currentTarget);
  }, []);

  const handleMenuClose = useCallback(() => {
    setMenuAnchorEl(null);
  }, []);

  const handleCheckboxChange = useCallback((mode: LogViewMode) => {
    const newSelection = selectedLogViewModes.includes(mode)
      ? selectedLogViewModes.filter((m) => m !== mode)
      : [...selectedLogViewModes, mode];
    setSelectedLogViewModes(newSelection);
  }, [selectedLogViewModes, setSelectedLogViewModes]);

  // 5. Return Clean API
  return {
    logEntries,
    selectedLogViewModes,
    isLoading,
    error,
    menuAnchorEl,
    isMenuOpen,
    handleMenuClick,
    handleMenuClose,
    handleCheckboxChange,
  };
};
@@FILE: src/utils/hooks/useLongPress.ts
// src/utils/hooks/useLongPress.ts

import React, { useRef, useCallback } from 'react';

/**
 * Custom hook to detect long press events.
 * @param onLongPress The callback function to execute on long press.
 * @param onClick The callback function to execute on a regular click (optional).
 * @param options Configuration options for long press.
 * @param options.delay The duration in milliseconds for a press to be considered a long press (default: 500).
 */
export function useLongPress<T extends HTMLElement>(
  onLongPress: (event: React.MouseEvent<T> | React.TouchEvent<T>) => void,
  onClick?: (event: React.MouseEvent<T> | React.TouchEvent<T>) => void,
  { delay = 500 } = {}
) {
  const timeout = useRef<NodeJS.Timeout>();
  const target = useRef<T>();

  const start = useCallback(
    (event: React.MouseEvent<T> | React.TouchEvent<T>) => {
      // Stop the event from bubbling to parent elements
      event.stopPropagation();

      // Prevent context menu on long press on some browsers
      event.preventDefault();

      target.current = event.currentTarget as T;
      timeout.current = setTimeout(() => {
        onLongPress(event);
        target.current = undefined; // Clear target after long press
      }, delay);
    },
    [onLongPress, delay]
  );

  const clear = useCallback(
    (event: React.MouseEvent<T> | React.TouchEvent<T>, shouldClick = true) => {
      clearTimeout(timeout.current);
      if (shouldClick && onClick && target.current === event.currentTarget) {
        onClick(event);
      }
      target.current = undefined;
    },
    [onClick]
  );

  return {
    onMouseDown: start,
    onTouchStart: start,
    onMouseUp: (e: React.MouseEvent<T>) => clear(e),
    onMouseLeave: (e: React.MouseEvent<T>) => clear(e, false),
    onTouchEnd: (e: React.TouchEvent<T>) => clear(e),
    onTouchCancel: (e: React.TouchEvent<T>) => clear(e, false),
  };
}

@@FILE: src/utils/hooks/usePromptCardManagerLogic.ts
// src/utils/hooks/usePromptCardManagerLogic.ts
import { useState, useEffect, useCallback } from 'react';
import { User } from 'firebase/auth';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useSettingsStore } from '../../state/useSettingsStore';
import { PromptCard, NewPromptCardData } from '../../models';
import {
  defaultStackInstructions,
  defaultAiSettingsInCard,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../../data/config/promptCardDefaults';
import { useNavigate } from 'react-router-dom';

export const usePromptCardManagerLogic = (user: User | null) => {
  const navigate = useNavigate();

  // 1. All state and store hooks are moved here
  const {
    promptCards,
    activePromptCard,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    addPromptCard,
    updatePromptCard,
    duplicatePromptCard,
    deletePromptCard,
    importPromptCards,
    exportPromptCard,
  } = usePromptCardStore();

  const { initializeGame } = useGameStateStore();
  const { aiConnections, fetchAiConnections } = useSettingsStore();

  const [localEditedCard, setLocalEditedCard] = useState<PromptCard | null>(null);
  const [isCardDirty, setIsCardDirty] = useState(false);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [saveAsNewTitle, setSaveAsNewTitle] = useState('');
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' | 'info' | 'warning' }>({ open: false, message: '', severity: 'info' });

  // 2. All useEffects are moved here
  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
      fetchAiConnections(user.uid);
    }
  }, [user?.uid, fetchPromptCards, fetchAiConnections]);

  useEffect(() => {
    setLocalEditedCard(activePromptCard ? { ...activePromptCard } : null);
    setIsCardDirty(false);
  }, [activePromptCard]);

  // 3. All handler functions are moved here and wrapped in useCallback
  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbar({ open: true, message, severity });
  }, []);

  const handleCardSelect = useCallback((card: PromptCard) => {
    if (isCardDirty) {
      showSnackbar('Unsaved changes will be lost if you switch cards.', 'warning');
    }
    setActivePromptCard(card);
  }, [isCardDirty, setActivePromptCard, showSnackbar]);

  const handleLocalCardChange = useCallback((updatedCard: PromptCard) => {
    setLocalEditedCard(updatedCard);
    setIsCardDirty(JSON.stringify(updatedCard) !== JSON.stringify(activePromptCard));
  }, [activePromptCard]);

  const handleSaveCard = useCallback(async (saveAsNew: boolean = false) => {
    if (!user?.uid || !localEditedCard) return;

    try {
      let savedCard: PromptCard | null = null;
      if (saveAsNew) {
        const newCardData: NewPromptCardData = {
          ...localEditedCard,
          title: saveAsNewTitle || `${localEditedCard.title} (Copy)`,
        };
        savedCard = await addPromptCard(user.uid, newCardData);
      } else {
        savedCard = await updatePromptCard(user.uid, localEditedCard.id, localEditedCard);
      }

      if (savedCard) {
        setActivePromptCard(savedCard);
        showSnackbar('Card saved successfully!', 'success');
      }
    } catch (e) {
      showSnackbar(`Failed to save card: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    } finally {
      setShowSaveDialog(false);
      setSaveAsNewTitle('');
    }
  }, [user, localEditedCard, saveAsNewTitle, addPromptCard, updatePromptCard, setActivePromptCard, showSnackbar]);

  const handleRevert = useCallback(() => {
    if (activePromptCard) {
      setLocalEditedCard({ ...activePromptCard });
      setIsCardDirty(false);
      showSnackbar('Changes reverted.', 'info');
    }
  }, [activePromptCard, showSnackbar]);

  const handleNewCard = useCallback(async () => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to create a new card.', 'error');
      return;
    }
    const defaultConnectionId = aiConnections.length > 0 ? aiConnections[0].id : "";
    const newCardData: NewPromptCardData = {
      title: "New Prompt Card",
      prompt: "This is a new prompt card. Describe the setting and your character's starting situation.",
      description: null,
      firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: defaultStackInstructions,
      emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: '',
      gameRules: '',
      aiSettings: { ...defaultAiSettingsInCard, selectedConnectionId: defaultConnectionId },
      helperAiSettings: { ...defaultAiSettingsInCard, selectedConnectionId: defaultConnectionId },
      isHelperAiEnabled: false,
      tags: [],
      isExample: false,
      functionDefs: '',
      isPublic: false,
    };
    const createdCard = await addPromptCard(user.uid, newCardData);
    if (createdCard) {
      setActivePromptCard(createdCard);
      showSnackbar('New card created successfully!', 'success');
    }
  }, [user, aiConnections, addPromptCard, setActivePromptCard, showSnackbar]);

  const handleDeleteCard = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    await deletePromptCard(user.uid, cardId);
    showSnackbar('Card deleted successfully!', 'success');
  }, [user, deletePromptCard, showSnackbar]);

  const handleDuplicateCard = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    const duplicated = await duplicatePromptCard(user.uid, cardId);
    if (duplicated) {
      showSnackbar('Card duplicated successfully!', 'success');
    }
  }, [user, duplicatePromptCard, showSnackbar]);

  const handleImport = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !user?.uid) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const content = e.target?.result as string;
        const parsed = JSON.parse(content) as NewPromptCardData | NewPromptCardData[];
        const cardsToImport = Array.isArray(parsed) ? parsed : [parsed];
        await importPromptCards(user.uid, cardsToImport);
        showSnackbar(`Successfully imported ${cardsToImport.length} cards!`, 'success');
      } catch (err) {
        showSnackbar(`Failed to import cards: ${err instanceof Error ? err.message : 'Invalid JSON'}`, 'error');
      }
    };
    reader.readAsText(file);
    event.target.value = ''; // Reset file input
  }, [user, importPromptCards, showSnackbar]);

  const handleExport = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    const card = await exportPromptCard(user.uid, cardId);
    if (card) {
      const json = JSON.stringify(card, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `prompt_card_${card.title.replace(/\s/g, '_')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showSnackbar(`Card "${card.title}" exported.`, 'success');
    }
  }, [user, exportPromptCard, showSnackbar]);

  const handleStartGame = useCallback(async () => {
    if (!user?.uid || !activePromptCard) return;
    if (isCardDirty) {
      showSnackbar('Please save changes before starting a game.', 'warning');
      return;
    }
    await initializeGame(user.uid, activePromptCard.id);
    navigate('/game');
  }, [user, activePromptCard, isCardDirty, initializeGame, navigate, showSnackbar]);

  // 4. Return a clean API for the component
  return {
    // State for Rendering
    isLoading,
    error,
    promptCards,
    activePromptCard,
    localEditedCard,
    isCardDirty,
    aiConnections,
    saveDialog: {
      open: showSaveDialog,
      title: saveAsNewTitle
    },
    snackbar,

    // Functions for Event Handlers
    handleCardSelect,
    handleLocalCardChange,
    handleSaveCard,
    handleRevert,
    handleNewCard,
    handleDeleteCard,
    handleDuplicateCard,
    handleImport,
    handleExport,
    handleStartGame,
    setSaveDialog: setShowSaveDialog,
    setSaveAsNewTitle,
    closeSnackbar: () => setSnackbar(prev => ({ ...prev, open: false })),
  };
};
@@FILE: src/utils/hooks/useSettingsLogic.ts
// src/utils/hooks/useSettingsLogic.ts
import { useState, useEffect, useCallback } from 'react';
import { useAuthStore } from '../../state/useAuthStore';
import { useSettingsStore } from '../../state/useSettingsStore';
import { AiConnection } from '../../models/AiConnection';
import { aiClient } from '../../logic/aiClient';

export const useSettingsLogic = () => {
  const { user } = useAuthStore();
  const settingsStore = useSettingsStore();

  // 1. Local UI State
  const [editingConnection, setEditingConnection] = useState<AiConnection | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [testStatus, setTestStatus] = useState<string | null>(null);
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' | 'info' | 'warning' }>({ open: false, message: '', severity: 'info' });

  // 2. Data Fetching Effect
  useEffect(() => {
    if (user?.uid) {
      settingsStore.fetchAiConnections(user.uid);
    }
  }, [user?.uid, settingsStore.fetchAiConnections]);

  // 3. Handlers and Callbacks
  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbar({ open: true, message, severity });
  }, []);

  const handleOpenDialog = useCallback((connection: AiConnection | null) => {
    setTestStatus(null);
    if (connection) {
      // Editing existing connection
      setEditingConnection({ ...connection });
    } else {
      // Adding a new connection
      setEditingConnection({
        id: '', // Will be generated in the store action
        displayName: '',
        apiUrl: '',
        apiToken: '',
        modelName: '',
        modelSlug: '',
        functionCallingEnabled: false,
        userAgent: 'StoryForge/1.0 (Web)',
        createdAt: '',
        lastUpdated: '',
      });
    }
    setIsDialogOpen(true);
  }, []);

  const handleCloseDialog = useCallback(() => {
    setIsDialogOpen(false);
    setEditingConnection(null);
  }, []);

  const handleUpdateEditingConnection = useCallback((updates: Partial<AiConnection>) => {
    if (editingConnection) {
      setEditingConnection(prev => ({ ...prev!, ...updates }));
    }
  }, [editingConnection]);

  const handleSave = useCallback(async () => {
    if (!user?.uid || !editingConnection) return;
    try {
      if (editingConnection.id) {
        await settingsStore.updateAiConnection(user.uid, editingConnection);
        showSnackbar('Connection updated successfully!', 'success');
      } else {
        await settingsStore.addAiConnection(user.uid, editingConnection);
        showSnackbar('Connection added successfully!', 'success');
      }
      handleCloseDialog();
    } catch (e) {
      showSnackbar(`Failed to save connection: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  }, [user, editingConnection, settingsStore, showSnackbar, handleCloseDialog]);

  const handleDelete = useCallback(async (connectionId: string) => {
    if (!user?.uid) return;
    await settingsStore.deleteAiConnection(user.uid, connectionId);
    showSnackbar('Connection deleted successfully!', 'success');
  }, [user, settingsStore, showSnackbar]);

  const handleTest = useCallback(async () => {
    if (!editingConnection) return;
    setTestStatus('Testing...');
    const success = await aiClient.testConnection(editingConnection);
    if (success) {
      setTestStatus(' Success!');
    } else {
      setTestStatus(' Failed. Check URL, Token, and Model Slug.');
    }
  }, [editingConnection]);

  const closeSnackbar = useCallback(() => {
    setSnackbar(prev => ({ ...prev, open: false }));
  }, []);


  // 4. Return Clean API
  return {
    // Global State from Store
    ...settingsStore,

    // Local UI State
    isDialogOpen,
    editingConnection,
    testStatus,
    snackbar,

    // Handlers
    handleOpenDialog,
    handleCloseDialog,
    handleUpdateEditingConnection,
    handleSave,
    handleDelete,
    handleTest,
    closeSnackbar,
  };
};
@@FILE: src/utils/hooks/useWorldStateViewLogic.ts
// src/utils/hooks/useWorldStateViewLogic.ts
import { useState, useMemo, useCallback } from 'react';
import { useGameStateStore } from '../../state/useGameStateStore';
import { flattenJsonObject, getNestedValue } from '../../utils/jsonUtils';
import { GameState } from '../../models';

interface GroupedWorldState {
    [category: string]: {
        [entity: string]: {
            [variable: string]: any;
        };
    };
}

export const useWorldStateViewLogic = (gameState: GameState | null) => {
    // 1. Get the global state actions we need from the store
    const {
        worldStatePinnedKeys,
        toggleWorldStatePin,
        renameWorldCategory,
        renameWorldEntity,
        deleteWorldCategory,
        deleteWorldEntity,
        editWorldKeyValue,
        deleteWorldKey,
    } = useGameStateStore();

    // 2. Move all local UI state here
    const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());
    const [expandedEntities, setExpandedEntities] = useState<Set<string>>(new Set());
    const [editingCategory, setEditingCategory] = useState<string | null>(null);
    const [newCategoryName, setNewCategoryName] = useState('');
    const [editingEntity, setEditingEntity] = useState<[string, string] | null>(null);
    const [newEntityName, setNewEntityName] = useState('');

    // 3. Move all memoized calculations here
    const worldState = gameState?.worldState || {};
    const flattenedWorld = useMemo(() => flattenJsonObject(worldState), [worldState]);

    const groupedByCategory = useMemo(() => {
        const grouped: GroupedWorldState = {};
        for (const fullKey in flattenedWorld) {
            const value = flattenedWorld[fullKey];
            const parts = fullKey.split(".");
            if (parts.length < 1) continue;

            const category = parts[0];
            const entity = (parts.length > 1 && (parts[1].startsWith('#') || parts[1].startsWith('@') || parts[1].startsWith('$'))) ? parts[1] : '@@_direct';
            const variable = (entity === '@@_direct') ? parts.slice(1).join('.') : parts.slice(2).join('.');
            if (!variable) continue;

            grouped[category] = grouped[category] || {};
            grouped[category][entity] = grouped[category][entity] || {};
            grouped[category][entity][variable] = value;
        }
        for (const category in grouped) {
            if (Object.keys(grouped[category]['@@_direct'] || {}).length === 0) {
                delete grouped[category]['@@_direct'];
            }
        }
        return grouped;
    }, [flattenedWorld]);

    const getAllChildVariableKeys = useCallback((basePath: string): string[] => {
        const nestedData = getNestedValue(worldState, basePath.split('.'));
        if (typeof nestedData !== 'object' || nestedData === null) return [];
        return Object.keys(flattenJsonObject(nestedData, basePath));
    }, [worldState]);

    const isAnyChildPinned = useCallback((parentPath: string) => {
        return getAllChildVariableKeys(parentPath).some(key => worldStatePinnedKeys.includes(key));
    }, [getAllChildVariableKeys, worldStatePinnedKeys]);

    const areAllChildrenPinned = useCallback((parentPath: string) => {
        const childKeys = getAllChildVariableKeys(parentPath);
        return childKeys.length > 0 && childKeys.every(key => worldStatePinnedKeys.includes(key));
    }, [getAllChildVariableKeys, worldStatePinnedKeys]);

    // 4. Move all callback handlers here
    const handleToggleCategoryExpand = useCallback((category: string) => {
        setExpandedCategories(prev => {
            const newSet = new Set(prev);
            newSet.has(category) ? newSet.delete(category) : newSet.add(category);
            return newSet;
        });
    }, []);

    const handleToggleEntityExpand = useCallback((category: string, entity: string) => {
        const key = `${category}.${entity}`;
        setExpandedEntities(prev => {
            const newSet = new Set(prev);
            newSet.has(key) ? newSet.delete(key) : newSet.add(key);
            return newSet;
        });
    }, []);

    const handleToggleCategoryPin = useCallback((category: string) => {
        toggleWorldStatePin(category, 'category');
    }, [toggleWorldStatePin]);

    const handleToggleEntityPin = useCallback((entityPath: string) => {
        toggleWorldStatePin(entityPath, 'entity');
    }, [toggleWorldStatePin]);

    const handleConfirmRenameCategory = useCallback(async () => {
        if (editingCategory && newCategoryName.trim() && newCategoryName !== editingCategory) {
            await renameWorldCategory(editingCategory, newCategoryName);
        }
        setEditingCategory(null);
    }, [editingCategory, newCategoryName, renameWorldCategory]);

    const handleConfirmRenameEntity = useCallback(async () => {
        if (editingEntity && newEntityName.trim() && newEntityName !== editingEntity[1]) {
            await renameWorldEntity(editingEntity[0], editingEntity[1], newEntityName);
        }
        setEditingEntity(null);
    }, [editingEntity, newEntityName, renameWorldEntity]);


    // 5. Return the clean API
    return {
        // Derived Data
        groupedByCategory,
        worldStatePinnedKeys,
        isAnyChildPinned,
        areAllChildrenPinned,

        // UI State
        expandedCategories,
        expandedEntities,
        editingCategory,
        newCategoryName,
        editingEntity,
        newEntityName,

        // Handlers from Store
        renameWorldEntity,
        deleteWorldCategory,
        deleteWorldEntity,
        editWorldKeyValue,
        deleteWorldKey,
        toggleWorldStatePin,

        // Local UI Handlers
        handleToggleCategoryExpand,
        handleToggleEntityExpand,
        handleToggleCategoryPin,
        handleToggleEntityPin,
        handleStartRenameCategory: setEditingCategory,
        handleConfirmRenameCategory,
        setNewCategoryName,
        handleStartRenameEntity: setEditingEntity,
        handleConfirmRenameEntity,
        setNewEntityName,
        cancelEdit: () => {
          setEditingCategory(null);
          setEditingEntity(null);
        },
    };
};
@@FILE: src/utils/jsonUtils.ts
// src/utils/jsonUtils.ts

import { JsonPrimitive } from '@mui/material'; // Assuming this is for example, JsonPrimitive isn't from MUI

/**
 * Flattens a nested JSON object into a single-level map with dot-separated keys.
 * @param obj The JSON object to flatten.
 * @param prefix The prefix for the current level (used in recursion).
 * @returns A map where keys are dot-separated paths and values are primitives or arrays/objects at the leaf.
 */
export function flattenJsonObject(obj: Record<string, any>, prefix: string = ""): Record<string, any> {
  const result: Record<string, any> = {};

  for (const k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      const fullKey = prefix ? `${prefix}.${k}` : k;
      const value = obj[k];

      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        Object.assign(result, flattenJsonObject(value, fullKey));
      } else {
        result[fullKey] = value;
      }
    }
  }
  return result;
}

/**
 * Attempts to parse a string into a JSON primitive (string, number, boolean, null).
 * This is a simplified version of the Android `parseJsonPrimitive` and may need robustness.
 * @param text The string to parse.
 * @returns The parsed JSON primitive or the original string if no better match.
 */
export function parseJsonPrimitive(text: string): any {
  const trimmed = text.trim();

  if (trimmed.toLowerCase() === 'true') return true;
  if (trimmed.toLowerCase() === 'false') return false;
  if (trimmed === 'null') return null;

  const num = Number(trimmed);
  if (!isNaN(num) && isFinite(num)) {
    return num;
  }

  // If it's a string that looks like a string (quoted), remove quotes
  if (trimmed.startsWith('"') && trimmed.endsWith('"') && trimmed.length >= 2) {
    return trimmed.substring(1, trimmed.length - 1);
  }

  // Fallback: if string doesn't parse cleanly, treat as raw string
  return trimmed;
}

/**
 * Safely retrieves a nested value from an object using a dot-separated path.
 * @param obj The object to traverse.
 * @param pathParts An array of strings representing the path.
 * @returns The value at the specified path, or undefined if not found.
 */
export function getNestedValue(obj: Record<string, any>, pathParts: string[]): any {
  let current: any = obj;
  for (const part of pathParts) {
    if (typeof current !== 'object' || current === null || !(part in current)) {
      return undefined;
    }
    current = current[part];
  }
  return current;
}
@@FILE: src/utils/types.ts
// src/utils/types.ts

export enum LogViewMode {
  NARRATOR_OUTPUT = 'Narrator Output',
  USER_INPUT = 'User Input',
  DIGEST_LINES = 'Digest Lines',
  DELTAS = 'Deltas',
  CONTEXT_SNAPSHOT = 'Context Snapshot',
  TOKEN_USAGE = 'Token Usage',
  AI_SETTINGS = 'AI Settings',
  API_DETAILS = 'API Details',
  ERROR_FLAGS = 'Error Flags',
  MODEL_SLUG_USED = 'Model Slug Used'
}
@@FILE: src/utils/uuid.ts
// src/utils/uuid.ts

import { v4 as uuidv4 } from 'uuid';

/**
 * Generates a new unique UUID (Universally Unique Identifier).
 * @returns A string representation of a UUID v4.
 */
export function generateUuid(): string {
  return uuidv4();
}
@@FILE: src/vite-env.d.ts
/// <reference types="vite/client" />

