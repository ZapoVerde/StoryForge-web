@@FILE: src/App.css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

@@FILE: src/App.tsx
// src/App.tsx
import React, { useEffect, useRef } from 'react';
import { BrowserRouter as Router } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import { useSettingsStore } from './state/useSettingsStore';
import { getAppTheme } from './theme';
import MainLayout from './ui/components/MainLayout';
import { AppRoutes } from './AppRoutes';
import { useAuthStore } from './state/useAuthStore';
import { useGameStateStore } from './state/useGameStateStore';
import { usePromptCardStore } from './state/usePromptCardStore';
import { useLogStore } from './state/useLogStore';
import { debugLog } from './utils/debug';

const App: React.FC = () => {
  // DEBUG: Log App component renders
  debugLog('%c[App.tsx] App component rendering', 'color: purple; font-weight: bold;');


  const { themeMode } = useSettingsStore();
  const theme = React.useMemo(() => getAppTheme(themeMode), [themeMode]);

  const { user } = useAuthStore();
  const wasUserLoggedIn = useRef(!!user);

  useEffect(() => {
    // DEBUG: Log App component useEffect execution
    debugLog('[App.tsx] App component useEffect fired. User:', user ? user.uid : 'null');

    const isLoggingOut = wasUserLoggedIn.current && !user;

    if (isLoggingOut) {
      debugLog("[App.tsx] User is logging out. Resetting all data stores.");
      useGameStateStore.getState().reset();
      usePromptCardStore.getState().reset();
      useSettingsStore.getState().reset();
      useLogStore.getState().reset();
    }
    
    // Update the ref for the next render
    wasUserLoggedIn.current = !!user;
  }, [user]);

  return (
    <ThemeProvider theme={theme}>
      <Router>
        <MainLayout>
          <AppRoutes />
        </MainLayout>
      </Router>
    </ThemeProvider>
  );
};

export default App;
@@FILE: src/AppRoutes.tsx
// src/AppRoutes.tsx
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import ProtectedRoute from './ui/components/ProtectedRoute';
import AuthOrchestrator from './ui/components/AuthOrchestrator';
import LoginScreen from './ui/screens/LoginScreen';
import GameLibraryScreen from './ui/screens/GameLibraryScreen';
import PromptCardManager from './ui/screens/PromptCardManager';
import GameScreen from './ui/screens/GameScreen';
import WorldStateScreen from './ui/screens/WorldStateScreen';
import LogViewerScreen from './ui/screens/LogViewerScreen';
import SettingsScreen from './ui/screens/SettingsScreen';
import SourceDump from './ui/screens/SourceDump';
import type { JSX } from 'react';

// A simple wrapper to protect routes that need an active game.
const GameActiveRoute: React.FC<{ children: JSX.Element }> = ({ children }) => {
    const { currentSnapshot } = useGameStateStore();
    if (!currentSnapshot) {
        return <Navigate to="/library" replace />;
    }
    return children;
};

import { useGameStateStore } from './state/useGameStateStore';

export const AppRoutes = () => {
  return (
    <Routes>
      {/* Public Routes */}
      <Route path="/login" element={<LoginScreen />} />
      <Route path="/sourcedump" element={<SourceDump />} />

      {/* Authenticated Routes Layout */}
      <Route
        element={
          <ProtectedRoute>
            <AuthOrchestrator />
          </ProtectedRoute>
        }
      >
        {/* These routes render inside AuthOrchestrator's <Outlet /> */}
        <Route path="/library" element={<GameLibraryScreen />} />
        <Route path="/cards" element={<PromptCardManager />} />
        <Route path="/settings" element={<SettingsScreen />} />
        <Route path="/game" element={<GameActiveRoute><GameScreen /></GameActiveRoute>} />
        <Route path="/world-state" element={<GameActiveRoute><WorldStateScreen /></GameActiveRoute>} />
        <Route path="/logs" element={<GameActiveRoute><LogViewerScreen /></GameActiveRoute>} />

        {/* Default authenticated route */}
        <Route path="/" element={<Navigate to="/library" replace />} />
      </Route>

      {/* Catch-all for any unhandled paths */}
      <Route path="*" element={<Navigate to="/login" replace />} />
    </Routes>
  );
};
@@FOLDER: src/assets
@@FILE: src/assets/react.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
@@FOLDER: src/config
@@FILE: src/config/navigation.tsx
// src/config/navigation.ts
import LibraryBooksIcon from '@mui/icons-material/LibraryBooks';
import StyleIcon from '@mui/icons-material/Style';
import SettingsIcon from '@mui/icons-material/Settings';
import TravelExploreIcon from '@mui/icons-material/TravelExplore';
import HistoryIcon from '@mui/icons-material/History';
import DataObjectIcon from '@mui/icons-material/DataObject';
import CodeIcon from '@mui/icons-material/Code';
import type {  GameSnapshot } from '../models';
/**
 * Generates the navigation items array.
 * @param currentSnapshot - The current game snapshot, used to determine if game-specific links should be enabled.
 * @returns An array of navigation item objects.
 */
export const getNavItems = (currentSnapshot: GameSnapshot | null) => [
  { text: 'Game Library', icon: <LibraryBooksIcon />, path: '/library', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Prompt Cards', icon: <StyleIcon />, path: '/cards', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Settings', icon: <SettingsIcon />, path: '/settings', requiresAuth: true, requiresGame: false, disabled: false },
  { text: 'Current Game', icon: <TravelExploreIcon />, path: '/game', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'World State', icon: <DataObjectIcon />, path: '/world-state', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'Log Viewer', icon: <HistoryIcon />, path: '/logs', requiresAuth: true, requiresGame: true, disabled: !currentSnapshot },
  { text: 'Source Dump', icon: <CodeIcon />, path: '/sourcedump', requiresAuth: false, requiresGame: false, disabled: false },
];
@@FOLDER: src/contexts
@@FILE: src/contexts/GameSessionContext.tsx
// src/contexts/GameSessionContext.tsx

import React, { createContext, useContext } from 'react';
import type { IGameSession } from '../logic/gameSession';

// Define the context to hold the IGameSession instance
const GameSessionContext = createContext<IGameSession | undefined>(undefined);

// Provider component to wrap the application and provide the gameSession
export const GameSessionProvider: React.FC<{ children: React.ReactNode; gameSession: IGameSession }> = ({ children, gameSession }) => {
  return (
    <GameSessionContext.Provider value={gameSession}>
      {children}
    </GameSessionContext.Provider>
  );
};

// Custom hook to easily consume the gameSession from the context by React components
export const useGameSession = () => {
  const context = useContext(GameSessionContext);
  if (context === undefined) {
    throw new Error('useGameSession must be used within a GameSessionProvider');
  }
  return context;
};
@@FILE: src/contexts/LayoutContext.tsx
// src/contexts/LayoutContext.tsx
import React, { createContext, useContext, useState } from 'react';

interface LayoutContextType {
  toggleDrawer: () => void;
}

const LayoutContext = createContext<LayoutContextType | undefined>(undefined);

export const useLayout = () => {
  const context = useContext(LayoutContext);
  if (!context) {
    throw new Error('useLayout must be used within a LayoutProvider');
  }
  return context;
};

export const LayoutProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mobileOpen, setMobileOpen] = useState(false);
  const toggleDrawer = () => setMobileOpen(!mobileOpen);

  const value = { toggleDrawer, mobileOpen }; // Provide mobileOpen as well if needed by MainLayout

  // The actual provider component will be part of MainLayout to have access to state
  // This file just defines the context and hook. The implementation will be in MainLayout.
  // This is a common pattern to avoid circular dependencies.
  // For this refactor, we will define the Provider logic directly within MainLayout.
  return (
    <LayoutContext.Provider value={{ toggleDrawer }}>
      {children}
    </LayoutContext.Provider>
  );
};
@@FOLDER: src/data
@@FOLDER: src/data/config
@@FILE: src/data/config/aiConnectionTemplates.ts
// src/data/config/aiConnectionTemplates.ts
import type { AiConnection } from '../../models';
export interface ModelInfo {
  id: string; // The API identifier, e.g., "gpt-4-turbo"
  name: string; // The human-readable name, e.g., "GPT-4 Turbo"
  description?: string; // NEW: A description for the tooltip/dialog
}

export interface AiConnectionTemplate extends Omit<AiConnection, 'id' | 'createdAt' | 'lastUpdated'> {
  supportsModelDiscovery: boolean;
  commonModels: ModelInfo[];
}

// Using a Record for easier lookup by key
export const aiConnectionTemplates: Record<string, AiConnectionTemplate> = {
  openai: {
    displayName: 'OpenAI',
    modelName: 'GPT-4o',
    modelSlug: 'gpt-4o',
    apiUrl: 'https://api.openai.com/v1/',
    apiToken: 'PASTE_YOUR_OPENAI_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
      { id: 'gpt-4o', name: 'GPT-4o', description: 'The latest and most advanced model from OpenAI. Excellent reasoning, multimodal capabilities.' },
      { id: 'gpt-4-turbo', name: 'GPT-4 Turbo', description: 'A powerful and fast version of GPT-4, optimized for performance.' },
      { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo', description: 'A highly capable and cost-effective model, great for general purpose tasks.' },
    ],
  },
  google: {
    displayName: 'Google',
    modelName: 'Gemini 1.5 Flash',
    modelSlug: 'gemini-1.5-flash-latest',
    apiUrl: 'https://generativelanguage.googleapis.com/v1beta/',
    apiToken: 'PASTE_YOUR_GOOGLE_AI_STUDIO_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: false, // Google's API needs a different endpoint for model listing
    commonModels: [
      { id: 'gemini-1.5-pro-latest', name: 'Gemini 1.5 Pro', description: 'Google\'s top-tier multimodal model with a massive context window.' },
      { id: 'gemini-1.5-flash-latest', name: 'Gemini 1.5 Flash', description: 'A lightweight, fast, and cost-efficient version of Gemini 1.5.' },
      { id: 'gemini-1.0-pro', name: 'Gemini 1.0 Pro', description: 'The original balanced model for scaled tasks.' },
    ],
  },
  deepseek: {
    displayName: 'DeepSeek',
    modelName: 'DeepSeek Coder V2',
    modelSlug: 'deepseek-coder-v2',
    apiUrl: 'https://api.deepseek.com/v1/',
    apiToken: 'PASTE_YOUR_DEEPSEEK_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
        { id: 'deepseek-chat', name: 'DeepSeek Chat', description: 'Specialized in general conversation and creative text generation.' },
        { id: 'deepseek-coder', name: 'DeepSeek Coder', description: 'Specialized in code generation and explanation. A very capable model.' },
    ],
  },
  openrouter: {
    displayName: 'OpenRouter',
    modelName: 'OpenRouter (Auto)',
    modelSlug: 'openrouter/auto',
    apiUrl: 'https://openrouter.ai/api/v1/',
    apiToken: 'PASTE_YOUR_OPENROUTER_KEY_HERE',
    functionCallingEnabled: true,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: true,
    commonModels: [
        { id: 'openrouter/auto', name: 'Auto (Best)', description: 'OpenRouter automatically selects the best model for your prompt based on price and performance.' },
        { id: 'google/gemini-flash-1.5', name: 'Google: Gemini Flash 1.5', description: 'Fast and affordable model, good for quick tasks.' },
        { id: 'openai/gpt-4o', name: 'OpenAI: GPT-4o', description: 'Access GPT-4o through OpenRouter\'s API.' },
        { id: 'mistralai/mistral-large', name: 'Mistral Large', description: 'High-quality model from Mistral AI, strong reasoning.' },
    ],
  },
  custom: {
    displayName: 'Custom',
    modelName: 'Custom Model',
    modelSlug: '',
    apiUrl: '',
    apiToken: '',
    functionCallingEnabled: false,
    userAgent: 'StoryForge/1.0',
    supportsModelDiscovery: false,
    commonModels: [],
  },
};
@@FILE: src/data/config/promptCardDefaults.ts
// src/data/config/promptCardDefaults.ts

// In src/data/config/promptCardDefaults.ts
import type { AiSettings, StackInstructions} from '../../models';
import  { StackMode, FilterMode} from '../../models';
import { debugLog, errorLog } from '../../utils/debug';

/**
 * Default AI settings to be used for PromptCards if not specified.
 * Corresponds to AiSettings.kt's default values, now embedded in PromptCard.
 */
export const defaultAiSettingsInCard: AiSettings = {
  selectedConnectionId: "",
  temperature: 0.7,
  topP: 1.0,
  maxTokens: 2048,
  presencePenalty: 0.0,
  frequencyPenalty: 0.0,
  functionCallingEnabled: false,
  streaming: true, 
};

/**
 * Default structured StackInstructions object.
 * This is the parsed object version of the default JSON string from PromptCardDefaults.kt.
 */
export const defaultStackInstructions: StackInstructions = {
  narratorProseEmission: { mode: StackMode.FIRST_N, n: 3, filtering: FilterMode.SCENE_ONLY, enabled: true },
  digestPolicy: { filtering: FilterMode.TAGGED, enabled: true },
  digestEmission: {
    "5": { mode: StackMode.ALWAYS, n: 0 }, // MODIFIED: Added n: 0
    "4": { mode: StackMode.AFTER_N, n: 1 },
    "3": { mode: StackMode.FIRST_N, n: 6 },
    "2": { mode: StackMode.FIRST_N, n: 3 },
    "1": { mode: StackMode.NEVER, n: 0 }, // MODIFIED: Added n: 0
  },
  expressionLogPolicy: { mode: StackMode.ALWAYS, n: 0, filtering: FilterMode.SCENE_ONLY, enabled: true },
  expressionLinesPerCharacter: 3,
  emotionWeighting: true,
  worldStatePolicy: { mode: StackMode.FILTERED, n: 0, filtering: FilterMode.SCENE_ONLY, enabled: true },
  knownEntitiesPolicy: { mode: StackMode.FIRST_N, n: 2, filtering: FilterMode.TAGGED, enabled: true },
  // REMOVED: "outputFormat": "prose_digest_emit",
  tokenPolicy: {
    minTokens: 1000,
    maxTokens: 4096,
    fallbackPlan: [
      "drop_known_entities",
      "drop_low_importance_digest",
      "truncate_expression_logs",
    ],
  },
};

/**
 * Default content for the 'firstTurnOnlyBlock' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_FIRST_TURN_PROMPT_BLOCK: string = `The camera pans down. It's your first time in this place.
Describe the scene and how the world feels from the character's perspective.`;

/**
 * Default content for the 'emitSkeleton' field of a PromptCard.
 * From PromptCardDefaults.kt.
 */
export const DEFAULT_EMIT_SKELETON_STRING: string = `
### Narrator Output Structure

**IMPORTANT:** Your response MUST follow this exact structure. Each section MUST be separated by the specified markers on their own lines.

1.  **Narrative Prose:**
    *   Begin with clear, immersive narration in freeform prose.
    *   This is the only section that should contain descriptive text. It MUST NOT contain any markers or JSON blocks.

2.  **Summary Digest Block (\`@digest\`):**
    *   After the prose, you MUST include a single newline, followed by the marker \`@digest\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing an array of 1-5 summary lines.
    *   Each line MUST have an importance score from 1 (minor) to 5 (critical).

3.  **Emit Block (\`@delta\`):**
    *   After the digest block, include a single newline, followed by the marker \`@delta\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block containing key-value deltas for the world state.

4.  **Scene Change Block (\`@scene\`, Optional):
    *   If the scene has shifted, include a single newline, followed by the marker \`@scene\` on its own line.
    *   Immediately after the marker, provide a \`\`\`json\`\`\` block with the new scene object.

---

### **MANDATORY OUTPUT FORMAT EXAMPLE**

This is not optional. Your output must match this structure precisely.

The mist curls like spectral fingers around the ancient oaks. #Lyrielle stands rigid, her silver-threaded cloak shimmering faintly in the moonlight. You feel a sudden chill as #Brom shifts his weight, his leather armor creaking.

@digest
\`\`\`json
[
  { "text": "#Lyrielle appears tense and wary.", "importance": 3 },
  { "text": "The mist in @MoonlitVale thickens, obscuring the path.", "importance": 2 }
]
\`\`\`

@delta
\`\`\`json
{
  "=npcs.#lyrielle.status": "wary",
  "+world.environment.fog_density": 0.1
}
\`\`\`

@scene
\`\`\`json
{
  "location": "@MoonlitVale",
  "present": ["#you", "#lyrielle", "#brom"],
  "weather": "foggy"
}
\`\`\`
---

### Emit & Tagging Rules

*   **Emit Rules:** Paths are \`category.entity.field\`. Use symbolic ops: \`+\`, \`=\`, \`!\`, \`-\`. Paths must be valid.
*   **Tagging Rules:** Use \`#\` for characters, \`@\` for locations, \`$\` for items. Use tags consistently in narration and emits.

`.trim();
@@FOLDER: src/data/infrastructure
@@FILE: src/data/infrastructure/firebaseClient.ts
// src/data/infrastructure/firebaseClient.ts

import { initializeApp, getApps, getApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore'; // Removed initializeFirestore and PersistentLocalCache

// Your Firebase configuration
function getEnvVar(name: string): string {
  const value = import.meta.env[name] as string | undefined;
  if (!value) {
    throw new Error(`Missing required environment variable: ${name}`);
  }
  return value;
}

const firebaseConfig = {
  apiKey: getEnvVar('VITE_FIREBASE_API_KEY'),
  authDomain: getEnvVar('VITE_FIREBASE_AUTH_DOMAIN'),
  projectId: getEnvVar('VITE_FIREBASE_PROJECT_ID'),
  storageBucket: getEnvVar('VITE_FIREBASE_STORAGE_BUCKET'),
  messagingSenderId: getEnvVar('VITE_FIREBASE_MESSAGING_SENDER_ID'),
  appId: getEnvVar('VITE_FIREBASE_APP_ID'),
};

// Initialize Firebase App
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

// Get Firebase services (without offline persistence for MVP)
export const auth = getAuth(app);
export const db = getFirestore(app);
@@FOLDER: src/data/repositories
@@FILE: src/data/repositories/authRepository.ts
// src/data/authRepository.ts

import {
  GoogleAuthProvider,
  signInWithPopup,
  signOut,
  onAuthStateChanged,
  type User,
} from 'firebase/auth';
import { auth } from '../infrastructure/firebaseClient'; // Import the auth instance from our firebaseClient

/**
 * Handles user login using Google as the authentication provider.
 * @returns A Promise that resolves with the Firebase User credential if successful, or rejects with an error.
 */
export async function signInWithGoogle(): Promise<User | null> {
  const provider = new GoogleAuthProvider();
  try {
    const result = await signInWithPopup(auth, provider);
    // The signed-in user info.
    const user = result.user;
    console.log("User logged in:", user.uid);
    return user;
  } catch (error: any) {
    // Handle Errors here.
    const errorCode = error.code;
    const errorMessage = error.message;
    // The email of the user's account used.
    const email = error.customData?.email;
    // The AuthCredential type that was used.
    const credential = GoogleAuthProvider.credentialFromError(error);
    console.error("Error signing in with Google:", errorCode, errorMessage, email, credential);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Handles user logout.
 * @returns A Promise that resolves when the user is successfully signed out.
 */
export async function signOutUser(): Promise<void> {
  try {
    await signOut(auth);
    console.log("User signed out.");
  } catch (error) {
    console.error("Error signing out:", error);
    throw error; // Re-throw the error for the UI to handle
  }
}

/**
 * Subscribes to authentication state changes.
 * This is crucial for keeping the UI updated about the current user's login status.
 * @param callback A function to call when the auth state changes, receiving the current Firebase User or null.
 * @returns An unsubscribe function that can be called to stop listening for changes.
 */
export function subscribeToAuthChanges(callback: (user: User | null) => void): () => void {
  // onAuthStateChanged returns an unsubscribe function
  const unsubscribe = onAuthStateChanged(auth, (user) => {
    callback(user);
  });
  console.log("Auth state change listener attached.");
  return unsubscribe;
}

// Optional: You could also add a way to get the current user synchronously if needed,
// though `subscribeToAuthChanges` is generally preferred for reactivity.
export function getCurrentUser(): User | null {
  return auth.currentUser;
}
@@FILE: src/data/repositories/gameRepository.ts
// src/data/repositories/gameRepository.ts

import {
  collection,
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  query,
  getDocs,
  serverTimestamp,
  orderBy,
  Timestamp, // Import Timestamp type
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient';
import { generateUuid } from '../../utils/uuid'; // Import generateUuid
import type { AiConnection, GameSnapshot } from '../../models';
/**
 * Defines the contract for GameSnapshot and AiConnection data persistence operations.
 */
export interface IGameRepository {
  /**
   * Saves a new or updates an existing GameSnapshot.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshot The GameSnapshot object to save.
   * @returns A Promise that resolves when the snapshot is successfully saved.
   */
  saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void>;

  /**
   * Retrieves a single GameSnapshot by its ID for a specific user.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshotId The ID of the GameSnapshot to retrieve.
   * @returns A Promise that resolves with the GameSnapshot object or null if not found.
   */
  getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null>;

  /**
   * Retrieves all GameSnapshots for a specific user, ordered by updatedAt descending.
   * @param userId The ID of the user owning the snapshots.
   * @returns A Promise that resolves with an array of GameSnapshot objects.
   */
  getAllGameSnapshots(userId: string): Promise<GameSnapshot[]>;

  /**
   * Deletes a GameSnapshot by its ID for a specific user.
   * @param userId The ID of the user owning the snapshot.
   * @param snapshotId The ID of the GameSnapshot to delete.
   * @returns A Promise that resolves when the snapshot is successfully deleted.
   */
  deleteGameSnapshot(userId: string, snapshotId: string): Promise<void>;

  /**
   * Retrieves all AI Connections for a user.
   * @param userId The ID of the user.
   * @returns A Promise resolving with an array of AiConnection objects.
   */
  getAiConnections(userId: string): Promise<AiConnection[]>;

  /**
   * Saves a new or updates an existing AI Connection.
   * @param userId The ID of the user.
   * @param connection The AiConnection object to save.
   * @returns A Promise that resolves when the connection is successfully saved.
   */
  saveAiConnection(userId: string, connection: AiConnection): Promise<void>;

  /**
   * Deletes an AI Connection by its ID for a specific user.
   * @param userId The ID of the user.
   * @param connectionId The ID of the AiConnection to delete.
   * @returns A Promise that resolves when the connection is successfully deleted.
   */
  deleteAiConnection(userId: string, connectionId: string): Promise<void>;
}

/**
 * Concrete implementation of IGameRepository using Firestore.
 */
class FirestoreGameRepository implements IGameRepository {

  private getSnapshotsCollectionRef(userId: string) {
    // Path: users/{userId}/gameSnapshots
    return collection(db, 'users', userId, 'gameSnapshots');
  }

  private getAiConnectionsCollectionRef(userId: string) {
    // Path: users/{userId}/aiConnections
    return collection(db, 'users', userId, 'aiConnections');
  }

  // Helper to convert Firestore Timestamp to ISO string
  private convertTimestamps<T extends { createdAt?: any; updatedAt?: any; lastUpdated?: any }>(data: any): T {
    const convertedData: any = { ...data };

    if (data.createdAt && data.createdAt instanceof Timestamp) {
      convertedData.createdAt = data.createdAt.toDate().toISOString();
    }
    if (data.updatedAt && data.updatedAt instanceof Timestamp) {
      convertedData.updatedAt = data.updatedAt.toDate().toISOString();
    }
    // This is the specific field causing the error. 
    // Only convert it if it exists on the source object.
    if (data.lastUpdated && data.lastUpdated instanceof Timestamp) {
      convertedData.lastUpdated = data.lastUpdated.toDate().toISOString();
    }
    
    return convertedData as T;
  }

  async saveGameSnapshot(userId: string, snapshot: GameSnapshot): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshot.id);
    console.log(`FirestoreGameRepository: Attempting to setDoc for GameSnapshot ${snapshot.id} for user ${userId}.`);
    try {
      await setDoc(snapshotDocRef, {
        // Pass all snapshot data, including the new 'title'
        ...snapshot,
        updatedAt: serverTimestamp() // Always update timestamp on save
      }, { merge: true });
      console.log(`FirestoreGameRepository: Successfully setDoc for GameSnapshot ${snapshot.id}.`);
    } catch (e) {
      console.error(`FirestoreGameRepository: FAILED to setDoc for GameSnapshot ${snapshot.id}:`, e);
      throw e; // Re-throw the error for GameSession to catch
    }
  }

  async getGameSnapshot(userId: string, snapshotId: string): Promise<GameSnapshot | null> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    const snapshotSnap = await getDoc(snapshotDocRef);

    if (snapshotSnap.exists()) {
      const data = snapshotSnap.data();
      // Ensure title is retrieved
      return this.convertTimestamps<GameSnapshot>(data) as GameSnapshot;
    } else {
      console.log(`No GameSnapshot found with ID: ${snapshotId} for user ${userId}`);
      return null;
    }
  }

  async getAllGameSnapshots(userId: string): Promise<GameSnapshot[]> {
    const q = query(
      this.getSnapshotsCollectionRef(userId),
      orderBy('updatedAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    const snapshots: GameSnapshot[] = [];
    querySnapshot.forEach((doc) => {
      // Ensure title is retrieved
      snapshots.push(this.convertTimestamps<GameSnapshot>(doc.data()) as GameSnapshot);
    });
    return snapshots;
  }

  async deleteGameSnapshot(userId: string, snapshotId: string): Promise<void> {
    const snapshotDocRef = doc(this.getSnapshotsCollectionRef(userId), snapshotId);
    await deleteDoc(snapshotDocRef);
    console.log(`GameSnapshot ${snapshotId} deleted for user ${userId}`);
  }

  async getAiConnections(userId: string): Promise<AiConnection[]> {
    const q = query(
      this.getAiConnectionsCollectionRef(userId),
      orderBy('displayName', 'asc') // Order by display name
    );
    const querySnapshot = await getDocs(q);
    const connections: AiConnection[] = [];
    querySnapshot.forEach((docSnap) => {
      // Ensure the ID from the document is used
      connections.push(this.convertTimestamps<AiConnection>(docSnap.data()));
    });

    // Provide a default DeepSeek connection if no connections exist for the user.
    // This allows immediate testing without requiring users to manually add one.
    if (connections.length === 0) {
      console.log("No AI connections found, returning default.");
      return [
        {
          id: generateUuid(), // Use a generated UUID for the default
          displayName: 'DeepSeek Coder (Default)', // Added displayName
          modelName: 'DeepSeek Coder (Default)',
          modelSlug: 'deepseek-coder',
          apiUrl: 'https://api.deepseek.com/v1/',
          apiToken: 'YOUR_DEEPSEEK_API_KEY_HERE', // User should be able to edit this
          functionCallingEnabled: false, // Default value
          createdAt: new Date().toISOString(),
          lastUpdated: new Date().toISOString(),
          userAgent: 'StoryForge/1.0 (Default)'
        },
      ];
    }
    return connections;
  }

  async saveAiConnection(userId: string, connection: AiConnection): Promise<void> {
    const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connection.id);
    await setDoc(connectionDocRef, {
      ...connection,
      createdAt: connection.createdAt || serverTimestamp(), // Set createdAt only on initial creation
      lastUpdated: serverTimestamp(), // Always update lastUpdated
    }, { merge: true });
    console.log(`AI Connection ${connection.id} saved for user ${userId}`);
  }

  async deleteAiConnection(userId: string, connectionId: string): Promise<void> {
    const connectionDocRef = doc(this.getAiConnectionsCollectionRef(userId), connectionId);
    await deleteDoc(connectionDocRef);
    console.log(`AI Connection ${connectionId} deleted for user ${userId}`);
  }
}

// Export a singleton instance of the repository.
export const gameRepository = new FirestoreGameRepository();


@@FILE: src/data/repositories/promptCardRepository.ts
// src/data/repositories/promptCardRepository.ts

import {
  collection,
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  query,
  getDocs,
  serverTimestamp,
  orderBy
} from 'firebase/firestore';
import { db } from '../infrastructure/firebaseClient'; // Import our Firestore instance
import type { PromptCard } from '../../models';
import { toIsoStringIfTimestamp } from '../../utils/formatDate';

/**
 * Defines the contract for PromptCard data persistence operations.
 * This interface can be implemented by different concrete repositories
 * (e.g., FirestorePromptCardRepository, MockPromptCardRepository)
 * to allow for easy swapping of data sources.
 */
export interface IPromptCardRepository {
  /**
   * Saves a new or updates an existing PromptCard.
   * If the card already has an ID, it will update the existing document.
   * If not, it assumes the card object passed already has an ID generated (e.g., by cardManager).
   * @param userId The ID of the user owning the card.
   * @param card The PromptCard object to save.
   * @returns A Promise that resolves when the card is successfully saved.
   */
  savePromptCard(userId: string, card: PromptCard): Promise<void>;

  /**
   * Retrieves a single PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to retrieve.
   * @returns A Promise that resolves with the PromptCard object or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a specific user, ordered by updatedAt descending.
   * @param userId The ID of the user owning the cards.
   * @returns A Promise that resolves with an array of PromptCard objects.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Deletes a PromptCard by its ID for a specific user.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the PromptCard to delete.
   * @returns A Promise that resolves when the card is successfully deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Imports a collection of PromptCards. This method will likely involve
   * generating new IDs/hashes and setting ownerId upon import.
   * The actual logic for generating IDs/hashes and setting ownerId should be in cardManager.ts,
   * this repository method merely handles the bulk persistence.
   * @param userId The ID of the user importing the cards.
   * @param cards The array of PromptCard objects to import.
   * @returns A Promise that resolves when all cards are imported.
   */
  importPromptCards(userId: string, cards: PromptCard[]): Promise<void>;
}

/**
 * Concrete implementation of IPromptCardRepository using Firestore.
 */
export class FirestorePromptCardRepository implements IPromptCardRepository {

  private getCollectionRef(userId: string) {
    // Path: users/{userId}/promptCards
    return collection(db, 'users', userId, 'promptCards');
  }

  async savePromptCard(userId: string, card: PromptCard): Promise<void> {
    if (!card.id) {
      // This case should ideally be prevented by logic in cardManager or wherever cards are created
      // as PromptCard should always have an ID before reaching the repository.
      throw new Error("PromptCard must have an ID to be saved.");
    }
    const cardDocRef = doc(this.getCollectionRef(userId), card.id);
    await setDoc(cardDocRef, {
      ...card,
      updatedAt: serverTimestamp() // Firestore special value for server timestamp
    }, { merge: true }); // Use merge: true to update existing fields and add new ones without overwriting entire doc
    // Note: createdAt should only be set on initial creation, not on every update.
    // We'll manage createdAt in cardManager.ts before passing to repository.
    console.log(`PromptCard ${card.id} saved for user ${userId}`);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    const cardSnap = await getDoc(cardDocRef);

    if (cardSnap.exists()) {
      // Firestore `data()` method returns `any`. We cast it to PromptCard.
      // Note: serverTimestamp() will be an object like { seconds: ..., nanoseconds: ... }
      // when retrieved, not an ISO string. We might need a conversion layer if UI strictly expects ISO string.
      // However, Firestore handles this transparently for objects if saving back.
      // For display, formatIsoDateForDisplay will handle it correctly if it's Date or Timestamp object.
      const data = cardSnap.data() as PromptCard;

      // Firestore's serverTimestamp() retrieves as a Timestamp object.
      // To ensure our PromptCard interface holds string (ISO 8601), we convert it here.
      // This is a common pattern: store one way, retrieve/convert to match app's type.
      return {
        ...data,
        createdAt: toIsoStringIfTimestamp(data.createdAt),
        updatedAt: toIsoStringIfTimestamp(data.updatedAt),
      };
    } else {
      console.log(`No PromptCard found with ID: ${cardId} for user ${userId}`);
      return null;
    }
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    const q = query(
      this.getCollectionRef(userId),
      orderBy('updatedAt', 'desc') // Order by last updated, newest first
    );
    const querySnapshot = await getDocs(q);
    const cards: PromptCard[] = [];
    querySnapshot.forEach((doc) => {
      // Same conversion for Timestamp objects as in getPromptCard
      const data = doc.data() as PromptCard;
      cards.push({
        ...data,
        createdAt: toIsoStringIfTimestamp(data.createdAt),
        updatedAt: toIsoStringIfTimestamp(data.updatedAt),
      });
    });
    console.log(`Retrieved ${cards.length} prompt cards for user ${userId}`);
    return cards;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    const cardDocRef = doc(this.getCollectionRef(userId), cardId);
    await deleteDoc(cardDocRef);
    console.log(`PromptCard ${cardId} deleted for user ${userId}`);
  }

  async importPromptCards(userId: string, cards: PromptCard[]): Promise<void> {
    // Firestore transactions/batch writes are ideal for bulk operations.
    // For simplicity in MVP, we'll do individual setDoc calls in parallel.
    // A more robust solution might use writeBatch for atomicity.
    const importPromises = cards.map(async (card) => {
      // Assume cardManager has already processed these cards for import (new IDs, hashes, ownerId).
      const cardDocRef = doc(this.getCollectionRef(userId), card.id);
      await setDoc(cardDocRef, {
        ...card,
        // Ensure timestamps are correctly handled for imported cards.
        // If the imported card already has createdAt/updatedAt, use them.
        // Otherwise, serverTimestamp() is an option, but for imports,
        // it's often preferred to preserve original times or set a specific import time.
        // For now, assume the card object already has string ISO timestamps set by cardManager.
      });
    });
    await Promise.all(importPromises);
    console.log(`Successfully imported ${cards.length} prompt cards for user ${userId}`);
  }
}

// Export a singleton instance of the repository for use throughout the application
export const promptCardRepository = new FirestorePromptCardRepository();
@@FILE: src/index.css
/* Reset and base styles */
* {
  box-sizing: border-box;
}

html,
body,
#root {
  margin: 0;
  padding: 0;
  height: 100%;
  background-color: transparent;
  color: inherit;
}

/* Prevent default link styles from clashing */
a {
  color: inherit;
  text-decoration: none;
}

/* Smooth scrolling */
html {
  scroll-behavior: smooth;
}

@@FOLDER: src/logic
@@FILE: src/logic/ContextStackAssembler.ts
// src/logic/ContextStackAssembler.ts
import { StackMode, FilterMode } from '../models';

import type {
  PromptCard,
  GameState,
  LogEntry,
  Message,
  SceneState,
  DigestLine,
} from '../models';
import type { IContextStackAssembler } from './IContextStackAssembler';
import { getNestedValue } from '../utils/jsonUtils'; // Assuming you have this utility function
import { debugLog, errorLog } from '../utils/debug';


export class ContextStackAssembler implements IContextStackAssembler {
  public assembleContext(card: PromptCard, gameState: GameState, logEntries: LogEntry[]): Message[] {
    const messages: Message[] = [];
    const { stackInstructions } = card;

    // 1. World State Context
    if (stackInstructions.worldStatePolicy.enabled) {
      messages.push({ role: "system", content: `## Current World State\n\`\`\`json\n${JSON.stringify(gameState.worldState, null, 2)}\n\`\`\`` });
    }

    // 2. Known Entities
    if (stackInstructions.knownEntitiesPolicy.enabled) {
      const knownEntities = this.extractKnownEntities(gameState, stackInstructions.knownEntitiesPolicy.n);
      if (knownEntities.length > 0) {
        messages.push({ role: "system", content: `## Known Entities\n${knownEntities.join('\n')}` });
      }
    }

    // 3. Digest Context
    if (stackInstructions.digestPolicy.enabled) {
      const relevantDigests = this.getRelevantDigests(logEntries, gameState, card.stackInstructions);
      if (relevantDigests.length > 0) {
        messages.push({ role: "system", content: `## Game Summary Digest\n${relevantDigests.map(d => d.text).join('\n')}` });
      }
    }

    // 4. Expression Log
    if (stackInstructions.expressionLogPolicy.enabled) {
      // Placeholder for complex expression logic
    }

    return messages;
  }
  
  private getSceneTags(scene: SceneState, worldState: Record<string, any>): string[] {
    const tags = new Set<string>();
    if (scene.location?.startsWith('@')) tags.add(scene.location);
    scene.present.forEach(path => {
      const entity = getNestedValue(worldState, path.split('.'));
      if (entity?.tag) tags.add(entity.tag);
    });
    return Array.from(tags);
  }

  private extractKnownEntities(gameState: GameState, limit: number): string[] {
    const entities = new Set(this.getSceneTags(gameState.scene, gameState.worldState));
    return Array.from(entities).slice(0, limit);
  }

  private getRelevantDigests(logs: LogEntry[], gameState: GameState, instructions: PromptCard['stackInstructions']): DigestLine[] {
    const relevantDigests: DigestLine[] = [];
    const sceneTags = this.getSceneTags(gameState.scene, gameState.worldState);
    for (const log of logs) {
      for (const digest of log.digestLines) {
        const rule = instructions.digestEmission[digest.importance];
        if (!rule || rule.mode === StackMode.NEVER) continue;
        const meetsCondition = (rule.mode === StackMode.ALWAYS) || (rule.mode === StackMode.FIRST_N && log.turnNumber <= rule.n) || (rule.mode === StackMode.AFTER_N && log.turnNumber >= rule.n);
        if (meetsCondition) {
          let include = true;
          if (instructions.digestPolicy.filtering === FilterMode.SCENE_ONLY) include = digest.tags?.some(tag => sceneTags.includes(tag)) ?? false;
          else if (instructions.digestPolicy.filtering === FilterMode.TAGGED) include = (digest.tags?.length ?? 0) > 0;
          if (include) relevantDigests.push(digest);
        }
      }
    }
    return relevantDigests;
  }
}
@@FILE: src/logic/GameStateManager.ts
// src/logic/GameStateManager.ts

import type { IGameStateManager } from './IGameStateManager';
import { produce } from 'immer'; // For immutable updates
import type { GameState, DeltaMap } from '../models';
/**
 * Manages the mutable aspects of the game state (world state and scene).
 * All mutations here are designed to be immutable, returning new state objects.
 */
export class GameStateManager implements IGameStateManager {

  /**
   * Applies delta instructions to the worldState within a given GameState.
   * @param gameState The current game state to modify.
   * @param deltas The map of delta instructions to apply.
   * @returns A new GameState object with deltas applied (immutable update).
   */
  public applyDeltasToGameState(gameState: GameState, deltas: DeltaMap): GameState {
    return produce(gameState, draft => {
      const updatedWorld = draft.worldState; // immer makes this a mutable draft

      for (const fullKey in deltas) {
        const instruction = deltas[fullKey];
        const parts = instruction.key.split('.');

        let currentLevel: Record<string, any> = updatedWorld;
        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!currentLevel[part] || typeof currentLevel[part] !== 'object' || Array.isArray(currentLevel[part])) {
            currentLevel[part] = {};
          }
          currentLevel = currentLevel[part];
        }

        const lastPart = parts[parts.length - 1];

        switch (instruction.op) {
          case 'add':
            const prevAddValue = typeof currentLevel[lastPart] === 'number' ? currentLevel[lastPart] : 0;
            const addValue = typeof instruction.value === 'number' ? instruction.value : 0;
            currentLevel[lastPart] = prevAddValue + addValue;
            break;
          case 'assign':
            currentLevel[lastPart] = instruction.value;
            break;
          case 'declare':
            if (!(lastPart in currentLevel)) {
              currentLevel[lastPart] = instruction.value;
            }
            break;
          case 'delete':
            delete currentLevel[lastPart];
            break;
        }
      }
    });
  }

  /**
   * Updates the scene state within a given GameState based on parsed AI output or inferred deltas.
   * @param gameState The current game state to modify.
   * @param parsedScene The parsed scene object from AI output.
   * @param deltas The delta map (for inference if no explicit scene).
   * @returns A new GameState object with updated scene (immutable update).
   */
  public updateSceneState(
    gameState: GameState,
    parsedScene: Record<string, any> | null | undefined,
    deltas: DeltaMap
  ): GameState {
    return produce(gameState, draft => {
      let newLocation: string | null = draft.scene.location;
      let newPresent: string[] = [...draft.scene.present];

      if (parsedScene) {
        if (parsedScene.location !== undefined) {
          newLocation = typeof parsedScene.location === 'string' ? parsedScene.location : null;
        }
        if (Array.isArray(parsedScene.present)) {
          newPresent = parsedScene.present.filter((item: any) => typeof item === 'string');
        }
      } else {
        if ((!newLocation && newPresent.length === 0) && deltas) {
          const inferredPresent = new Set<string>();
          for (const fullKey in deltas) {
            const instruction = deltas[fullKey];
            if (instruction.op === 'declare') {
              const parts = instruction.key.split('.');
              if (parts.length >= 2) {
                const category = parts[0];
                const entity = parts[1];
                const valueObj = instruction.value as Record<string, any>;
                if (valueObj && (valueObj.tag === "character" || valueObj.tag === "location")) {
                  inferredPresent.add(`${category}.${entity}`);
                }
              }
              if (instruction.key === "world.location" && typeof instruction.value === 'string') {
                newLocation = instruction.value;
              }
            }
          }
          newPresent = Array.from(inferredPresent);
        }
      }

      draft.scene.location = newLocation;
      draft.scene.present = newPresent;
    });
  }

  // --- World State Direct Modification Methods (Immutable) ---

  public renameCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      if (draft[oldName]) {
        draft[newName] = draft[oldName];
        delete draft[oldName];
      }
    });

    const updatedPinnedKeys = currentPinnedKeys.map(key =>
      key.startsWith(oldName + '.') ? `${newName}${key.substring(oldName.length)}` : key
    );
    return { updatedWorldState, updatedPinnedKeys };
  }

  public renameEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const categoryObj = draft[category];
      if (categoryObj && categoryObj[oldName]) {
        categoryObj[newName] = categoryObj[oldName];
        delete categoryObj[oldName];
      }
    });

    const oldEntityPath = `${category}.${oldName}`;
    const newEntityPath = `${category}.${newName}`;
    const updatedPinnedKeys = currentPinnedKeys.map(key =>
      key.startsWith(oldEntityPath + '.') ? `${newEntityPath}${key.substring(oldEntityPath.length)}` : key
    );
    return { updatedWorldState, updatedPinnedKeys };
  }

  public deleteCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      delete draft[category];
    });
    const updatedPinnedKeys = currentPinnedKeys.filter(key => !key.startsWith(category + '.'));
    return { updatedWorldState, updatedPinnedKeys };
  }

  public deleteEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, entity: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const categoryObj = draft[category];
      if (categoryObj && categoryObj[entity]) {
        delete categoryObj[entity];
      }
    });
    const entityPath = `${category}.${entity}`;
    const updatedPinnedKeys = currentPinnedKeys.filter(key => !key.startsWith(entityPath + '.'));
    return { updatedWorldState, updatedPinnedKeys };
  }

  public editKeyValue(currentWorldState: Record<string, any>, key: string, value: any): Record<string, any> {
    return produce(currentWorldState, draft => {
      const parts = key.split('.');
      let current: any = draft;
      for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!current[part] || typeof current[part] !== 'object') {
          current[part] = {};
        }
        current = current[part];
      }
      current[parts[parts.length - 1]] = value;
    });
  }

  public deleteKey(currentWorldState: Record<string, any>, currentPinnedKeys: string[], key: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] } {
    const updatedWorldState = produce(currentWorldState, draft => {
      const parts = key.split('.');
      let current: any = draft;
      for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!(part in current)) {
          return; // Path doesn't exist, nothing to delete
        }
        current = current[part];
      }
      delete current[parts[parts.length - 1]];
    });
    const updatedPinnedKeys = currentPinnedKeys.filter(pk => pk !== key);
    return { updatedWorldState, updatedPinnedKeys };
  }
}
@@FILE: src/logic/IContextStackAssembler.ts
// src/logic/IContextStackAssembler.ts
import type { PromptCard, GameState, LogEntry, Message } from '../models';

/**
 * Defines the contract for a service that assembles the dynamic parts
 * of an AI prompt's context based on StackInstructions.
 */
export interface IContextStackAssembler {
  /**
   * Assembles the full dynamic context stack based on the rules in the prompt card.
   * @param card The active PromptCard containing the StackInstructions.
   * @param gameState The current GameState.
   * @param logEntries The history of log entries for the session.
   * @returns An array of Message objects representing the assembled context.
   */
  assembleContext(
    card: PromptCard,
    gameState: GameState,
    logEntries: LogEntry[]
  ): Message[];
}


@@FILE: src/logic/IGameStateManager.ts
// src/logic/IGameStateManager.ts

import type { GameState, DeltaMap } from '../models';

/**
 * Defines the contract for managing the mutable state of the game (worldState and scene).
 * This manager operates on GameState objects and does not directly interact with repositories.
 */
export interface IGameStateManager {
  /**
   * Applies delta instructions to the worldState within a given GameState.
   * @param gameState The current game state to modify.
   * @param deltas The map of delta instructions to apply.
   * @returns A new GameState object with deltas applied (immutable update).
   */
  applyDeltasToGameState(gameState: GameState, deltas: DeltaMap): GameState;

  /**
   * Updates the scene state within a given GameState based on parsed AI output or inferred deltas.
   * @param gameState The current game state to modify.
   * @param parsedScene The parsed scene object from AI output.
   * @param deltas The delta map (for inference if no explicit scene).
   * @returns A new GameState object with updated scene (immutable update).
   */
  updateSceneState(gameState: GameState, parsedScene: Record<string, any> | null | undefined, deltas: DeltaMap): GameState;

  // Methods for direct world state modification (now immutable operations)
  renameCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  renameEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, oldName: string, newName: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  deleteCategory(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  deleteEntity(currentWorldState: Record<string, any>, currentPinnedKeys: string[], category: string, entity: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
  editKeyValue(currentWorldState: Record<string, any>, key: string, value: any): Record<string, any>;
  deleteKey(currentWorldState: Record<string, any>, currentPinnedKeys: string[], key: string): { updatedWorldState: Record<string, any>; updatedPinnedKeys: string[] };
}
@@FILE: src/logic/ISnapshotUpdater.ts
// src/logic/ISnapshotUpdater.ts
import type { GameSnapshot, ParsedNarrationOutput, LogEntry } from '../models';

export interface ITurnResult {
  parsedOutput: ParsedNarrationOutput;
  logEntry: LogEntry;
  playerAction?: string; // Include the player's action for conversation history
}

export interface ISnapshotUpdater {
  /**
   * Applies the result of a processed turn to a game snapshot.
   * This handles updating game state from deltas, scene changes, adding logs,
   * updating conversation history, and incrementing the turn counter.
   * @param snapshot The current GameSnapshot.
   * @param turnResult The result from the TurnProcessor.
   * @returns A new, updated GameSnapshot.
   */
  applyTurnResultToSnapshot(snapshot: GameSnapshot, turnResult: ITurnResult): GameSnapshot;

  /**
   * Applies a direct world state category rename to the snapshot.
   * @returns A new, updated GameSnapshot.
   */
  applyCategoryRename(snapshot: GameSnapshot, oldName: string, newName: string): GameSnapshot;

  /**
   * Applies a direct world state entity rename to the snapshot.
   * @returns A new, updated GameSnapshot.
   */
  applyEntityRename(snapshot: GameSnapshot, category: string, oldName: string, newName: string): GameSnapshot;
  applyCategoryDelete(snapshot: GameSnapshot, category: string): GameSnapshot;
  applyEntityDelete(snapshot: GameSnapshot, category: string, entity: string): GameSnapshot;
  applyKeyValueEdit(snapshot: GameSnapshot, key: string, value: any): GameSnapshot;
  applyKeyDelete(snapshot: GameSnapshot, key: string): GameSnapshot;
  applyPinToggle(snapshot: GameSnapshot, keyPath: string, type: 'variable' | 'entity' | 'category'): GameSnapshot;
}
@@FILE: src/logic/ITurnProcessor.ts
// src/logic/ITurnProcessor.ts

import type { PromptCard, GameState, LogEntry, Message, AiConnection, ParsedNarrationOutput, TokenSummary} from '../models';

/**
 * Defines the contract for processing individual game turns, including AI interaction.
 */
export interface ITurnProcessor {
  /**
   * Processes the first turn of a new game, generating the initial AI response and log.
   * @param userId The ID of the current user.
   * @param card The PromptCard used for the game.
   * @param initialGameState The initial game state.
   * @param useDummyNarrator Flag to use a dummy AI.
   * @param aiConnections User's configured AI connections.
   * @returns A Promise resolving with the parsed AI output, the generated log entry, and token usage.
   */
  processFirstTurnNarratorResponse(
    userId: string,
    card: PromptCard,
    initialGameState: GameState,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[],
  ): Promise<{
    parsedOutput: ParsedNarrationOutput;
    logEntry: LogEntry;
    aiRawOutput: string;
    tokenUsage: TokenSummary | null;
  }>;

  /**
   * Processes a player's action, generating the AI response and updating conversation history/logs.
   * @param userId The ID of the current user.
   * @param card The PromptCard used for the game.
   * @param currentGameState The current game state before the turn.
   * @param logs The current game logs.
   * @param conversationHistory The current conversation history.
   * @param action The player's input string.
   * @param turnNumber The current turn number.
   * @param useDummyNarrator Flag to use a dummy AI.
   * @param aiConnections User's configured AI connections.
   * @returns A Promise resolving with the parsed AI output, the generated log entry, and token usage.
   */
  processPlayerTurn(
    userId: string,
    card: PromptCard,
    currentGameState: GameState,
    logs: LogEntry[],
    conversationHistory: Message[],
    action: string,
    turnNumber: number,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[],
  ): Promise<{
    parsedOutput: ParsedNarrationOutput;
    logEntry: LogEntry;
    aiRawOutput: string;
    tokenUsage: TokenSummary | null;
  }>;
}
@@FILE: src/logic/SnapshotUpdater.ts
// src/logic/SnapshotUpdater.ts
import { produce } from 'immer';
import type { GameSnapshot } from '../models';
import type { IGameStateManager } from './IGameStateManager';
import type { ISnapshotUpdater, ITurnResult } from './ISnapshotUpdater';
import { flattenJsonObject, getNestedValue } from '../utils/jsonUtils';

export class SnapshotUpdater implements ISnapshotUpdater {
  constructor(private gameStateManager: IGameStateManager) {
    console.log('[SnapshotUpdater.ts] SnapshotUpdater constructor called.');
  }

  public applyTurnResultToSnapshot(snapshot: GameSnapshot, turnResult: ITurnResult): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyTurnResultToSnapshot: Starting for snapshot ${snapshot.id}. Turn: ${snapshot.currentTurn}`);
    const { parsedOutput, logEntry, playerAction } = turnResult;

    const newSnapshot = produce(snapshot, draft => {
      let stateAfterDeltas = this.gameStateManager.applyDeltasToGameState(draft.gameState, parsedOutput.deltas);
      let finalGameState = this.gameStateManager.updateSceneState(stateAfterDeltas, parsedOutput.scene, parsedOutput.deltas);

      finalGameState.narration = parsedOutput.prose;
      draft.gameState = finalGameState;

      if (playerAction) {
        draft.conversationHistory.push({ role: 'user', content: playerAction });
      }
      draft.conversationHistory.push({ role: 'assistant', content: parsedOutput.prose });
      
      draft.logs.push(logEntry);

      draft.currentTurn += 1;
      draft.updatedAt = new Date().toISOString();
    });
    console.log(`[SnapshotUpdater.ts] applyTurnResultToSnapshot: Finished. New snapshot ID: ${newSnapshot.id}.`);
    return newSnapshot;
  }

  public applyCategoryRename(snapshot: GameSnapshot, oldName: string, newName: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyCategoryRename: ${oldName} -> ${newName}`);
    return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.renameCategory(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        oldName,
        newName
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyEntityRename(snapshot: GameSnapshot, category: string, oldName: string, newName: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyEntityRename: ${category}.${oldName} -> ${category}.${newName}`);
    return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.renameEntity(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category,
        oldName,
        newName
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }
  
  public applyCategoryDelete(snapshot: GameSnapshot, category: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyCategoryDelete: ${category}`);
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteCategory(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyEntityDelete(snapshot: GameSnapshot, category: string, entity: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyEntityDelete: ${category}.${entity}`);
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteEntity(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        category,
        entity
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyKeyValueEdit(snapshot: GameSnapshot, key: string, value: any): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyKeyValueEdit: ${key} = ${JSON.stringify(value)}`);
     return produce(snapshot, draft => {
      draft.gameState.worldState = this.gameStateManager.editKeyValue(
        draft.gameState.worldState,
        key,
        value
      );
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyKeyDelete(snapshot: GameSnapshot, key: string): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyKeyDelete: ${key}`);
     return produce(snapshot, draft => {
      const { updatedWorldState, updatedPinnedKeys } = this.gameStateManager.deleteKey(
        draft.gameState.worldState,
        draft.worldStatePinnedKeys,
        key
      );
      draft.gameState.worldState = updatedWorldState;
      draft.worldStatePinnedKeys = updatedPinnedKeys;
      draft.updatedAt = new Date().toISOString();
    });
  }

  public applyPinToggle(snapshot: GameSnapshot, keyPath: string, type: 'variable' | 'entity' | 'category'): GameSnapshot {
    console.log(`[SnapshotUpdater.ts] applyPinToggle: Starting for snapshot ${snapshot.id}, keyPath: ${keyPath}, type: ${type}.`);
    const newSnapshot = produce(snapshot, draft => {
      const currentWorldState = draft.gameState.worldState || {};
      const currentPinnedKeys = draft.worldStatePinnedKeys || [];
      const newPinnedKeys = new Set(currentPinnedKeys);

      const getAllChildVariableKeys = (basePath: string): string[] => {
        const nestedData = getNestedValue(currentWorldState, basePath.split('.'));
        if (typeof nestedData !== 'object' || nestedData === null) return [];
        const flattened = flattenJsonObject(nestedData, basePath);
        return Object.keys(flattened).filter(key => flattened[key] !== undefined); // Only include existing keys
      };

      let relevantKeysToToggle: string[] = [];
      if (type === 'variable') {
        relevantKeysToToggle = [keyPath];
      } else { // 'entity' or 'category'
        relevantKeysToToggle = getAllChildVariableKeys(keyPath);
      }

      // If there are no keys to toggle (e.g., entity doesn't exist), do nothing.
      if (relevantKeysToToggle.length === 0) {
        console.warn(`[SnapshotUpdater.ts] applyPinToggle: No relevant keys found for ${type} at "${keyPath}". No change.`);
        return; // No changes to draft
      }
      
      const areAllChildrenCurrentlyPinned = relevantKeysToToggle.every(key => newPinnedKeys.has(key));
      const shouldPin = !areAllChildrenCurrentlyPinned; 

      console.log(`[SnapshotUpdater.ts] applyPinToggle: Relevant keys (${relevantKeysToToggle.length}): ${relevantKeysToToggle.join(', ')}. ShouldPin: ${shouldPin}`);

      relevantKeysToToggle.forEach(key => {
        if (shouldPin) {
          newPinnedKeys.add(key);
        } else {
          newPinnedKeys.delete(key);
        }
      });

      draft.worldStatePinnedKeys = Array.from(newPinnedKeys).sort();
      draft.updatedAt = new Date().toISOString();
      console.log(`[SnapshotUpdater.ts] applyPinToggle: Final pinned keys count: ${draft.worldStatePinnedKeys.length}.`);
    });
    console.log(`[SnapshotUpdater.ts] applyPinToggle: Finished. New snapshot ID: ${newSnapshot.id}.`);
    return newSnapshot;
  }
}
@@FILE: src/logic/TurnProcessor.ts
// src/logic/TurnProcessor.ts

import type { AiSettings, AiConnection, GameState, LogEntry, Message, ParsedNarrationOutput, PromptCard, TokenSummary } from '../models';
import type { IAiClient } from './aiClient';
import { parseNarratorOutput } from './deltaParser';
import type { ILogManager } from './logManager';
import type { IPromptBuilder } from './promptBuilder';
import type { ITurnProcessor } from './ITurnProcessor';
import type { ModelInfo } from '../data/config/aiConnectionTemplates';

// Define a simple DummyAiClient for testing and dev
class DummyAiClient implements IAiClient {
  async generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string> {
    console.log("Dummy Narrator: Simulating AI response...");
    // Find the LAST message with role 'user'
    const lastUserMessage = messages.slice().reverse().find(m => m.role === 'user')?.content || 'No user input.';
    const dummyResponse = {
      choices: [{
        message: {
          // MODIFIED: Dummy response to test all emits and match the expected structure with fences
          content: `The dummy narrator observes your action: "${lastUserMessage}". A ripple of arcane energy flows through the air, subtly shifting the very fabric of reality around you. You hear a distant chime, and a curious, ancient tome appears at your feet.

@digest
\`\`\`json
[
  { "text": "The world reacted to your input: '${lastUserMessage}'.", "importance": 2 },
  { "text": "Something new has manifested nearby: the $enchanted_quill.", "importance": 4, "tags": ["$enchanted_quill"] },
  { "text": "#Brom's disposition shifted slightly.", "importance": 3, "tags": ["#brom"] },
  { "text": "A critical system event occurred, requiring your attention!", "importance": 5 }
]
\`\`\`

@delta
\`\`\`json
{
  "=player.hp": 85,
  "+player.gold": 5,
  "!items.$enchanted_quill.description": "A quill that seems to hum with forgotten magic, vibrating faintly.",
  "-npcs.#old_sage.wisdom" : true,
  "=player.status": "observant"
}
\`\`\`

@scene
\`\`\`json
{
  "location": "@forest_clearing",
  "present": ["#you", "#lyrielle", "$enchanted_quill"],
  "weather": "clear and crisp"
}
\`\`\`
`
        }
      }],
      usage: {
        prompt_tokens: 10,
        completion_tokens: 150, // Increased for a longer response
        total_tokens: 160,
      }
    };
    return Promise.resolve(JSON.stringify(dummyResponse)); // Return as stringified JSON
  }

  async testConnection(connection: AiConnection): Promise<{ success: boolean; message: string }> {
    return Promise.resolve({
      success: true,
      message: "Dummy client: test always passes."
    });
  }
  
  async listModels(connection: Pick<AiConnection, 'apiUrl' | 'apiToken'>): Promise<ModelInfo[]> {
    return Promise.resolve([
      { id: 'dummy-model', name: 'Dummy Model' }
    ]);
  }
  
}


export class TurnProcessor implements ITurnProcessor {
  private realAiClient: IAiClient;
  private dummyAiClient: IAiClient;
  private builder: IPromptBuilder;
  private logManager: ILogManager;

  constructor(
    aiClient: IAiClient,
    promptBuilder: IPromptBuilder,
    logManager: ILogManager
  ) {
    this.realAiClient = aiClient;
    this.builder = promptBuilder;
    this.logManager = logManager;
    this.dummyAiClient = new DummyAiClient();
  }

  private async executeAiCall(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings,
    useDummyNarrator: boolean
  ): Promise<{ aiRawOutput: string; tokenUsage: TokenSummary | null; fullResponse: string }> {
    const activeClient = useDummyNarrator ? this.dummyAiClient : this.realAiClient;
    const fullResponse = await activeClient.generateCompletion(connection, messages, settings);

    let aiRawOutput = '';
    let tokenUsage: TokenSummary | null = null;
    try {
      const parsedJson = JSON.parse(fullResponse);
      aiRawOutput = parsedJson.choices?.[0]?.message?.content?.trim() || fullResponse;
      tokenUsage = parsedJson.usage ? {
        inputTokens: parsedJson.usage.prompt_tokens || 0,
        outputTokens: parsedJson.usage.completion_tokens || 0,
        totalTokens: parsedJson.usage.total_tokens || 0,
      } : null;
    } catch (e) {
      aiRawOutput = fullResponse;
    }
    return { aiRawOutput, tokenUsage, fullResponse };
  }

  async processFirstTurnNarratorResponse(
    userId: string,
    card: PromptCard,
    initialGameState: GameState,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[]
  ): Promise<{ parsedOutput: ParsedNarrationOutput; logEntry: LogEntry; aiRawOutput: string; tokenUsage: TokenSummary | null; }> {
    const messagesToSend = this.builder.buildFirstTurnPrompt(card);
    const contextSnapshotForLog = JSON.stringify(messagesToSend, null, 2);
    const userInputForLog = card.firstTurnOnlyBlock || "Begin the story.";

    const connection = aiConnections.find(c => c.id === card.aiSettings.selectedConnectionId);
    if (!connection && !useDummyNarrator) {
      throw new Error(`AI connection ${card.aiSettings.selectedConnectionId} not found.`);
    }

    const startTime = performance.now();
    const { aiRawOutput, tokenUsage, fullResponse } = await this.executeAiCall(connection!, messagesToSend, card.aiSettings, useDummyNarrator);
    const latencyMs = Math.round(performance.now() - startTime);

    const parsedOutput = parseNarratorOutput(aiRawOutput);

    const logEntry = this.logManager.assembleTurnLogEntry({
      turnNumber: 0,
      userInput: userInputForLog,
      rawNarratorOutput: aiRawOutput,
      parsedOutput: parsedOutput,
      contextSnapshot: contextSnapshotForLog,
      tokenUsage: tokenUsage,
      aiSettings: card.aiSettings,
      apiRequestBody: JSON.stringify({ model: connection?.modelSlug, messages: "..." }, null, 2),
      apiResponseBody: fullResponse,
      apiUrl: connection ? new URL("chat/completions", connection.apiUrl).href : 'dummy-url',
      latencyMs: latencyMs,
      modelSlugUsed: connection?.modelSlug || 'dummy-model',
    });

    return { parsedOutput, logEntry, aiRawOutput, tokenUsage };
  }

  async processPlayerTurn(
    userId: string,
    card: PromptCard,
    currentGameState: GameState,
    logs: LogEntry[],
    conversationHistory: Message[],
    action: string,
    turnNumber: number,
    useDummyNarrator: boolean,
    aiConnections: AiConnection[]
  ): Promise<{ parsedOutput: ParsedNarrationOutput; logEntry: LogEntry; aiRawOutput: string; tokenUsage: TokenSummary | null; }> {
    const messagesToSend = this.builder.buildEveryTurnPrompt(
      card,
      currentGameState,
      logs,
      conversationHistory,
      action,
    );
    const contextSnapshotForLog = JSON.stringify(messagesToSend, null, 2);

    const connection = aiConnections.find(c => c.id === card.aiSettings.selectedConnectionId);
    if (!connection && !useDummyNarrator) {
      throw new Error(`AI connection ${card.aiSettings.selectedConnectionId} not found.`);
    }

    const startTime = performance.now();
    const { aiRawOutput, tokenUsage, fullResponse } = await this.executeAiCall(connection!, messagesToSend, card.aiSettings, useDummyNarrator);
    const latencyMs = Math.round(performance.now() - startTime);

    const parsedOutput = parseNarratorOutput(aiRawOutput);

    const logEntry = this.logManager.assembleTurnLogEntry({
      turnNumber: turnNumber,
      userInput: action,
      rawNarratorOutput: aiRawOutput,
      parsedOutput: parsedOutput,
      contextSnapshot: contextSnapshotForLog,
      tokenUsage: tokenUsage,
      aiSettings: card.aiSettings,
      apiRequestBody: JSON.stringify({ model: connection?.modelSlug, messages: "..." }, null, 2),
      apiResponseBody: fullResponse,
      apiUrl: connection ? new URL("chat/completions", connection.apiUrl).href : 'dummy-url',
      latencyMs: latencyMs,
      modelSlugUsed: connection?.modelSlug || 'dummy-model',
    });

    return { parsedOutput, logEntry, aiRawOutput, tokenUsage };
  }
}
@@FILE: src/logic/aiClient.ts
// src/logic/aiClient.ts

import type { ModelInfo } from '../data/config/aiConnectionTemplates';
import type { Message, AiSettings, AiConnection } from '../models';
import { debugLog, errorLog } from '../utils/debug';

/**
 * Interface defining the contract for an AI client.
 */
export interface IAiClient {
  /**
   * Sends a completion request to the AI API.
   * @param connection The AiConnection details (URL, API key).
   * @param messages The array of messages forming the conversation context.
   * @param settings The AI settings for this specific call (temperature, etc.).
   * @returns A Promise that resolves with the raw stringified JSON of the AI's response.
   */
  generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string>;

  /**
   * Tests an AI connection by making a minimal API call.
   * @param connection The AiConnection details to test.
   * @returns A Promise that resolves to an object with success status and a descriptive message.
   */
  testConnection(connection: AiConnection): Promise<{ success: boolean, message: string }>;

  /**
   * Fetches a list of available models from the provider.
   * @param connection A partial connection object with apiUrl and apiToken.
   * @returns A Promise resolving with an array of ModelInfo objects.
   */
  listModels(connection: Pick<AiConnection, 'apiUrl' | 'apiToken'>): Promise<ModelInfo[]>;
}

/**
 * Concrete implementation of IAiClient using the browser's fetch API.
 */
class AiClient implements IAiClient {
  async generateCompletion(
    connection: AiConnection,
    messages: Message[],
    settings: AiSettings
  ): Promise<string> {
    if (!connection.apiToken || connection.apiToken.includes('PASTE') || connection.apiToken === "MISSING_API_KEY") {
      throw new Error("API key is missing or is a placeholder. Please set it in Settings.");
    }

    const apiUrl = new URL("chat/completions", connection.apiUrl).href;
    const requestBody = {
      model: connection.modelSlug,
      messages: messages,
      temperature: settings.temperature,
      top_p: settings.topP,
      max_tokens: settings.maxTokens,
      presence_penalty: settings.presencePenalty,
      frequency_penalty: settings.frequencyPenalty,
      stream: false,
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${connection.apiToken}` },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        let specificError = `Request failed with status ${response.status}.`;
        switch (response.status) {
          case 401: specificError = "Authentication error (401). Your API Key is likely invalid or expired."; break;
          case 403: specificError = "Permission denied (403). Your API key may not have access to this model."; break;
          case 404: specificError = `Model not found (404). Check if the API URL is correct and the model slug '${connection.modelSlug}' is valid.`; break;
          case 429: specificError = "Rate limit exceeded (429). You are sending requests too quickly. Please wait and try again."; break;
          case 500: specificError = "AI Server Error (500). The provider is having issues. Please try again later."; break;
        }
        throw new Error(`${specificError} Details: ${errorBody.substring(0, 200)}...`);
      }

      const responseJson = await response.json();
      return JSON.stringify(responseJson);
    } catch (error: unknown) {
        if (error instanceof Error) {
            throw new Error(`AI API call failed: ${error.message}`);
        }
        throw new Error(`An unknown error occurred during the AI API call.`);
    }
  }

  async testConnection(connection: AiConnection): Promise<{ success: boolean, message: string }> {
    if (!connection.apiToken || connection.apiToken.includes('PASTE') || connection.apiToken === "MISSING_API_KEY") {
      return { success: false, message: "API Key is missing or is a placeholder." };
    }

    const apiUrl = new URL("chat/completions", connection.apiUrl).href;
    const testMessage: Message[] = [{ role: 'user', content: 'hello' }];
    const requestBody = { model: connection.modelSlug, messages: testMessage, max_tokens: 10 };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${connection.apiToken}` },
        body: JSON.stringify(requestBody),
      });

      if (response.ok) {
        return { success: true, message: `Success! Received response from model.` };
      } else {
        const errorBody = await response.text();
        let specificError = `Request failed with status ${response.status}.`;
        switch (response.status) {
          case 401: specificError = "Authentication error (401). Your API Key is invalid."; break;
          case 404: specificError = `Model not found (404). Check API URL and Model Slug.`; break;
          case 403: specificError = "Permission denied (403). Key may not have access to this model."; break;
          default: specificError = `Error ${response.status}: ${errorBody.substring(0, 100)}`;
        }
        return { success: false, message: ` ${specificError}` };
      }
    } catch (error) {
      return { success: false, message: ` Network Error: Could not reach the API endpoint. Check the URL and your connection.` };
    }
  }

  async listModels(connection: Pick<AiConnection, 'apiUrl' | 'apiToken'>): Promise<ModelInfo[]> {
    if (!connection.apiToken || connection.apiToken.includes('PASTE')) {
      throw new Error("An API key is required to fetch models.");
    }
    
    const modelsUrl = new URL("models", connection.apiUrl).href;

    try {
      const response = await fetch(modelsUrl, { 
        method: 'GET', 
        headers: { 'Authorization': `Bearer ${connection.apiToken}` }
      });
      if (!response.ok) {
        throw new Error(`Failed to fetch models with status ${response.status}`);
      }
      const json = await response.json();
      
      // The data structure varies between APIs (e.g., json.data for OpenAI)
      const modelList = json.data || json.models || [];

      return modelList
        .map((model: any) => ({ 
          id: model.id, 
          name: model.name || model.id // Use 'name' if available (like OpenRouter), otherwise fall back to 'id'
        }))
        .sort((a: ModelInfo, b: ModelInfo) => a.name.localeCompare(b.name));

    } catch (error) {
      errorLog("Failed to list models:", error);
      throw error;
    }
  }
}

// Export a singleton instance of the AI client.
export const aiClient = new AiClient();
@@FILE: src/logic/cardManager.ts
// src/logic/cardManager.ts

import type { PromptCard, NewPromptCardData, StackInstructions} from '../models';
import { generateUuid } from '../utils/uuid';
import { generateContentHash, getPromptCardContentForHash } from '../utils/hash';
import { promptCardRepository } from '../data/repositories/promptCardRepository';
import type { IPromptCardRepository } from '../data/repositories/promptCardRepository';

import { debugLog, errorLog } from '../utils/debug';
import {
  defaultAiSettingsInCard,
  defaultStackInstructions,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../data/config/promptCardDefaults';

/**
 * Interface defining the contract for the Card Manager.
 * This can be useful for testing or providing different implementations (e.g., a mock manager).
 */
export interface ICardManager {
  /**
   * Creates a brand new PromptCard with default values for unspecified fields.
   * Generates new IDs and hash, sets creation/update timestamps.
   * @param userId The ID of the user creating the card.
   * @param data The initial data for the new card.
   * @returns A Promise resolving with the newly created PromptCard.
   */
  createNewPromptCard(userId: string, data: NewPromptCardData): Promise<PromptCard>;

  /**
   * Updates an existing PromptCard. Recalculates the content hash and updates the timestamp.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the card to update.
   * @param updates The partial PromptCard data to apply.
   * @returns A Promise resolving with the updated PromptCard or null if not found.
   */
  updatePromptCard(userId: string, cardId: string, updates: Partial<PromptCard>): Promise<PromptCard | null>;

  /**
   * Duplicates an existing PromptCard, creating a new card with a new ID
   * but linking it to the original's lineage (parentId, rootId).
   * @param userId The ID of the user performing the duplication.
   * @param sourceCardId The ID of the card to duplicate.
   * @returns A Promise resolving with the new, duplicated PromptCard or null if source not found.
   */
  duplicatePromptCard(userId: string, sourceCardId: string): Promise<PromptCard | null>;

  /**
   * Deletes a PromptCard.
   * @param userId The ID of the user owning the card.
   * @param cardId The ID of the card to delete.
   * @returns A Promise resolving when the card is deleted.
   */
  deletePromptCard(userId: string, cardId: string): Promise<void>;

  /**
   * Retrieves a single PromptCard.
   * @param userId The ID of the user.
   * @param cardId The ID of the card.
   * @returns A Promise resolving with the PromptCard or null if not found.
   */
  getPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Retrieves all PromptCards for a user.
   * @param userId The ID of the user.
   * @returns A Promise resolving with an array of PromptCards.
   */
  getAllPromptCards(userId: string): Promise<PromptCard[]>;

  /**
   * Exports a single PromptCard for sharing/download.
   * This might involve stripping user-specific metadata like ownerId for public sharing.
   * For now, it simply returns the card, but can be extended.
   * @param userId The ID of the user exporting.
   * @param cardId The ID of the card to export.
   * @returns A Promise resolving with the PromptCard or null.
   */
  exportPromptCard(userId: string, cardId: string): Promise<PromptCard | null>;

  /**
   * Imports PromptCards from a provided list (e.g., from a JSON file).
   * This involves generating new IDs, re-calculating hashes, setting ownerId,
   * and linking lineage appropriately.
   * @param userId The ID of the user importing.
   * @param importedCardsData An array of NewPromptCardData (or similar) from the import source.
   * @returns A Promise resolving with an array of the newly imported PromptCards.
   */
  importPromptCards(userId: string, importedCardsData: NewPromptCardData[]): Promise<PromptCard[]>;
}

/**
 * Concrete implementation of ICardManager.
 */
export class PromptCardManager implements ICardManager {
  constructor(private repo: IPromptCardRepository) {}

  private async buildPromptCard(userId: string, data: NewPromptCardData, existingCard?: PromptCard): Promise<PromptCard> {
    const now = new Date().toISOString();
    let cardId: string;
    let rootId: string;
    let parentId: string | null;
    let createdAt: string;

    if (existingCard) {
      // This path is for updates, or duplicating where we are basing off an existing structure
      cardId = existingCard.id;
      rootId = existingCard.rootId;
      parentId = existingCard.parentId; // Parent ID remains the same for updates
      createdAt = existingCard.createdAt;
    } else {
      // This path is for new creations or imports that need new IDs
      cardId = generateUuid();
      rootId = cardId; // For brand new cards, rootId is its own ID
      parentId = null; // No parent for brand new cards
      createdAt = now;
    }

    // Handle stackInstructions: if provided as string, parse it; otherwise use object or default.
    let parsedStackInstructions: StackInstructions;
    if (typeof data.stackInstructions === 'string') {
      try {
        parsedStackInstructions = JSON.parse(data.stackInstructions);
      } catch (e) {
        errorLog("Error parsing stackInstructions string for new card, falling back to default:", e);
        parsedStackInstructions = defaultStackInstructions;
      }
    } else if (data.stackInstructions) {
      parsedStackInstructions = data.stackInstructions;
    } else {
      parsedStackInstructions = defaultStackInstructions;
    }

    // Construct the card with defaults applied where data is missing
    const tempCard: PromptCard = {
      id: cardId,
      rootId: rootId,
      parentId: parentId,
      ownerId: userId,
      createdAt: createdAt,
      updatedAt: now, // Always update timestamp on creation/modification
      title: data.title,
      prompt: data.prompt,
      description: data.description ?? null,
      firstTurnOnlyBlock: data.firstTurnOnlyBlock ?? DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: parsedStackInstructions,
      emitSkeleton: data.emitSkeleton ?? DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: data.worldStateInit ?? "",
      gameRules: data.gameRules ?? "",
      aiSettings: { ...defaultAiSettingsInCard, ...data.aiSettings },
      helperAiSettings: { ...defaultAiSettingsInCard, ...data.helperAiSettings },
      isHelperAiEnabled: data.isHelperAiEnabled ?? false, // NEW: Initialize with default false
      tags: data.tags ?? [],
      isExample: data.isExample ?? false,
      functionDefs: data.functionDefs ?? "",
      isPublic: data.isPublic ?? false, // Default to private for new user-created cards
      contentHash: '', // Will be calculated below
    };

    // Calculate content hash AFTER all content fields are finalized
    tempCard.contentHash = generateContentHash(getPromptCardContentForHash(tempCard));

    return tempCard;
  }

  async createNewPromptCard(userId: string, data: NewPromptCardData): Promise<PromptCard> {
    const newCard = await this.buildPromptCard(userId, data);
    await this.repo.savePromptCard(userId, newCard);
    return newCard;
  }

  async updatePromptCard(userId: string, cardId: string, updates: Partial<PromptCard>): Promise<PromptCard | null> {
    const existingCard = await this.repo.getPromptCard(userId, cardId);
    if (!existingCard) {
      return null;
    }

    // Apply updates
    const updatedCardData = { ...existingCard, ...updates };

    // Re-calculate hash based on potentially changed content fields
    const newContentHash = generateContentHash(getPromptCardContentForHash(updatedCardData));
    updatedCardData.contentHash = newContentHash;
    updatedCardData.updatedAt = new Date().toISOString(); // Update timestamp on modification

    await this.repo.savePromptCard(userId, updatedCardData);
    return updatedCardData;
  }

  async duplicatePromptCard(userId: string, sourceCardId: string): Promise<PromptCard | null> {
    const sourceCard = await this.repo.getPromptCard(userId, sourceCardId);
    if (!sourceCard) {
      debugLog(`Source card with ID ${sourceCardId} not found for duplication.`);
      return null;
    }

    const newId = generateUuid();
    const now = new Date().toISOString();

    const duplicatedCard: PromptCard = {
      ...sourceCard, // Copy all existing fields
      id: newId, // Assign new ID
      rootId: sourceCard.rootId, // Root remains the same
      parentId: sourceCard.id, // New parent is the source card
      ownerId: userId, // Ensure new owner is current user
      createdAt: now, // New creation timestamp for the duplicate
      updatedAt: now, // New update timestamp
      isExample: false, // Duplicates are user-owned, not examples
      isPublic: false, // Duplicates are private by default
      // isHelperAiEnabled will be copied correctly from sourceCard by the spread operator
    };

    // Recalculate hash for the duplicated card in case any content fields were implicitly changed
    // (e.g., if a previous source card had an older version of stack instructions that parsed differently).
    // Or just for robustness.
    duplicatedCard.contentHash = generateContentHash(getPromptCardContentForHash(duplicatedCard));

    await this.repo.savePromptCard(userId, duplicatedCard);
    debugLog(`Card ${sourceCardId} duplicated to ${newId}`);
    return duplicatedCard;
  }

  async deletePromptCard(userId: string, cardId: string): Promise<void> {
    await this.repo.deletePromptCard(userId, cardId);
  }

  async getPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    return this.repo.getPromptCard(userId, cardId);
  }

  async getAllPromptCards(userId: string): Promise<PromptCard[]> {
    return this.repo.getAllPromptCards(userId);
  }

  async exportPromptCard(userId: string, cardId: string): Promise<PromptCard | null> {
    const card = await this.repo.getPromptCard(userId, cardId);
    if (card) {
      // For export, you might want to strip or transform sensitive/user-specific fields.
      // For MVP, we return the full card.
      // E.g., delete card.ownerId; // if it's meant for public template export
    }
    return card;
  }

  async importPromptCards(userId: string, importedCardsData: NewPromptCardData[]): Promise<PromptCard[]> {
    const importedAndProcessedCards: PromptCard[] = [];
    for (const data of importedCardsData) {
      // For imported cards, we generate a new UUID.
      // The parentId and rootId logic for imports needs careful consideration:
      // If the imported card explicitly defines a lineage, we might keep it.
      // If it's a "fresh" import, its rootId becomes its own new ID, parentId is null.
      // For now, let's treat all imports as new roots by default for simplicity,
      // and re-establish lineage if a more complex import format is defined later.
      // OR, if `NewPromptCardData` from import includes original IDs, we could preserve root/parent
      // For MVP, let's assume they are new root cards.
      const newCard = await this.buildPromptCard(userId, data);
      importedAndProcessedCards.push(newCard);
    }
    await this.repo.importPromptCards(userId, importedAndProcessedCards);
   debugLog(`Imported ${importedAndProcessedCards.length} cards.`);
    return importedAndProcessedCards;
  }
}

// Export a singleton instance of the manager
export const promptCardManager = new PromptCardManager(promptCardRepository);
@@FILE: src/logic/deltaParser.ts
// src/logic/deltaParser.ts
import type { DeltaInstruction, DeltaMap,DigestLine, ParsedNarrationOutput} from '../models';
import { debugLog, errorLog } from '../utils/debug';

// Exported Marker constants
export const DELTA_MARKER = "@delta";
export const DIGEST_MARKER = "@digest";
export const SCENE_MARKER = "@scene";

/**
 * Extracts a JSON object from a string, handling potential parsing errors.
 * This function expects the *raw JSON string*, not lines including fences.
 * @param jsonString The raw JSON string.
 * @returns A JSON object, or an empty object on error.
 */
function extractJsonObject(jsonString: string): Record<string, unknown> {
  const text = jsonString.trim();
  if (!text) return {};
  try {
    const parsed = JSON.parse(text);
    return typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed) ? parsed : {};
  } catch (e: unknown) {
    errorLog("Failed to parse JSON object:", e, "\nText:", text);
    return {};
  }
}

/**
 * Extracts a JSON array from a string, handling potential parsing errors.
 * This function expects the *raw JSON string*, not lines including fences.
 * @param jsonString The raw JSON string.
 * @returns A JSON array, or an empty array on error.
 */
function extractJsonArray(jsonString: string): unknown[] {
  const text = jsonString.trim();
  if (!text) return [];
  try {
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : [];
  } catch (e: unknown) {
    errorLog("Failed to parse JSON array:", e, "\nText:", text);
    return [];
  }
}

/**
 * Extracts content from a markdown-fenced JSON block.
 * Looks for ```json and ```. Also includes a fallback for unfenced blocks
 * if a JSON start character is found immediately after the marker.
 * @param lines The full array of lines from AI output.
 * @param startIndex The index of the marker line (e.g., @delta).
 * @returns The raw JSON string content, or an empty string if not found.
 */
function extractFencedJsonBlock(lines: string[], startIndex: number): string {
    if (startIndex < 0 || startIndex >= lines.length) {
        return "";
    }

    let jsonLines: string[] = [];
    let inJsonBlock = false;
    let fenceFound = false;

    // Start searching from the line *after* the marker
    for (let i = startIndex + 1; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line.startsWith("```")) {
            if (!inJsonBlock) {
                // Found opening fence
                inJsonBlock = true;
                fenceFound = true;
                // If there's content *after* ```json on the same line
                const contentAfterFence = line.substring(line.indexOf('{'));
                if(contentAfterFence.startsWith('{') || contentAfterFence.startsWith('[')) {
                    jsonLines.push(contentAfterFence);
                }
                continue;
            } else {
                // Found closing fence
                break;
            }
        }

        if (inJsonBlock) {
            jsonLines.push(lines[i]);
        } else if (!fenceFound && (line.startsWith("{") || line.startsWith("["))) {
            // If no fence was found yet, but we encounter a JSON start,
            // assume it's an unfenced block and start capturing.
            // This is a fallback for AIs that don't use fences.
            inJsonBlock = true;
            jsonLines.push(lines[i]);
        } else if (inJsonBlock && !fenceFound && !line.startsWith("{") && !line.startsWith("[")) {
            // If we're in an unfenced block but encounter a non-JSON line, stop.
            break;
        }
    }

    return jsonLines.join('\n').trim();
}

/**
 * Parses a key-value pair from the AI's delta JSON into a DeltaInstruction.
 * Corresponds to `DeltaInstruction.fromJsonElement` from the old project.
 * The raw key is expected to be in the format `+player.gold` or `=npcs.goblin.hp`.
 * @param rawKey The raw key from the JSON, e.g., "+player.gold".
 * @param value The JSON value associated with the key.
 * @returns A DeltaInstruction object or null if parsing fails.
 */
function parseSingleDelta(rawKey: string, value: unknown): DeltaInstruction | null {
  const op = rawKey.charAt(0);
  const path = rawKey.substring(1); // The rest of the key, e.g., "player.gold"

  switch (op) {
    case '+':
      return { op: 'add', key: path, value: value };
    case '=':
      return { op: 'assign', key: path, value: value };
    case '!':
      return { op: 'declare', key: path, value: value };
    case '-':
      return { op: 'delete', key: path };
    default:
      console.warn(`Invalid delta operation character '${op}' in key '${rawKey}'`);
      return null;
  }
}

/**
 * Parses the raw AI response string into a structured ParsedNarrationOutput object.
 * This function replicates the logic of `NarrationParser.extractJsonAndCleanNarration`.
 * @param rawAiOutput The full, raw string from the AI model.
 * @returns A ParsedNarrationOutput object.
 */
export function parseNarratorOutput(rawAiOutput: string): ParsedNarrationOutput {
  const lines = rawAiOutput.split('\n');

  const deltaIndex = lines.findIndex(line => line.trim() === DELTA_MARKER);
  const digestIndex = lines.findIndex(line => line.trim() === DIGEST_MARKER);
  const sceneIndex = lines.findIndex(line => line.trim() === SCENE_MARKER);

  const firstMarkerIndex = [deltaIndex, digestIndex, sceneIndex]
    .filter(index => index !== -1)
    .reduce((min, current) => Math.min(min, current), lines.length);

  const prose = lines.slice(0, firstMarkerIndex).join('\n').trim();

  // Use the new helper to extract the raw JSON strings
  const deltaJsonString = extractFencedJsonBlock(lines, deltaIndex);
  const digestJsonString = extractFencedJsonBlock(lines, digestIndex);
  const sceneJsonString = extractFencedJsonBlock(lines, sceneIndex);

  const deltaJson = extractJsonObject(deltaJsonString);
  const digestJson = extractJsonArray(digestJsonString);
  const sceneJson = extractJsonObject(sceneJsonString);

  // --- Parse Deltas ---
  const deltas: DeltaMap = {};
  for (const key in deltaJson) {
    const instruction = parseSingleDelta(key, deltaJson[key]);
    if (instruction) {
      deltas[key] = instruction;
    }
  }

  // --- Parse Digest Lines ---
  const digestLines: DigestLine[] = digestJson.map((item) => {
    const { text = '', importance } = item as { text?: string; importance?: number };
    const finalImportance = typeof importance === 'number' ? importance : 3;
    // Extract tags from text using regex, as in original NarrationParser
    const tagPattern = /[#@$][a-zA-Z0-9_]+/g;
    const tags = text.match(tagPattern) || [];
    return { text, importance: finalImportance, tags };
  }).filter(line => line.text); // Filter out empty lines

  return {
    prose,
    deltas,
    digestLines,
    scene: sceneJson,
  };
}
@@FILE: src/logic/gameSession.ts
import type { IGameRepository } from '../data/repositories/gameRepository';
import type { IPromptCardRepository } from '../data/repositories/promptCardRepository';
import type { GameSnapshot, GameState, LogEntry, Message, PromptCard } from '../models';
import { formatIsoDateForDisplay } from '../utils/formatDate';
import { generateUuid } from '../utils/uuid';
import type { ITurnProcessor } from './ITurnProcessor';
import type { ISnapshotUpdater } from './ISnapshotUpdater';
import { debugLog, errorLog } from '../utils/debug'; //  Injected centralized logger

export interface IGameSession {
  initializeGame(userId: string, cardId: string, existingSnapshotId?: string): Promise<void>;
  processPlayerAction(action: string, useDummyNarrator: boolean): Promise<GameSnapshot>;
  processFirstNarratorTurn(useDummyNarrator: boolean): Promise<GameSnapshot>;
  getCurrentGameSnapshot(): GameSnapshot | null;
  saveGame(snapshot: GameSnapshot): Promise<void>;
  loadGame(userId: string, snapshotId: string): Promise<void>;
  loadLastActiveGame(userId: string): Promise<boolean>;
  getCurrentPromptCard(): PromptCard | null;
  getCurrentGameState(): GameState | null;
  getGameLogs(): LogEntry[];
  gameRepo: IGameRepository;
  renameWorldCategory(oldName: string, newName: string): Promise<GameSnapshot | null>;
  renameWorldEntity(category: string, oldName: string, newName: string): Promise<GameSnapshot | null>;
  deleteWorldCategory(category: string): Promise<GameSnapshot | null>;
  deleteWorldEntity(category: string, entity: string): Promise<GameSnapshot | null>;
  editWorldKeyValue(key: string, value: any): Promise<GameSnapshot | null>;
  deleteWorldKey(key: string): Promise<GameSnapshot | null>;
  toggleWorldStatePin(keyPath: string, type: 'variable' | 'entity' | 'category'): Promise<GameSnapshot | null>;
}

export class GameSession implements IGameSession {
  private currentUserId: string | null = null;
  private currentSnapshot: GameSnapshot | null = null;
  private currentPromptCard: PromptCard | null = null;

  constructor(
    public gameRepo: IGameRepository,
    private cardRepo: IPromptCardRepository,
    private turnProcessor: ITurnProcessor,
    private snapshotUpdater: ISnapshotUpdater
  ) {
    debugLog('[gameSession.ts] GameSession constructor called.');
  }

  public async initializeGame(userId: string, cardId: string, existingSnapshotId?: string): Promise<void> {
    debugLog(`[gameSession.ts] initializeGame: Starting for User=${userId}, Card=${cardId}, Snapshot=${existingSnapshotId || 'new'}`);
    this.currentUserId = userId;

    if (existingSnapshotId) {
      await this.loadGame(userId, existingSnapshotId);
      debugLog(`[gameSession.ts] initializeGame: Loaded existing game ${existingSnapshotId}.`);
      return;
    }

    const card = await this.cardRepo.getPromptCard(userId, cardId);
    if (!card) {
      errorLog(`[gameSession.ts] initializeGame: PromptCard with ID ${cardId} not found.`);
      throw new Error(`PromptCard with ID ${cardId} not found.`);
    }
    this.currentPromptCard = card;

    let initialWorldState = {};
    try {
      if (card.worldStateInit) {
        initialWorldState = JSON.parse(card.worldStateInit);
      } else {
        initialWorldState = {};
      }
    } catch (e) {
      errorLog("[gameSession.ts] initializeGame: Failed to parse worldStateInit JSON:", e);
      initialWorldState = {};
    }

    const now = new Date().toISOString();
    const firstTurnProse = card.firstTurnOnlyBlock || "The story begins...";

    const initialSnapshot: GameSnapshot = {
      id: generateUuid(),
      userId: userId,
      promptCardId: cardId,
      title: `Game with ${card.title} - ${formatIsoDateForDisplay(now)}`,
      createdAt: now,
      updatedAt: now,
      currentTurn: 0,
      gameState: {
        narration: firstTurnProse,
        worldState: initialWorldState,
        scene: { location: null, present: [] },
      },
      conversationHistory: [{ role: 'assistant', content: firstTurnProse }],
      logs: [],
      worldStatePinnedKeys: [],
    };

    this.currentSnapshot = initialSnapshot;
    debugLog(`[gameSession.ts] initializeGame: NEW game initialized with ID ${initialSnapshot.id}. currentSnapshot set.`);
  }

  public async processFirstNarratorTurn(useDummyNarrator: boolean): Promise<GameSnapshot> {
    debugLog('[gameSession.ts] processFirstNarratorTurn: Starting.');
    if (!this.currentSnapshot || !this.currentUserId || !this.currentPromptCard) {
      errorLog('[gameSession.ts] processFirstNarratorTurn: Prerequisites missing.');
      throw new Error("Cannot process first turn: Game not initialized correctly.");
    }

    const aiConnections = await this.gameRepo.getAiConnections(this.currentUserId);
    debugLog(`[gameSession.ts] processFirstNarratorTurn: Calling turnProcessor.useDummyNarrator=${useDummyNarrator}.`);
    const turnResult = await this.turnProcessor.processFirstTurnNarratorResponse(
      this.currentUserId,
      this.currentPromptCard,
      this.currentSnapshot.gameState,
      useDummyNarrator,
      aiConnections
    );

    debugLog('[gameSession.ts] processFirstNarratorTurn: Calling snapshotUpdater.applyTurnResultToSnapshot.');
    const newSnapshot = this.snapshotUpdater.applyTurnResultToSnapshot(this.currentSnapshot, turnResult);

    this.currentSnapshot = newSnapshot;
    debugLog(`[gameSession.ts] processFirstNarratorTurn: newSnapshot ${newSnapshot.id} applied. Saving game...`);
    await this.saveGame(newSnapshot);
    debugLog('[gameSession.ts] processFirstNarratorTurn: Finished and saved.');
    return newSnapshot;
  }

  public async processPlayerAction(action: string, useDummyNarrator: boolean): Promise<GameSnapshot> {
    debugLog(`[gameSession.ts] processPlayerAction: Starting for action: "${action.substring(0, 50)}..."`);
    if (!this.currentSnapshot || !this.currentUserId || !this.currentPromptCard) {
      errorLog('[gameSession.ts] processPlayerAction: Prerequisites missing.');
      throw new Error("Cannot process player action: Game not initialized correctly.");
    }

    const aiConnections = await this.gameRepo.getAiConnections(this.currentUserId);
    debugLog(`[gameSession.ts] processPlayerAction: Calling turnProcessor.useDummyNarrator=${useDummyNarrator}.`);
    const turnResult = await this.turnProcessor.processPlayerTurn(
      this.currentUserId,
      this.currentPromptCard,
      this.currentSnapshot.gameState,
      this.currentSnapshot.logs,
      this.currentSnapshot.conversationHistory,
      action,
      this.currentSnapshot.currentTurn,
      useDummyNarrator,
      aiConnections
    );

    debugLog('[gameSession.ts] processPlayerAction: Calling snapshotUpdater.applyTurnResultToSnapshot.');
    const newSnapshot = this.snapshotUpdater.applyTurnResultToSnapshot(this.currentSnapshot, { ...turnResult, playerAction: action });

    this.currentSnapshot = newSnapshot;
    debugLog(`[gameSession.ts] processPlayerAction: newSnapshot ${newSnapshot.id} applied. Saving game...`);
    await this.saveGame(newSnapshot);
    debugLog('[gameSession.ts] processPlayerAction: Finished and saved.');
    return newSnapshot;
  }

  private async updateAndSave(updater: (snapshot: GameSnapshot) => GameSnapshot): Promise<GameSnapshot | null> {
    debugLog(`[gameSession.ts] updateAndSave: Applying update and saving. currentSnapshot before update: ${this.currentSnapshot?.id || 'null'}`);
    if (!this.currentSnapshot) {
      debugLog('[gameSession.ts] updateAndSave: No currentSnapshot to update. Returning null.');
      return null;
    }

    const newSnapshot = updater(this.currentSnapshot);
    this.currentSnapshot = newSnapshot;
    debugLog(`[gameSession.ts] updateAndSave: currentSnapshot updated to ${this.currentSnapshot.id}. Persisting...`);
    await this.saveGame(newSnapshot);
    debugLog('[gameSession.ts] updateAndSave: Persisted successfully.');
    return newSnapshot;
  }

  public async renameWorldCategory(oldName: string, newName: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyCategoryRename(snap, oldName, newName));
  }

  public async renameWorldEntity(category: string, oldName: string, newName: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyEntityRename(snap, category, oldName, newName));
  }

  public async deleteWorldCategory(category: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyCategoryDelete(snap, category));
  }

  public async deleteWorldEntity(category: string, entity: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyEntityDelete(snap, category, entity));
  }

  public async editWorldKeyValue(key: string, value: any): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyKeyValueEdit(snap, key, value));
  }

  public async deleteWorldKey(key: string): Promise<GameSnapshot | null> {
    return this.updateAndSave(snap => this.snapshotUpdater.applyKeyDelete(snap, key));
  }

  public async toggleWorldStatePin(keyPath: string, type: 'variable' | 'entity' | 'category'): Promise<GameSnapshot | null> {
    debugLog(`[gameSession.ts] toggleWorldStatePin: Toggling pin for ${type} at path "${keyPath}".`);
    return this.updateAndSave(snap => this.snapshotUpdater.applyPinToggle(snap, keyPath, type));
  }

  public async loadGame(userId: string, snapshotId: string): Promise<void> {
    debugLog(`[gameSession.ts] loadGame: Attempting to load snapshot ${snapshotId} for user ${userId}.`);
    const snapshot = await this.gameRepo.getGameSnapshot(userId, snapshotId);
    if (!snapshot) {
      errorLog(`[gameSession.ts] loadGame: Snapshot ${snapshotId} not found.`);
      throw new Error(`Game snapshot ${snapshotId} not found.`);
    }
    const card = await this.cardRepo.getPromptCard(userId, snapshot.promptCardId);
    if (!card) {
      errorLog(`[gameSession.ts] loadGame: PromptCard ${snapshot.promptCardId} not found for loaded game.`);
      throw new Error(`PromptCard ${snapshot.promptCardId} not found.`);
    }

    this.currentUserId = userId;
    this.currentSnapshot = snapshot;
    this.currentPromptCard = card;
    debugLog(`[gameSession.ts] loadGame: Successfully loaded snapshot ${snapshot.id} and card ${card.id}. currentSnapshot set.`);
  }

  public async loadLastActiveGame(userId: string): Promise<boolean> {
    debugLog(`[gameSession.ts] loadLastActiveGame: Checking for last active game for user ${userId}.`);
    const allSnapshots = await this.gameRepo.getAllGameSnapshots(userId);
    if (allSnapshots.length > 0) {
      debugLog(`[gameSession.ts] loadLastActiveGame: Found ${allSnapshots.length} snapshots. Loading most recent: ${allSnapshots[0].id}.`);
      await this.loadGame(userId, allSnapshots[0].id);
      debugLog('[gameSession.ts] loadLastActiveGame: Finished loading last active game. Returning true.');
      return true;
    }
    debugLog('[gameSession.ts] loadLastActiveGame: No last active game found. Returning false.');
    return false;
  }

  public async saveGame(snapshot: GameSnapshot): Promise<void> {
    debugLog(`[gameSession.ts] saveGame: Attempting to save snapshot ${snapshot.id}.`);
    if (!this.currentUserId) {
      errorLog('[gameSession.ts] saveGame: User not initialized during save. Throwing error.');
      throw new Error("User not initialized.");
    }
    await this.gameRepo.saveGameSnapshot(this.currentUserId, snapshot);
    debugLog(`[gameSession.ts] saveGame: Snapshot ${snapshot.id} saved successfully.`);
  }

  public getCurrentGameSnapshot = () => this.currentSnapshot;
  public getCurrentPromptCard = () => this.currentPromptCard;
  public getCurrentGameState = () => this.currentSnapshot?.gameState || null;
  public getGameLogs = () => this.currentSnapshot?.logs || [];
}

@@FILE: src/logic/gameSessionServices.ts
// src/logic/gameSessionServices.ts
import { GameStateManager } from './GameStateManager.ts';
import { SnapshotUpdater } from './SnapshotUpdater.ts'; // CORRECTED
import { TurnProcessor } from './TurnProcessor.ts';
import { aiClient } from './aiClient.ts';
import { logManager } from './logManager.ts';
import { promptBuilder } from './promptBuilder.ts';

// Instantiate all the core logic services here to be used by GameSession
const gameStateManager = new GameStateManager();
export const snapshotUpdater = new SnapshotUpdater(gameStateManager);
export const turnProcessor = new TurnProcessor(aiClient, promptBuilder, logManager);
@@FILE: src/logic/logManager.ts
// src/logic/logManager.ts

import { DELTA_MARKER } from './deltaParser'; // Import DELTA_MARKER
import type { 
  AiSettings, 
  ParsedNarrationOutput, 
  LogEntry,
  DeltaMap,
  DigestLine, 
  TokenSummary, 
  LogErrorFlag 
} from '../models';

/**
 * Interface defining the contract for the Log Manager.
 */
export interface ILogManager {
 /**
  * Assembles a complete LogEntry for a single turn of the game.
  * This centralizes the logic from TurnLogAssembler and DigestManager.addParsedLines.
  * @param params An object containing all necessary data for the log entry.
  * @returns A fully constructed LogEntry object.
  */
 assembleTurnLogEntry(params: {
  turnNumber: number;
  userInput: string;
  rawNarratorOutput: string;
  parsedOutput: ParsedNarrationOutput; // Output from deltaParser.ts
  contextSnapshot: string; // The full prompt string sent to AI
  tokenUsage: TokenSummary | null;
  aiSettings: AiSettings; // The AI settings used for this turn
  apiRequestBody: string | null;
  apiResponseBody: string | null;
  apiUrl: string | null;
  latencyMs: number | null;
  modelSlugUsed: string;
 }): LogEntry;

 /**
  * Infers digest lines from deltas if no explicit digest was provided by the AI.
  * Replicates logic from DigestManager.addParsedLines.
  * @param deltas The map of DeltaInstruction objects.
  * @param prose Optional: the prose of the turn, for extracting first line as digest.
  * @returns An array of inferred DigestLine objects.
  */
 inferDigestLinesFromDeltas(deltas: DeltaMap, prose?: string): DigestLine[];
}

/**
 * Concrete implementation of ILogManager.
 */
class LogManager implements ILogManager {

 inferDigestLinesFromDeltas(deltas: DeltaMap, prose?: string): DigestLine[] {
  const inferredDigests: DigestLine[] = [];

  if (Object.keys(deltas).length === 0) {
   return inferredDigests;
  }

  for (const rawKey in deltas) {
   const instruction = deltas[rawKey];
   let score = 1; // Default low importance

   // Logic from DigestManager.addParsedLines to infer importance
   if (rawKey.startsWith("player.")) {
    score = 5; // Player-related changes are critical
   } else if (rawKey.startsWith("world.")) {
    score = 5; // World-related changes are critical
   } else if (rawKey.includes(".flags.")) {
    score = 4;
   } else if (rawKey.includes(".status")) {
    score = 3;
   } else if (rawKey.startsWith("+") || rawKey.startsWith("!")) {
    score = 2; // Add or Declare operations
   }

   // Logic from DeltaInstruction.toLogValue() for summary text
   let summaryText = `Unknown delta operation: ${rawKey}`;
   if (instruction.op === 'assign') {
    summaryText = `Set ${instruction.key} = ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'add') {
    summaryText = `Added to ${instruction.key}: ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'declare') {
    // Inferred tag logic, similar to DigestManager
    let taggableKey = instruction.key;
    const pathParts = instruction.key.split(".");
    if (pathParts.length >= 2) {
      const entity = pathParts[1];
      // Infer if this is a character or location declaration for a summary
      const valueAsObject = instruction.value as Record<string, any>;
      if (valueAsObject && (valueAsObject.tag === "character" || valueAsObject.tag === "location")) {
        taggableKey = (valueAsObject.tag === "character" ? "#" : "@") + entity;
      }
    }
    summaryText = `Declared ${taggableKey} as ${JSON.stringify(instruction.value)}`;
   } else if (instruction.op === 'delete') {
    summaryText = `Removed ${instruction.key}`;
   }

  const tags = this.extractTags(summaryText); // Extract tags from the generated summary
    // MODIFIED: Use `importance: score` to match the DigestLine model
   inferredDigests.push({ text: summaryText, importance: score, tags });
  }

  // Optional prose line extraction from DigestManager.addParsedLines
  if (prose && prose.trim().length > 10) {
   const firstLine = prose.trim().split(/[.!?\n]/).find(line => line.trim().length > 10)?.trim();
   if (firstLine) {
    const tags = this.extractTags(firstLine);
      // MODIFIED: Use `importance: 3`
    inferredDigests.push({ text: firstLine, importance: 3, tags });
   }
  }

  // Assign consistent turn number AFTER all are collected
  // MODIFIED: Remove turn property, as it's not in the DigestLine model. It's part of the parent LogEntry.
  return inferredDigests;
}

 private extractTags(text: string): string[] {
  const tagPattern = /[#@$][a-zA-Z0-9_]+/g; // Global flag to find all matches
  const matches = text.match(tagPattern);
  return matches || [];
 }

 assembleTurnLogEntry(params: {
  turnNumber: number;
  userInput: string;
  rawNarratorOutput: string;
  parsedOutput: ParsedNarrationOutput;
  contextSnapshot: string;
  tokenUsage: TokenSummary | null;
  aiSettings: AiSettings;
  apiRequestBody: string | null;
  apiResponseBody: string | null;
  apiUrl: string | null;
  latencyMs: number | null;
  modelSlugUsed: string;
 }): LogEntry {
  const now = new Date().toISOString();
  const {
   turnNumber, userInput, rawNarratorOutput, parsedOutput,
   contextSnapshot, tokenUsage, aiSettings, apiRequestBody,
   apiResponseBody, apiUrl, latencyMs, modelSlugUsed
  } = params;

  let digestLines: DigestLine[] = parsedOutput.digestLines || [];
  if (digestLines.length === 0 && parsedOutput.deltas) {
   // If AI didn't provide digest, infer from deltas
   digestLines = this.inferDigestLinesFromDeltas(parsedOutput.deltas, parsedOutput.prose);
  }
  // Ensure correct turn number for inferred digests
  //digestLines = digestLines.map(d => ({ ...d, turn: turnNumber }));


  const errorFlags: LogErrorFlag[] = [];
  // Basic error checking (can be expanded)
  if (!parsedOutput.prose) {
   errorFlags.push('MISSING_PROSE');
  }
  // Now using DELTA_MARKER imported from deltaParser
  if (parsedOutput.deltas && Object.keys(parsedOutput.deltas).length === 0 && rawNarratorOutput.includes(DELTA_MARKER)) {
    // If the delta marker was present but no deltas were parsed
    errorFlags.push('INVALID_JSON_DELTA');
  }
  if (!tokenUsage || tokenUsage.totalTokens <= 0) {
   errorFlags.push('INVALID_TOKEN_USAGE');
  }
  // Add more validation based on your `LogErrorFlag` enum/sealed class
  // e.g., if (rawNarratorOutput.length < 50) { errorFlags.push('AI_RESPONSE_TOO_SHORT'); }


  return {
   turnNumber: turnNumber,
   timestamp: now,
   userInput: userInput,
   narratorOutput: rawNarratorOutput,
   prose: parsedOutput.prose, // ADDED: Save the clean prose here
   digestLines: digestLines, // Now an array
   deltas: parsedOutput.deltas,
   contextSnapshot: contextSnapshot,
   tokenUsage: tokenUsage,
   apiRequestBody: apiRequestBody,
   apiResponseBody: apiResponseBody,
   apiUrl: apiUrl,
   latencyMs: latencyMs,
   aiSettings: aiSettings,
   errorFlags: errorFlags,
   modelSlugUsed: modelSlugUsed,
  };
 }
}

export const logManager = new LogManager();
@@FILE: src/logic/promptBuilder.ts
// src/logic/promptBuilder.ts
import type { PromptCard, GameState, LogEntry, Message } from '../models';

import type { IContextStackAssembler } from './IContextStackAssembler'; // <-- ADD THIS LINE
import { ContextStackAssembler } from './ContextStackAssembler';   // <-- AND THIS LINE
import { debugLog, errorLog } from '../utils/debug';
import { useSettingsStore } from '../state/useSettingsStore'; // if using hooks in React files


export interface IPromptBuilder {
  buildFirstTurnPrompt(card: PromptCard): Message[];
  buildEveryTurnPrompt(
    card: PromptCard,
    currentGameState: GameState,
    logEntries: LogEntry[],
    conversationHistory: Message[],
    currentUserAction: string,
  ): Message[];
}

export class PromptBuilder implements IPromptBuilder {
  private stackAssembler: IContextStackAssembler;

  constructor() {
    // The builder now owns an instance of the assembler
    this.stackAssembler = new ContextStackAssembler();
  }

  private buildCommonPromptParts(card: PromptCard): Message[] {
    const messages: Message[] = [];
    messages.push({ role: "system", content: `## Core Scenario / Persona\n${card.prompt}` });
    if (card.gameRules) {
      messages.push({ role: "system", content: `\n## Game Rules\n${card.gameRules}` });
    }
    if (card.emitSkeleton) {
      messages.push({ role: "system", content: `\n## AI Output Structure Rules\n${card.emitSkeleton}` });
    }
    if (card.functionDefs) {
      messages.push({ role: "system", content: `\n## Available Functions (JSON)\n\`\`\`json\n${card.functionDefs}\n\`\`\`` });
    }
    return messages;
  }

  public buildFirstTurnPrompt(card: PromptCard): Message[] {
    const messages = this.buildCommonPromptParts(card);

    if (card.worldStateInit) {
      messages.push({ role: "system", content: `\n## Initial World State (JSON)\n\`\`\`json\n${card.worldStateInit}\n\`\`\`` });
    }
    if (card.firstTurnOnlyBlock) {
      messages.push({ role: "system", content: `\n## First Turn Specifics\n${card.firstTurnOnlyBlock}` });
    }

    return messages;
  }

  public buildEveryTurnPrompt(
    card: PromptCard,
    currentGameState: GameState,
    logEntries: LogEntry[],
    conversationHistory: Message[],
    currentUserAction: string,
  ): Message[] {
    // 1. Get the static parts of the prompt
    const messages = this.buildCommonPromptParts(card);

    // 2. Delegate the complex part to the stack assembler
    const dynamicContextMessages = this.stackAssembler.assembleContext(
      card,
      currentGameState,
      logEntries
    );
    messages.push(...dynamicContextMessages);

    // 3. Append conversation history
    messages.push(...conversationHistory);

    // 4. Append the current user's action
    messages.push({ role: "user", content: currentUserAction });

    return messages;
  }
}

// Export a singleton instance for easy use across the app
export const promptBuilder = new PromptBuilder();
@@FILE: src/main.tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css';

// Import the new provider that encapsulates GameSession creation and store initialization
import { GameSessionAndStoreProvider } from './providers/GameSessionAndStoreProvider.tsx';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    {/* Wrap App with the provider */}
    <GameSessionAndStoreProvider>
      <App />
    </GameSessionAndStoreProvider>
  </React.StrictMode>,
);
@@FOLDER: src/models
@@FILE: src/models/AiConnection.ts
// src/models/AiConnection.ts

/**
 * Represents the configuration for a connection to an AI service.
 * Aligns with Android's AiConnection class.
 */
export interface AiConnection {
  id: string; // Unique ID for this connection
  displayName: string; // User-friendly name for the connection (e.g., "My OpenAI Key")
  modelName: string; // The full name of the model (e.g., "GPT-4 Turbo")
  modelSlug: string; // The API identifier for the model (e.g., "gpt-4-turbo", "deepseek-coder")
  apiUrl: string; // The base URL for the API (e.g., "https://api.openai.com/v1/")
  apiToken: string; // The user's API key (sensitive)
  functionCallingEnabled: boolean; // Whether this connection supports/uses function calling
  userAgent?: string | null; // Optional: User-Agent string for API calls (from Android)

  // Metadata
  createdAt: string; // ISO 8601 string
  lastUpdated: string; // ISO 8601 string
}
@@FILE: src/models/DeltaInstruction.ts
// src/models/DeltaInstruction.ts

/**
 * Represents a single instruction to modify the game world state, as per DeltaInstruction.kt.
 * This is a pure data definition, without logic or companion methods.
 * Corresponds to a discriminated union in TypeScript for Kotlin's sealed class.
 *
 * `value: any` corresponds to Kotlin's `JsonElement`, allowing any valid JSON value (string, number, boolean, object, array, null).
 */

export type DeltaInstruction =
  | { op: 'add'; key: string; value: any }      // Corresponds to Add data class
  | { op: 'assign'; key: string; value: any }   // Corresponds to Assign data class
  | { op: 'declare'; key: string; value: any }  // Corresponds to Declare data class
  | { op: 'delete'; key: string };              // Corresponds to Delete data class (no value)

// Helper type for the map of deltas
export type DeltaMap = { [fullKey: string]: DeltaInstruction };
@@FILE: src/models/GameSnapshot.ts
// src/models/GameSnapshot.ts

import type { GameState, LogEntry, Message } from './index';

/**
 * Represents a full, self-contained snapshot of a game session.
 * This is the primary object for saving and loading games.
 * Based on `StoryForgeViewModel.buildSnapshot()`.
 */
export interface GameSnapshot {
  // --- Core Identifiers ---
  id: string; // Unique ID for this snapshot/game session
  userId: string;
  promptCardId: string; // ID of the card used
  title: string; // NEW: A human-readable title for the saved game

  // --- Timestamps ---
  createdAt: string; // When the game session was started
  updatedAt: string; // When this snapshot was last saved

  // --- Core Game State ---
  currentTurn: number;
  gameState: GameState; // Contains worldState, scene, narration
  conversationHistory: Message[]; // Full user/assistant conversation history

  // --- Logs for Context & Debugging ---
  // Note: All "digests" are now just part of the logs.
  // We extract them for context building, but don't store them separately.
  logs: LogEntry[];

  // --- UI Preferences (Persisted with Snapshot) ---
  worldStatePinnedKeys: string[]; // Stores full variable paths, e.g., "npcs.#fox.hp"
}
@@FILE: src/models/GameState.ts
// src/models/GameState.ts

/**
 * Represents the current scene's location and present entities.
 * Corresponds to the state managed by SceneManager.
 */
export interface SceneState {
  location: string | null;
  present: string[]; // List of entity keys, e.g., ["player.#you", "npcs.#fox"]
}

/**
 * Defines the core mutable state of the game.
 * All game variables (like HP, gold) are expected to be dynamic and reside within `worldState`.
 */
export interface GameState {
  narration: string;
  worldState: Record<string, any>; // The dynamic game world
  scene: SceneState; // The current scene state
}
@@FILE: src/models/LogEntry.ts
// src/models/LogEntry.ts

import type { DeltaMap, DigestLine, TokenSummary, LogErrorFlag, AiSettings } from './index';

/**
 * Canonical structured log for a single turn or significant event in the game.
 * Corresponds to TurnLogEntry.kt, enhanced with insights from DigestManager.
 */
export interface LogEntry {
 turnNumber: number;
 timestamp: string;

 userInput: string;
 narratorOutput: string; // The raw, full output from the AI
 prose: string; 

 digestLines: DigestLine[];
 deltas?: DeltaMap | null;

 contextSnapshot?: string | null;
 tokenUsage?: TokenSummary | null;
 apiRequestBody?: string | null;
 apiResponseBody?: string | null;
 apiUrl?: string | null;
 latencyMs?: number | null;

 aiSettings?: AiSettings | null;
 errorFlags: LogErrorFlag[];
 modelSlugUsed: string;
}
@@FILE: src/models/LogEntryElements.ts
// src/models/LogEntryElements.ts

/**
 * Represents a single summary line for the digest, as per DigestLine.kt (implied by TurnLogEntry).
 */
export interface DigestLine {
  text: string;
  importance: number; // 1 (minor) to 5 (critical)
  tags?: string[];    // Optional, e.g., for filtering by specific entities
}

/**
 * Summarizes token usage for an AI call, as per TokenSummary.kt (implied by TurnLogEntry).
 */
export interface TokenSummary {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  cachedTokens?: number; // Optional: If some tokens were served from cache
}

/**
 * Represents a flag for a validation error or issue in the log entry.
 * Based on `LogErrorFlag` (implied enum/sealed class from `TurnLogEntry`).
 */
export type LogErrorFlag =
  | 'MISSING_PROSE'
  | 'MISSING_DELTAS'
  | 'INVALID_JSON_DELTA'
  | 'INVALID_TOKEN_USAGE'
  | 'AI_RESPONSE_TOO_SHORT'
  | 'AI_RESPONSE_TOO_LONG'
  | 'UNEXPECTED_AI_FORMAT'
  | 'API_ERROR'
  | 'UNKNOWN_ERROR';
// Add more flags as needed based on your LogErrorFlag enum/sealed class if it exists.
@@FILE: src/models/Message.ts
// src/models/Message.ts

/**
 * Represents a single message in a conversation with the AI.
 * Corresponds to Message.kt.
 */
export interface Message {
  role: 'system' | 'user' | 'assistant';
  content: string;
}
@@FILE: src/models/ParsedNarrationOutput.ts
// src/models/ParsedNarrationOutput.ts

import type { DeltaMap, DigestLine} from './index';

/**
 * Represents the structured data extracted from a raw AI narrator response.
 * Corresponds to `NarrationParser.ParsedNarration` from the old project.
 *
 * @param prose The clean, human-readable narrative text.
 * @param deltas A map of world state changes to apply.
 * @param digestLines An array of summary lines.
 * @param scene A flexible JSON object describing the current scene (location, present characters, etc.).
 */
export interface ParsedNarrationOutput {
  prose: string;
  deltas: DeltaMap;
  digestLines: DigestLine[];
  scene?: Record<string, any> | null; // Corresponds to the JsonObject? for the @scene block
}
@@FILE: src/models/PromptCard.ts
// src/models/PromptCard.ts

import type { StackInstructions} from './index';
/**
 * Defines the configuration settings for an AI connection.
 * These fields are embedded directly within PromptCard.
 * This is a pure data definition, without logic or companion methods.
 */
export interface AiSettings {
  selectedConnectionId: string;
  temperature: number;
  topP: number;
  maxTokens: number;
  presencePenalty: number;
  frequencyPenalty: number;
  functionCallingEnabled: boolean;
  streaming: boolean; 
}

/**
 * A self-contained prompt card that can be submitted to the AI to configure tone, rules, or scenario.
 * This version consolidates AiSettings and uses a structured StackInstructions object.
 * This is a pure data definition, with no default values or logic.
 */
export interface PromptCard {
  // Web-specific lineage and deduplication fields (as per initial migration plan)
  id: string;
  rootId: string;
  parentId: string | null; // Null for root cards
  contentHash: string; // Hash of significant content fields to detect duplicates

  // Fields directly from old PromptCard.kt
  title: string;
  description: string | null; // Optional in Kotlin, so `string | null`
  prompt: string;
  firstTurnOnlyBlock: string;
  stackInstructions: StackInstructions; // Now a structured object
  emitSkeleton: string;      // JSON string
  worldStateInit: string;    // JSON string
  gameRules: string;
  aiSettings: AiSettings;
  helperAiSettings: AiSettings;
  isHelperAiEnabled: boolean; // NEW: Controls whether helper AI is considered active
  tags: string[];            // Kotlin `List<String>` maps to `string[]`
  isExample: boolean;        // From Kotlin `isExample`
  functionDefs: string;      // JSON string

  // Additional web-specific metadata (as per initial migration plan)
  isPublic: boolean;
  createdAt: string; // ISO 8601 string
  updatedAt: string; // ISO 8601 string
  ownerId: string;   // Firebase User UID
}

/**
 * Represents the raw data needed when creating or updating a PromptCard.
 * This does not include generated fields like IDs, hashes, timestamps, or ownerId,
 * nor does it specify default values for optional fields.
 */
export interface NewPromptCardData {
  title: string;
  prompt: string;
  description?: string | null;
  firstTurnOnlyBlock?: string;
  // This is kept as 'string | StackInstructions' to allow raw JSON string input,
  // with parsing logic to convert it to StackInstructions handled elsewhere (e.g., in logic/cardManager or data repository).
  stackInstructions?: string | StackInstructions;
  emitSkeleton?: string;
  worldStateInit?: string;
  gameRules?: string;
  aiSettings?: AiSettings; // Changed from AiSettingsInCard to AiSettings for consistency
  helperAiSettings?: AiSettings; // Changed from AiSettingsInCard to AiSettings for consistency
  isHelperAiEnabled?: boolean; // NEW: Optional for new card data
  tags?: string[];
  isExample?: boolean;
  functionDefs?: string;
  isPublic?: boolean;
}
@@FILE: src/models/StackInstructions.ts
// src/models/StackInstructions.ts

/**
 * Defines the mode for including a stack element.
 * Now an enum to allow runtime access (e.g., Object.values).
 */
export enum StackMode {
  ALWAYS = 'always',
  FIRST_N = 'firstN',
  AFTER_N = 'afterN',
  NEVER = 'never',
  FILTERED = 'filtered', // Added if 'filtered' applies to modes
}

/**
 * Defines the filtering strategy for a stack element.
 * Now an enum to allow runtime access.
 */
export enum FilterMode {
  NONE = 'none',
  SCENE_ONLY = 'sceneOnly',
  TAGGED = 'tagged',
}

/**
 * Defines a policy for including prose or other list-based context.
 * Corresponds to `ProsePolicy`.
 */
export interface ProsePolicy {
  mode: StackMode; // Use the enum
  n: number;
  filtering: FilterMode; // Use the enum
  enabled?: boolean; // NEW: Added for toggling the entire section
}

/**
 * Defines a rule for emitting digest lines based on their importance score.
 * Corresponds to `EmissionRule`.
 */
export interface EmissionRule {
  mode: StackMode; // Use the enum
  n: number;
}

/**
 * Defines the policy for filtering digest lines.
 * Corresponds to `DigestFilterPolicy`.
 */
export interface DigestFilterPolicy {
  filtering: FilterMode; // Use the enum
  enabled?: boolean; // NEW: Added for toggling the entire section
}

/**
 * Defines the policy for token usage and fallback strategies.
 * Corresponds to `TokenPolicy`.
 */
export interface TokenPolicy {
  minTokens: number;
  maxTokens: number;
  fallbackPlan: string[];
}

/**
 * The full, structured stack instructions for a PromptCard.
 * Corresponds to `StackInstructions.kt`.
 */
export interface StackInstructions {
  narratorProseEmission: ProsePolicy;
  digestPolicy: DigestFilterPolicy;
  digestEmission: Record<number, EmissionRule>; // Map<Int, EmissionRule> -> Record<number, EmissionRule>

  expressionLogPolicy: ProsePolicy;
  expressionLinesPerCharacter: number;
  emotionWeighting: boolean;

  worldStatePolicy: ProsePolicy;
  knownEntitiesPolicy: ProsePolicy;

  // REMOVED: outputFormat: string; // This field is being removed
  tokenPolicy: TokenPolicy;
}
@@FILE: src/models/index.ts
// src/models/index.ts

// Re-export all models for easier importing
export * from './AiConnection';
export * from './DeltaInstruction';
export * from './GameSnapshot';
export * from './GameState.ts';
export * from './LogEntry';
export * from './LogEntryElements';
export * from './Message';
export * from './ParsedNarrationOutput';
export * from './PromptCard';
export * from './StackInstructions';
@@FOLDER: src/pages
@@FILE: src/pages/SourceDump.tsx
import React, { useEffect, useState } from 'react';

const SourceDump: React.FC = () => {
  const [code, setCode] = useState<string>('Loading...');

  useEffect(() => {
    fetch('/source-dump.txt')
      .then(res => res.text())
      .then(text => setCode(text))
      .catch(err => setCode('Error loading source dump: ' + err));
  }, []);

  return (
    <pre style={{
      whiteSpace: 'pre-wrap',
      background: '#1e1e1e',
      color: '#d4d4d4',
      padding: '1rem',
      overflowX: 'auto'
    }}>
      {code}
    </pre>
  );
};

export default SourceDump;

@@FOLDER: src/providers
@@FILE: src/providers/GameSessionAndStoreProvider.tsx
// src/providers/GameSessionAndStoreProvider.tsx
import React, { useRef } from 'react';
import { GameSession } from '../logic/gameSession';
import type { IGameSession } from '../logic/gameSession';
import { gameRepository } from '../data/repositories/gameRepository';
import { promptCardRepository } from '../data/repositories/promptCardRepository';
import { initializeGameStateStore } from '../state/useGameStateStore';
import { GameSessionProvider } from '../contexts/GameSessionContext';

// Import the new centralized service singletons
import { turnProcessor, snapshotUpdater } from '../logic/gameSessionServices';

interface GameSessionAndStoreProviderProps {
  children: React.ReactNode;
}

export const GameSessionAndStoreProvider: React.FC<GameSessionAndStoreProviderProps> = ({ children }) => {
  const gameSessionInstanceRef = useRef<IGameSession | null>(null);

  if (!gameSessionInstanceRef.current) {
    // DEBUG: Log the very first instantiation
    console.log('%c[GameSessionAndStoreProvider.tsx] Instantiating GameSession and Initializing GameStateStore for the first time.', 'color: blue; font-weight: bold;');

    
    // The GameSession constructor is now much cleaner
    gameSessionInstanceRef.current = new GameSession(
      gameRepository,
      promptCardRepository,
      turnProcessor,
      snapshotUpdater
    );

    // DEBUG: Confirm GameSession injection
    initializeGameStateStore(gameSessionInstanceRef.current);
  } else {
    // DEBUG: Log if it's NOT the first time (should happen once per app lifecycle)
    console.log('[GameSessionAndStoreProvider.tsx] Re-rendering, GameSession already instantiated.');
  }   
   
  return (
    <GameSessionProvider gameSession={gameSessionInstanceRef.current}>
      {children}
    </GameSessionProvider>
  );
};
@@FOLDER: src/state
@@FILE: src/state/useAuthStore.ts
// src/state/useAuthStore.ts

import { create } from 'zustand';
import { type User } from 'firebase/auth'; // Import Firebase User type
import { subscribeToAuthChanges, signInWithGoogle, signOutUser } from '../data/repositories/authRepository'; // Import auth functions
import { debugLog, errorLog } from '../utils/debug';

// Define the shape of our authentication state
interface AuthState {
  user: User | null; // The current authenticated user or null
  isLoading: boolean; // True while checking initial auth state
  error: string | null; // Any error during auth operations

  // Actions
  // These are not directly implemented here, but exposed for components to call
  signIn: () => Promise<void>;
  signOut: () => Promise<void>;
}

// Create the Zustand store
export const useAuthStore = create<AuthState>((set, get) => ({
  user: null, // Initial state: no user
  isLoading: true, // Initially loading to check auth state
  error: null, // No error initially

  // Action to handle sign-in
  signIn: async () => {
    debugLog('[useAuthStore.ts] signIn action called.');
    set({ error: null }); // Clear previous errors
    try {
      await signInWithGoogle();
      // The onAuthStateChanged listener will update the 'user' state,
      // so we don't need to manually set it here based on the signIn result.
    } catch (err: any) {
      console.error("[useAuthStore.ts] AuthStore signIn error:", err);
      set({ error: err.message || "Failed to sign in." });
    }
  },

  // Action to handle sign-out
  signOut: async () => {
    debugLog('[useAuthStore.ts] signOut action called.');
    set({ error: null }); // Clear previous errors
    try {
      await signOutUser();
    } catch (err: any) {
      console.error("[useAuthStore.ts] AuthStore signOut error:", err);
      set({ error: err.message || "Failed to sign out." });
    }
  },
}));

// --- Initialize and Subscribe to Auth Changes ---
// This part ensures our store's 'user' state is always in sync with Firebase Auth.
// It runs only once when the module is loaded.
const unsubscribe = subscribeToAuthChanges((user) => {
  // DEBUG: Log exact auth state updates
  useAuthStore.setState({ user: user, isLoading: false });
  debugLog(`%c[useAuthStore.ts] Auth State Updated: ${user ? user.uid : "No user"}, IsLoading: false`, 'color: brown;');
});

// Optional: You might want to handle unsubscription if your app could unmount this module,
// but for a core global store, it often lives for the app's lifetime.
// If you were to integrate this into a React component's useEffect, you'd return the unsubscribe function.
// For a global store, we typically let it live.
@@FILE: src/state/useGameStateStore.ts
// src/state/useGameStateStore.ts

import { create } from 'zustand';
import type {  StoreApi } from 'zustand';
import { useSettingsStore } from './useSettingsStore';
import type { GameSnapshot, GameState, LogEntry, Message } from '../models';
import type { IGameSession } from '../logic/gameSession';
import { debugLog, errorLog } from '../utils/debug';

// Module-level variable to hold the injected GameSession instance
let _gameSessionInstance: IGameSession | null = null;

export const initializeGameStateStore = (gameSession: IGameSession) => {
  if (_gameSessionInstance === null) {
    _gameSessionInstance = gameSession;
    debugLog('%c[useGameStateStore.ts] GameSession instance injected successfully.', 'color: green;');
  } else {
    debugLog('[useGameStateStore.ts] Attempted to re-inject GameSession instance. This should only happen once.');
  }
};

// --- Define State and Actions Interfaces Separately ---
interface GameStateState {
  currentSnapshot: GameSnapshot | null;
  narratorInputText: string;
  narratorScrollPosition: number;
  gameError: string | null;
  gameLoading: boolean; // This should only be true for major loading operations (initial game load, switching games)
  isProcessingTurn: boolean; // This is for AI turn processing, separate from gameLoading
}

interface GameStateActions {
  initializeGame: (userId: string, cardId: string, existingSnapshotId?: string) => Promise<void>;
  processPlayerAction: (action: string) => Promise<void>;
  processFirstNarratorTurn: () => Promise<void>;
  saveGame: () => Promise<void>;
  loadGame: (userId: string, snapshotId: string) => Promise<void>;
  loadLastActiveGame: (userId: string) => Promise<boolean>;
  updateNarratorInputText: (text: string) => void;
  updateNarratorScrollPosition: (position: number) => void;
  renameWorldCategory: (oldName: string, newName: string) => Promise<void>;
  renameWorldEntity: (category: string, oldName: string, newName: string) => Promise<void>;
  deleteWorldCategory: (category: string) => Promise<void>;
  deleteWorldEntity: (category: string, entity: string) => Promise<void>;
  editWorldKeyValue: (key: string, value: any) => Promise<void>;
  deleteWorldKey: (key: string) => Promise<void>;
  toggleWorldStatePin: (keyPath: string, type: 'variable' | 'entity' | 'category') => Promise<void>;
  reset: () => void;
}

// Combine them into the final store type
type GameStateStore = GameStateState & GameStateActions;

// --- Define the initial state ---
const initialState: GameStateState = {
  currentSnapshot: null,
  narratorInputText: '',
  narratorScrollPosition: 0,
  gameError: null,
  gameLoading: false, // Initial state: not loading
  isProcessingTurn: false,
};

// --- Create the store with separated actions ---
export const useGameStateStore = create<GameStateStore>((set, get) => {
  const getGameSession = (): IGameSession => {
    if (!_gameSessionInstance) {
      errorLog('%c[useGameStateStore.ts] CRITICAL ERROR: GameSession instance is NULL when getGameSession() called!', 'color: red; font-weight: bold;');
      throw new Error("Game session instance not initialized.");
    }
    return _gameSessionInstance;
  };

    // Helper to sync state from a snapshot
    const syncStateWithSnapshot = (snapshot: GameSnapshot | null) => {
      // DEBUG: Log every time currentSnapshot is updated
      // Removed gameLoading from this log as it's being de-coupled for minor updates
      debugLog(`%c[useGameStateStore.ts] syncStateWithSnapshot: Updating currentSnapshot to ${snapshot ? snapshot.id : 'null'}. isProcessingTurn: ${get().isProcessingTurn}`, 'color: dodgerblue;');
      set({ currentSnapshot: snapshot });
      // After setting the snapshot, let's verify immediately
      const verifySnapshot = get().currentSnapshot;
      debugLog(`%c[useGameStateStore.ts] syncStateWithSnapshot: currentSnapshot is now ${verifySnapshot ? verifySnapshot.id : 'null'}.`, 'color: dodgerblue;');
  };

  const performWorldStateUpdate = async (updateFn: (session: IGameSession) => Promise<GameSnapshot | null>) => {
    // DEBUG: Log start of any world state modification action
    debugLog('%c[useGameStateStore.ts] performWorldStateUpdate: Starting a world state modification.', 'color: purple;');
    // It's crucial NOT to set gameLoading: true here, as this is for minor UI updates.
    // AuthOrchestrator relies on gameLoading only for major app-level loads.
    set({ gameError: null });
    try {
        const session = getGameSession();
        const updatedSnapshot = await updateFn(session);
        syncStateWithSnapshot(updatedSnapshot);
    } catch (error: any) {
        errorLog("[useGameStateStore.ts] performWorldStateUpdate: Error during update:", error);
        set({ gameError: error.message });
    } finally {
        // This is a crucial safety measure. Even if `gameLoading` wasn't explicitly set to `true`
        // by this function, ensuring it's `false` here guarantees the global loading screen
        // is dismissed after any world state modification.
        set({ gameLoading: false });
        debugLog('[useGameStateStore.ts] performWorldStateUpdate: Finished a world state modification.');
    }
  };


    // Return the state AND actions. Actions are defined here once.
    return {
        ...initialState,

        initializeGame: async (userId, cardId, existingSnapshotId) => {
          debugLog(`[useGameStateStore.ts] initializeGame action: userId=${userId}, cardId=${cardId}, existingSnapshotId=${existingSnapshotId}`);
          set({ gameLoading: true, gameError: null }); // Set gameLoading for this major operation
          try {
            const gameSession = getGameSession();
            await gameSession.initializeGame(userId, cardId, existingSnapshotId);
            syncStateWithSnapshot(gameSession.getCurrentGameSnapshot());
          } catch (error: any) {
            errorLog("[useGameStateStore.ts] initializeGame action ERROR:", error);
            set({ gameError: error.message });
          } finally {
            set({ gameLoading: false }); // Reset gameLoading regardless of success/failure
          }
        },

        processFirstNarratorTurn: async () => {
          debugLog('[useGameStateStore.ts] processFirstNarratorTurn action started.');
          set({ isProcessingTurn: true, gameError: null });
          const useDummyNarrator = useSettingsStore.getState().useDummyNarrator;
          try {
            const gameSession = getGameSession();
            const updatedSnapshot = await gameSession.processFirstNarratorTurn(useDummyNarrator);
            syncStateWithSnapshot(updatedSnapshot);
          } catch (error: any) {
             errorLog("[useGameStateStore.ts] processFirstNarratorTurn action ERROR:", error);
             set({ gameError: error.message });
          } finally {
            set({ isProcessingTurn: false });
            debugLog('[useGameStateStore.ts] processFirstNarratorTurn action finished.');
          }
        },

        processPlayerAction: async (action) => {
          debugLog(`[useGameStateStore.ts] processPlayerAction action started. Action: "${action}"`);
          set({ isProcessingTurn: true, gameError: null, narratorInputText: '' });
          const useDummyNarrator = useSettingsStore.getState().useDummyNarrator;
          try {
            const gameSession = getGameSession();
            const updatedSnapshot = await gameSession.processPlayerAction(action, useDummyNarrator);
            syncStateWithSnapshot(updatedSnapshot);
          } catch (error: any) {
            errorLog("[useGameStateStore.ts] processPlayerAction action ERROR:", error);
            set({ gameError: error.message });
          } finally {
             set({ isProcessingTurn: false });
             debugLog('[useGameStateStore.ts] processPlayerAction action finished.');
          }
        },

        saveGame: async () => {
          debugLog('[useGameStateStore.ts] saveGame action called.');
          const { currentSnapshot } = get();
          if (!currentSnapshot) {
            debugLog('[useGameStateStore.ts] saveGame action: No currentSnapshot to save.');
            return;
          }
          try {
            await getGameSession().saveGame(currentSnapshot);
            debugLog(`[useGameStateStore.ts] saveGame action: Snapshot ${currentSnapshot.id} saved.`);
          } catch (error: any) {
            errorLog("[useGameStateStore.ts] saveGame action ERROR:", error);
            set({ gameError: error.message });
          }
        },
        
        loadGame: async (userId, snapshotId) => {
            debugLog(`[useGameStateStore.ts] loadGame action: userId=${userId}, snapshotId=${snapshotId}`);
            set({ gameLoading: true, gameError: null }); // Set gameLoading for this major operation
            try {
                const gameSession = getGameSession();
                await gameSession.loadGame(userId, snapshotId);
                syncStateWithSnapshot(gameSession.getCurrentGameSnapshot());
            } catch (error: any) {
                errorLog("[useGameStateStore.ts] loadGame action ERROR:", error);
                set({ gameError: error.message });
            } finally {
                set({ gameLoading: false }); // Reset gameLoading regardless of success/failure
                debugLog('[useGameStateStore.ts] loadGame action finished.');
            }
        },

        loadLastActiveGame: async (userId: string): Promise<boolean> => {
            debugLog('%c[useGameStateStore.ts] loadLastActiveGame action called.', 'color: blue; font-weight: bold;');
            set({ gameLoading: true, gameError: null }); // Set gameLoading for this major operation
            try {
                const gameSession = getGameSession();
                const gameLoaded = await gameSession.loadLastActiveGame(userId);
                // DEBUG: Check what gameSession.getCurrentGameSnapshot() returns immediately after load
                const snapshotAfterLoad = gameSession.getCurrentGameSnapshot();
                debugLog(`%c[useGameStateStore.ts] gameSession.getCurrentGameSnapshot() after loadLastActiveGame: ${snapshotAfterLoad ? snapshotAfterLoad.id : 'null'}`, 'color: blue;');
                
                syncStateWithSnapshot(snapshotAfterLoad); // Use the snapshot directly from session
                debugLog(`%c[useGameStateStore.ts] loadLastActiveGame action finished. Game loaded: ${gameLoaded}`, 'color: blue; font-weight: bold;');
                return gameLoaded;
            } catch (error: any) {
                errorLog("%c[useGameStateStore.ts] loadLastActiveGame action FAILED with error:", 'color: red; font-weight: bold;', error);
                set({ gameError: error.message });
                return false;
            } finally {
                set({ gameLoading: false }); // Reset gameLoading regardless of success/failure
            }
        },

        updateNarratorInputText: (text) => {
          // DEBUG: Log input text changes if not too frequent
          // debugLog(`[useGameStateStore.ts] updateNarratorInputText: "${text.substring(0, 30)}..."`);
          set({ narratorInputText: text });
        },
        updateNarratorScrollPosition: (position) => {
          // DEBUG: Log scroll position changes
          // debugLog(`[useGameStateStore.ts] updateNarratorScrollPosition: ${position}`);
          set({ narratorScrollPosition: position });
        },

        renameWorldCategory: (oldName, newName) => performWorldStateUpdate(session => session.renameWorldCategory(oldName, newName)),
        renameWorldEntity: (category, oldName, newName) => performWorldStateUpdate(session => session.renameWorldEntity(category, oldName, newName)),
        deleteWorldCategory: (category) => performWorldStateUpdate(session => session.deleteWorldCategory(category)),
        deleteWorldEntity: (category, entity) => performWorldStateUpdate(session => session.deleteWorldEntity(category, entity)),
        editWorldKeyValue: (key, value) => performWorldStateUpdate(session => session.editWorldKeyValue(key, value)),
        deleteWorldKey: (key) => performWorldStateUpdate(session => session.deleteWorldKey(key)),
        toggleWorldStatePin: (key, type) => performWorldStateUpdate(session => session.toggleWorldStatePin(key, type)),

        reset: () => {
          debugLog('%c[useGameStateStore.ts] RESETTING GameStateStore to initialState.', 'color: red; font-weight: bold;');
          set(initialState);
        },
    };
});


// --- Selectors ---
// DEBUG: Log when selectors are accessed. Be careful, this can be noisy.
export const selectCurrentGameState = (state: GameStateStore): GameState | null => {
  const gameState = state.currentSnapshot?.gameState ?? null;
  // debugLog(`[useGameStateStore.ts] Selector: selectCurrentGameState. State ID: ${state.currentSnapshot?.id || 'null'}. GameState: ${gameState ? 'present' : 'null'}`);
  return gameState;
};
export const selectGameLogs = (state: GameStateStore): LogEntry[] => {
  const logs = state.currentSnapshot?.logs ?? [];
  // debugLog(`[useGameStateStore.ts] Selector: selectGameLogs. State ID: ${state.currentSnapshot?.id || 'null'}. Logs Count: ${logs.length}`);
  return logs;
};
export const selectConversationHistory = (state: GameStateStore): Message[] => {
  const history = state.currentSnapshot?.conversationHistory ?? [];
  // debugLog(`[useGameStateStore.ts] Selector: selectConversationHistory. State ID: ${state.currentSnapshot?.id || 'null'}. History Count: ${history.length}`);
  return history;
};
export const selectWorldStatePinnedKeys = (state: GameStateStore): string[] => {
  const pinnedKeys = state.currentSnapshot?.worldStatePinnedKeys ?? [];
  // debugLog(`[useGameStateStore.ts] Selector: selectWorldStatePinnedKeys. State ID: ${state.currentSnapshot?.id || 'null'}. Pinned Keys Count: ${pinnedKeys.length}`);
  return pinnedKeys;
};
@@FILE: src/state/useLogStore.ts
// src/state/useLogStore.ts

import { create } from 'zustand';
import { LogViewMode } from '../utils/types'; // We'll define LogViewMode here
import type { LogEntry } from '../models';
import { debugLog, errorLog } from '../utils/debug';

const initialState = {
  logEntries: [],
  isLoading: false,
  error: null,
};

interface LogState {
  logEntries: LogEntry[];
  selectedLogViewModes: LogViewMode[];
  isLoading: boolean;
  error: string | null;

  // Actions
  setLogEntries: (entries: LogEntry[]) => void; // To be called by useGameStateStore after a turn
  setSelectedLogViewModes: (modes: LogViewMode[]) => void;
  // Potentially fetch logs if we implement persistent log storage separate from GameSnapshot
  fetchLogs: (snapshotId: string) => Promise<void>;
  reset: () => void;
}

export const useLogStore = create<LogState>((set, get) => ({
  logEntries: [],
  selectedLogViewModes: [LogViewMode.NARRATOR_OUTPUT, LogViewMode.USER_INPUT, LogViewMode.DIGEST_LINES], // Default selection
  isLoading: false,
  error: null,

  setLogEntries: (entries) => set({ logEntries: entries }),

  setSelectedLogViewModes: (modes) => set({ selectedLogViewModes: modes }),

  fetchLogs: async (snapshotId) => {
    set({ isLoading: true, error: null });
    try {
      // In MVP, logs are part of GameSnapshot. So this would primarily
      // fetch the GameSnapshot and then extract its logs.
      // E.g., const snapshot = await gameRepository.getGameSnapshot(userId, snapshotId);
      // set({ logEntries: snapshot?.logs || [], isLoading: false });
      set({ isLoading: false }); // Placeholder
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error fetching logs:", error);
    }
  },
  reset: () => {
    debugLog("Resetting LogStore.");
    set(initialState);
  },
}));
@@FILE: src/state/usePromptCardStore.ts
// src/state/usePromptCardStore.ts

import { create } from 'zustand';
import type { PromptCard, NewPromptCardData, AiConnection } from '../models'; // Assuming index.ts exports these
import { promptCardManager } from '../logic/cardManager';
import { gameRepository } from '../data/repositories/gameRepository'; // For AI Connections
import { debugLog, errorLog } from '../utils/debug';

const initialState = {
  promptCards: [],
  activePromptCard: null,
  isLoading: false,
  error: null,
};

interface PromptCardState {
  promptCards: PromptCard[];
  activePromptCard: PromptCard | null;
  aiConnections: AiConnection[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchPromptCards: (userId: string) => Promise<void>;
  setActivePromptCard: (card: PromptCard | null) => void;
  addPromptCard: (userId: string, cardData: NewPromptCardData) => Promise<PromptCard | null>;
  updatePromptCard: (userId: string, cardId: string, updates: Partial<PromptCard>) => Promise<PromptCard | null>;
  duplicatePromptCard: (userId: string, cardId: string) => Promise<PromptCard | null>;
  deletePromptCard: (userId: string, cardId: string) => Promise<void>;
  fetchAiConnections: (userId: string) => Promise<void>;
  // Import/Export functionality will go here eventually
  importPromptCards: (userId: string, cards: NewPromptCardData[]) => Promise<PromptCard[]>;
  exportPromptCard: (userId: string, cardId: string) => Promise<PromptCard | null>;
  reset: () => void;
}

export const usePromptCardStore = create<PromptCardState>((set, get) => ({
  promptCards: [],
  activePromptCard: null,
  aiConnections: [],
  isLoading: false,
  error: null,

  fetchPromptCards: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const cards = await promptCardManager.getAllPromptCards(userId);
      set({ promptCards: cards, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error fetching prompt cards:", error);
    }
  },

  setActivePromptCard: (card) => {
    set({ activePromptCard: card });
  },

  addPromptCard: async (userId, cardData) => {
    set({ isLoading: true, error: null });
    try {
      const newCard = await promptCardManager.createNewPromptCard(userId, cardData);
      set((state) => ({
        promptCards: [...state.promptCards, newCard],
        isLoading: false,
      }));
      return newCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error adding prompt card:", error);
      return null;
    }
  },

  updatePromptCard: async (userId, cardId, updates) => {
    set({ isLoading: true, error: null });
    try {
      const updatedCard = await promptCardManager.updatePromptCard(userId, cardId, updates);
      if (updatedCard) {
        set((state) => ({
          promptCards: state.promptCards.map(card => card.id === updatedCard.id ? updatedCard : card),
          activePromptCard: state.activePromptCard?.id === updatedCard.id ? updatedCard : state.activePromptCard,
          isLoading: false,
        }));
      }
      return updatedCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error updating prompt card:", error);
      return null;
    }
  },

  duplicatePromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      const duplicatedCard = await promptCardManager.duplicatePromptCard(userId, cardId);
      if (duplicatedCard) {
        set((state) => ({
          promptCards: [...state.promptCards, duplicatedCard],
          isLoading: false,
        }));
      }
      return duplicatedCard;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error duplicating prompt card:", error);
      return null;
    }
  },

  deletePromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      await promptCardManager.deletePromptCard(userId, cardId);
      set((state) => ({
        promptCards: state.promptCards.filter(card => card.id !== cardId),
        activePromptCard: state.activePromptCard?.id === cardId ? null : state.activePromptCard,
        isLoading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error deleting prompt card:", error);
    }
  },

  fetchAiConnections: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const connections = await gameRepository.getAiConnections(userId);
      set({ aiConnections: connections, isLoading: false });
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error fetching AI connections:", error);
    }
  },

  importPromptCards: async (userId, cards) => {
    set({ isLoading: true, error: null });
    try {
      const imported = await promptCardManager.importPromptCards(userId, cards);
      set((state) => ({
        promptCards: [...state.promptCards, ...imported],
        isLoading: false,
      }));
      return imported;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error importing prompt cards:", error);
      return [];
    }
  },

  exportPromptCard: async (userId, cardId) => {
    set({ isLoading: true, error: null });
    try {
      const exported = await promptCardManager.exportPromptCard(userId, cardId);
      set({ isLoading: false });
      return exported;
    } catch (error: any) {
      set({ error: error.message, isLoading: false });
      errorLog("Error exporting prompt card:", error);
      return null;
    }
  },

  reset: () => {
    debugLog("Resetting PromptCardStore.");
    set(initialState);
  },
}));
@@FILE: src/state/useSettingsStore.ts
// src/state/useSettingsStore.ts

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import type { AiConnection } from '../models';
import { gameRepository } from '../data/repositories/gameRepository';
import { generateUuid } from '../utils/uuid';
import { debugLog } from '../utils/debug'; // <-- NEW

interface SettingsState {
  aiConnections: AiConnection[];
  selectedConnectionId: string | null;
  isLoadingConnections: boolean;
  connectionsError: string | null;
  useDummyNarrator: boolean;
  themeMode: 'light' | 'dark';
  enableDebugLogging: boolean;              // <-- NEW
  textGenerationSpeedMs: number;            // <-- NEW

  fetchAiConnections: (userId: string) => Promise<void>;
  addAiConnection: (
    userId: string,
    connection: Omit<AiConnection, 'id' | 'createdAt' | 'lastUpdated'>
  ) => Promise<AiConnection | null>;
  updateAiConnection: (
    userId: string,
    connection: AiConnection
  ) => Promise<AiConnection | null>;
  deleteAiConnection: (userId: string, connectionId: string) => Promise<void>;

  setSelectedConnectionId: (id: string | null) => void;
  setUseDummyNarrator: (enabled: boolean) => void;
  setThemeMode: (mode: 'light' | 'dark') => void;
  setEnableDebugLogging: (enabled: boolean) => void;     // <-- NEW
  setTextGenerationSpeedMs: (speed: number) => void;     // <-- NEW
  reset: () => void;
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set, get) => ({
      // --- Initial State Values ---
      aiConnections: [],
      selectedConnectionId: null,
      isLoadingConnections: false,
      connectionsError: null,
      useDummyNarrator: false,
      themeMode: 'light',
      enableDebugLogging: false,             // <-- NEW
      textGenerationSpeedMs: 20,             // <-- NEW

      // --- Actions ---
      fetchAiConnections: async (userId) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const connections = await gameRepository.getAiConnections(userId);
          set({
            aiConnections: connections,
            isLoadingConnections: false,
            selectedConnectionId: get().selectedConnectionId &&
              connections.some(c => c.id === get().selectedConnectionId)
              ? get().selectedConnectionId
              : (connections.length > 0 ? connections[0].id : null)
          });
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
        }
      },

      addAiConnection: async (userId, newConnectionData) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const newId = generateUuid();
          const now = new Date().toISOString();
          const connection: AiConnection = {
            ...newConnectionData,
            id: newId,
            createdAt: now,
            lastUpdated: now,
          };
          await gameRepository.saveAiConnection(userId, connection);
          set(state => {
            const updatedConnections = [...state.aiConnections, connection].sort((a, b) =>
              a.displayName.localeCompare(b.displayName)
            );
            return {
              aiConnections: updatedConnections,
              isLoadingConnections: false,
              selectedConnectionId: state.selectedConnectionId || newId,
            };
          });
          return connection;
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          return null;
        }
      },

      updateAiConnection: async (userId, updatedConnection) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          const now = new Date().toISOString();
          const connectionToSave = { ...updatedConnection, lastUpdated: now };
          await gameRepository.saveAiConnection(userId, connectionToSave);
          set(state => {
            const updatedConnections = state.aiConnections.map(conn =>
              conn.id === updatedConnection.id ? connectionToSave : conn
            ).sort((a, b) => a.displayName.localeCompare(b.displayName));
            return {
              aiConnections: updatedConnections,
              isLoadingConnections: false,
            };
          });
          return connectionToSave;
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
          return null;
        }
      },

      deleteAiConnection: async (userId, connectionId) => {
        set({ isLoadingConnections: true, connectionsError: null });
        try {
          await gameRepository.deleteAiConnection(userId, connectionId);
          set(state => {
            const updatedConnections = state.aiConnections.filter(conn => conn.id !== connectionId);
            let newSelectedId = state.selectedConnectionId;
            if (newSelectedId === connectionId) {
              newSelectedId = updatedConnections.length > 0 ? updatedConnections[0].id : null;
            }
            return {
              aiConnections: updatedConnections.sort((a, b) =>
                a.displayName.localeCompare(b.displayName)
              ),
              selectedConnectionId: newSelectedId,
              isLoadingConnections: false,
            };
          });
        } catch (error: any) {
          set({ connectionsError: error.message, isLoadingConnections: false });
        }
      },

      setSelectedConnectionId: (id) => set({ selectedConnectionId: id }),
      setUseDummyNarrator: (enabled) => set({ useDummyNarrator: enabled }),
      setThemeMode: (mode) => set({ themeMode: mode }),
      setEnableDebugLogging: (enabled) => set({ enableDebugLogging: enabled }), // <-- NEW
      setTextGenerationSpeedMs: (speed) => set({ textGenerationSpeedMs: speed }), // <-- NEW

      reset: () => {
        debugLog("Resetting SettingsStore."); //  Replaces console.log
        set({
          aiConnections: [],
          isLoadingConnections: false,
          connectionsError: null,
        });
      },
    }),
    {
      name: 'storyforge-app-settings',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        selectedConnectionId: state.selectedConnectionId,
        useDummyNarrator: state.useDummyNarrator,
        themeMode: state.themeMode,
        enableDebugLogging: state.enableDebugLogging,         // <-- NEW
        textGenerationSpeedMs: state.textGenerationSpeedMs,   // <-- NEW
      }),
    }
  )
);

@@FOLDER: src/theme
@@FILE: src/theme/index.ts
// src/theme/index.ts
import { createTheme } from '@mui/material/styles';

/* --------------------------
   BRAND & COLOR VARIABLES
   -------------------------- */

// Backgrounds - Light
const BG_LIGHT_DEFAULT = '#FAFAFA'; // soft warm white
const BG_LIGHT_PAPER = '#FFFFFF';   // pure white

// Backgrounds - Dark
const BG_DARK_DEFAULT = '#121212';  // deep black
const BG_DARK_PAPER = '#1E1E1E';    // dark grey

// Text - Light
const TEXT_LIGHT_PRIMARY = '#1A1A1A'; // rich near-black
const TEXT_LIGHT_SECONDARY = '#555555'; // medium grey

// Text - Dark
const TEXT_DARK_PRIMARY = '#F5F5F5'; // soft white
const TEXT_DARK_SECONDARY = '#BBBBBB'; // medium light grey

// Primary Accent (actions, highlights)
const BRAND_PRIMARY_LIGHT = '#A84300'; // muted burnt orange
const BRAND_PRIMARY_DARK = '#FF8C42';  // warm muted orange

// Secondary Accent
const BRAND_SECONDARY_LIGHT = '#8B5E3C'; // warm brown
const BRAND_SECONDARY_DARK = '#D4A373';  // warm beige

// Dividers
const DIVIDER_LIGHT = '#E0E0E0';
const DIVIDER_DARK = '#333333';

// Custom UI colors
const PINNED_ENTITY_LIGHT = 'rgba(168, 67, 0, 0.85)'; // burnt orange translucent
// Much darker burnt orange, less opacity
const PINNED_ENTITY_DARK = 'rgba(140, 80, 40, 0.4)';


const CHIP_BG_LIGHT = 'rgba(255,255,255,0.7)';
const CHIP_BG_DARK = 'rgba(0,0,0,0.4)';

// Frosted translucency
const FROSTED_LIGHT = 'rgba(255,255,255,0.6)';
const FROSTED_DARK = 'rgba(30,30,30,0.4)';



/* --------------------------
   THEME EXTENSIONS
   -------------------------- */
declare module '@mui/material/styles' {
  interface Palette {
    pinnedEntity: Palette['primary'];
    chipBackground: Palette['primary'];
    frostedSurface: { light: string; dark: string };
  }
  interface PaletteOptions {
    pinnedEntity?: PaletteOptions['primary'];
    chipBackground?: PaletteOptions['primary'];
    frostedSurface?: { light: string; dark: string };
  }
}

/* --------------------------
   THEME FACTORY
   -------------------------- */
export const getAppTheme = (mode: 'light' | 'dark') => {
  const isLight = mode === 'light';

  return createTheme({
    palette: {
      mode,
      primary: {
        main: isLight ? BRAND_PRIMARY_LIGHT : BRAND_PRIMARY_DARK,
      },
      secondary: {
        main: isLight ? BRAND_SECONDARY_LIGHT : BRAND_SECONDARY_DARK,
      },
      background: {
        default: isLight ? BG_LIGHT_DEFAULT : BG_DARK_DEFAULT,
        paper: isLight ? BG_LIGHT_PAPER : BG_DARK_PAPER,
      },
      text: {
        primary: isLight ? TEXT_LIGHT_PRIMARY : TEXT_DARK_PRIMARY,
        secondary: isLight ? TEXT_LIGHT_SECONDARY : TEXT_DARK_SECONDARY,
      },

      // Custom palette extensions
      pinnedEntity: {
        main: isLight ? PINNED_ENTITY_LIGHT : PINNED_ENTITY_DARK
      },
      chipBackground: {
        main: isLight ? CHIP_BG_LIGHT : CHIP_BG_DARK,
      },
      frostedSurface: {
        light: FROSTED_LIGHT,
        dark: FROSTED_DARK,
      },
    },

    shape: {
      borderRadius: 8,
    },

    typography: {
      fontFamily: `"Roboto", "Arial", sans-serif`,
      h6: { fontWeight: 600 },
    },

    components: {
      MuiPaper: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiCard: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiDialog: {
        styleOverrides: {
          paper: ({ theme }) => ({
            backgroundColor: theme.palette.background.paper,
            border: `1px solid ${theme.palette.divider}`,
          }),
        },
      },
      MuiChip: {
        styleOverrides: {
          root: ({ theme }) => ({
            backgroundColor: theme.palette.chipBackground.main,
            color: theme.palette.text.primary,
          }),
        },
      },
      MuiButton: {
        styleOverrides: {
          root: () => ({
            borderRadius: 8,
          }),
        },
      },
    },
  });
};

@@FOLDER: src/ui
@@FOLDER: src/ui/components
@@FILE: src/ui/components/AiSettingsEditor.tsx
// src/ui/components/AiSettingsEditor.tsx

import React from 'react';
import {
  Box,
  Typography,
  Slider,
  Switch,
  FormControlLabel,
  Divider,
  TextField,
  MenuItem,
} from '@mui/material';
import type { AiSettings, AiConnection } from '../../models/index';
import { CollapsibleSection } from './CollapsibleSection';

interface AiSettingsEditorProps {
  label: string;
  settings: AiSettings;
  onSettingsChange: (updatedSettings: AiSettings) => void;
  availableConnections: AiConnection[];
}

export const AiSettingsEditor: React.FC<AiSettingsEditorProps> = ({
  label,
  settings,
  onSettingsChange,
  availableConnections,
}) => {
  const handleSliderChange = (
    prop: keyof AiSettings,
    newValue: number | number[]
  ) => {
    onSettingsChange({ ...settings, [prop]: newValue as number });
  };

  const handleSwitchChange = (prop: keyof AiSettings, checked: boolean) => {
    onSettingsChange({ ...settings, [prop]: checked });
  };

  const handleConnectionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onSettingsChange({ ...settings, selectedConnectionId: event.target.value });
  };

  return (
    <CollapsibleSection title={label} initiallyExpanded={false}>
      <TextField
        select
        fullWidth
        label="AI Connection"
        value={settings.selectedConnectionId}
        onChange={handleConnectionChange}
        variant="outlined"
        sx={{ mb: 2 }}
      >
        {availableConnections.map((conn) => (
          <MenuItem key={conn.id} value={conn.id}>
            {conn.modelName} ({conn.id})
          </MenuItem>
        ))}
      </TextField>

      <Typography gutterBottom>
        Temperature: {settings.temperature.toFixed(2)}
      </Typography>
      <Slider
        value={settings.temperature}
        onChange={(_e, val) => handleSliderChange('temperature', val)}
        min={0.0}
        max={1.5}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls randomness. Low = logical, high = creative. RPG-optimal:
        0.71.0.
      </Typography>

      <Typography gutterBottom>Top P: {settings.topP.toFixed(2)}</Typography>
      <Slider
        value={settings.topP}
        onChange={(_e, val) => handleSliderChange('topP', val)}
        min={0.0}
        max={1.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Controls diversity. Lower = focused, higher = expressive. RPG-optimal:
        0.81.0.
      </Typography>

      <Typography gutterBottom>Max Tokens: {settings.maxTokens}</Typography>
      <Slider
        value={settings.maxTokens}
        onChange={(_e, val) => handleSliderChange('maxTokens', val)}
        min={256}
        max={8192}
        step={256}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Maximum length of AI reply. Longer = more story depth. RPG-optimal:
        10244096.
      </Typography>

      <Typography gutterBottom>
        Presence Penalty: {settings.presencePenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.presencePenalty}
        onChange={(_e, val) => handleSliderChange('presencePenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages introducing new topics repeatedly. RPG-optimal: 0.00.5.
      </Typography>

      <Typography gutterBottom>
        Frequency Penalty: {settings.frequencyPenalty.toFixed(2)}
      </Typography>
      <Slider
        value={settings.frequencyPenalty}
        onChange={(_e, val) => handleSliderChange('frequencyPenalty', val)}
        min={-2.0}
        max={2.0}
        step={0.01}
        valueLabelDisplay="auto"
      />
      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
        Discourages repeating phrases. Helps avoid spam. RPG-optimal: 0.20.8.
      </Typography>

      <Divider sx={{ my: 2 }} />

      <FormControlLabel
        control={
          <Switch
            checked={settings.functionCallingEnabled}
            onChange={(e) =>
              handleSwitchChange('functionCallingEnabled', e.target.checked)
            }
          />
        }
        label="Enable Function Calling"
      />
      <Typography variant="body2" color="text.secondary">
        Allows AI to call structured functions (if you've defined them in the
        prompt).
      </Typography>

      <FormControlLabel
        control={
          <Switch
            checked={settings.streaming} // RENAMED
            onChange={(e) =>
              handleSwitchChange('streaming', e.target.checked) // RENAMED
            }
          />
        }
        label="Enable Streaming Output" // UPDATED LABEL
      />
      <Typography variant="body2" color="text.secondary">
        Displays AI-generated narrative text as it's generated (typing effect).
      </Typography>
    </CollapsibleSection>
  );
};
@@FILE: src/ui/components/AuthOrchestrator.tsx
// src/ui/components/AuthOrchestrator.tsx
import React, { useState, useEffect, useRef } from 'react';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useNavigate, useLocation, Outlet } from 'react-router-dom';
import { Box, CircularProgress, Typography } from '@mui/material';

const AuthOrchestrator: React.FC = () => {
  console.log('%c[AuthOrchestrator.tsx] Component rendering.', 'color: green;');

  const { user } = useAuthStore();
  const gameLoading = useGameStateStore(state => state.gameLoading); 
  const navigate = useNavigate();
  const location = useLocation();
  const initialLoadAttempted = useRef(false);

  // Capture current action references for debugging useEffect dependencies
  const loadLastActiveGameAction = useGameStateStore(state => state.loadLastActiveGame);
  const userRef = useRef(user);
  const gameLoadingRef = useRef(gameLoading);
  const locationPathnameRef = useRef(location.pathname);


  useEffect(() => {
    // DEBUG: Log dependency changes
    console.log('%c[AuthOrchestrator.tsx] useEffect triggered.', 'color: blue;');
    if (userRef.current !== user) console.log(`[AuthOrchestrator.tsx] useEffect dependency change: user from ${userRef.current?.uid || 'null'} to ${user?.uid || 'null'}`);
    if (gameLoadingRef.current !== gameLoading) console.log(`[AuthOrchestrator.tsx] useEffect dependency change: gameLoading from ${gameLoadingRef.current} to ${gameLoading}`);
    if (locationPathnameRef.current !== location.pathname) console.log(`[AuthOrchestrator.tsx] useEffect dependency change: location.pathname from ${locationPathnameRef.current} to ${location.pathname}`);
    
    // Update refs for next comparison
    userRef.current = user;
    gameLoadingRef.current = gameLoading;
    locationPathnameRef.current = location.pathname;


    // Logic to prevent re-attempts for game loading
    if (user && !initialLoadAttempted.current) {
      initialLoadAttempted.current = true; // Mark that we are attempting this load
      
      console.log(`%c[AuthOrchestrator.tsx] Authenticated user (${user.uid}), attempting initial game load.`, 'color: orange; font-weight: bold;');

      loadLastActiveGameAction(user.uid).then((gameLoaded) => {
        console.log(`%c[AuthOrchestrator.tsx] loadLastActiveGameAction resolved. Game loaded: ${gameLoaded}. Current path: ${location.pathname}`, 'color: orange;');
        if (location.pathname === '/') {
          if (gameLoaded) {
            console.log('[AuthOrchestrator.tsx] Navigating to /game');
            navigate('/game', { replace: true });
          } else {
            console.log('[AuthOrchestrator.tsx] Navigating to /library (no game loaded)');
            navigate('/library', { replace: true });
          }
        } else {
             console.log(`[AuthOrchestrator.tsx] Not navigating from non-root path: ${location.pathname}`);
        }
      }).catch((error) => {
          console.error("[AuthOrchestrator.tsx] Error during loadLastActiveGameAction:", error);
          if (location.pathname === '/') {
              navigate('/library', { replace: true });
          }
      });
    } else if (!user && initialLoadAttempted.current) {
        // If user logs out and we had previously attempted to load, reset the flag.
        console.log('[AuthOrchestrator.tsx] User logged out, resetting initialLoadAttempted flag.');
        initialLoadAttempted.current = false;
    } else {
        console.log('[AuthOrchestrator.tsx] useEffect: No user or initialLoadAttempted already true. Skipping load logic.');
    }
  }, [user, gameLoading, location.pathname, navigate, loadLastActiveGameAction]); // loadLastActiveGameAction is now a stable reference due to Zustand's action pattern.

  if ((user && !initialLoadAttempted.current) || gameLoading) {
    console.log(`[AuthOrchestrator.tsx] Displaying loading screen. User: ${user ? 'present' : 'null'}, InitialLoadAttempted: ${initialLoadAttempted.current}, GameLoading: ${gameLoading}`);
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Session...</Typography>
      </Box>
    );
  }

  console.log('[AuthOrchestrator.tsx] Rendering Outlet (loading complete).');
  return <Outlet />;
};

export default AuthOrchestrator;
@@FILE: src/ui/components/CollapsibleLogEntry.tsx
// src/ui/components/CollapsibleLogEntry.tsx

import React from 'react';
import { Box, Typography, Divider } from '@mui/material';
import type { LogEntry } from '../../models/LogEntry';
import { LogViewMode } from '../../utils/types';
import { CollapsibleSection } from './CollapsibleSection';
import { LogEntryDisplay } from './LogEntryDisplay';

interface CollapsibleLogEntryProps {
  entry: LogEntry;
  selectedLogViewModes: LogViewMode[];
}

export const CollapsibleLogEntry: React.FC<CollapsibleLogEntryProps> = ({ entry, selectedLogViewModes }) => {
  // Determine if there's any content to show based on selected modes
  const hasContent = selectedLogViewModes.some(mode => {
    switch (mode) {
      case LogViewMode.NARRATOR_OUTPUT: return !!entry.narratorOutput;
      case LogViewMode.USER_INPUT: return !!entry.userInput;
      case LogViewMode.DIGEST_LINES: return (entry.digestLines?.length || 0) > 0;
      case LogViewMode.DELTAS: return entry.deltas && Object.keys(entry.deltas).length > 0;
      case LogViewMode.CONTEXT_SNAPSHOT: return !!entry.contextSnapshot;
      case LogViewMode.TOKEN_USAGE: return !!entry.tokenUsage;
      case LogViewMode.AI_SETTINGS: return !!entry.aiSettings;
      case LogViewMode.API_DETAILS: return !!entry.apiUrl || !!entry.modelSlugUsed || entry.latencyMs !== null;
      case LogViewMode.ERROR_FLAGS: return (entry.errorFlags?.length || 0) > 0;
      case LogViewMode.MODEL_SLUG_USED: return !!entry.modelSlugUsed;
      default: return false;
    }
  });

  if (!hasContent) {
    // Optionally return null or a placeholder if no content is selected to display
    // For now, if the main entry title is desired even without content, keep rendering.
    // If you want to hide the whole entry if nothing is selected, uncomment below.
    // return null;
  }

  return (
    <CollapsibleSection
      title={`Turn ${entry.turnNumber} - ${new Date(entry.timestamp).toLocaleTimeString()}`}
      initiallyExpanded={entry.turnNumber === 0} // Expand Turn 0 by default
    >
      <Box sx={{ p: 1 }}>
        {selectedLogViewModes.length === 0 ? (
          <Typography variant="body2" color="text.secondary">
            No log view modes selected for this entry. Please select modes from the "Log Views" menu.
          </Typography>
        ) : (
          selectedLogViewModes.map((mode, index) => (
            <React.Fragment key={mode}>
              <CollapsibleSection title={mode} initiallyExpanded={true}> {/* Inner collapsible for each mode */}
                <LogEntryDisplay mode={mode} entry={entry} hideTurnInfo={true} />
              </CollapsibleSection>
              {index < selectedLogViewModes.length - 1 && <Divider sx={{ my: 1 }} />}
            </React.Fragment>
          ))
        )}
      </Box>
    </CollapsibleSection>
  );
};
@@FILE: src/ui/components/CollapsibleSection.tsx
// src/ui/components/CollapsibleSection.tsx

import React from 'react';
import {
  Card,
  CardContent,
  Typography,
  IconButton,
  Collapse,
  Box,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';

interface CollapsibleSectionProps {
  title: string;
  children: React.ReactNode;
  initiallyExpanded?: boolean;
}

export const CollapsibleSection: React.FC<CollapsibleSectionProps> = ({
  title,
  children,
  initiallyExpanded = false,
}) => {
  const [expanded, setExpanded] = React.useState(initiallyExpanded);

  const handleExpandClick = () => {
    setExpanded(!expanded);
  };

  return (
    <Card variant="outlined" sx={{ mb: 2 }}>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          p: 1.5,
          cursor: 'pointer',
          '&:hover': {
            backgroundColor: (theme) => theme.palette.action.hover,
          },
        }}
        onClick={handleExpandClick}
      >
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
        </Typography>
        <IconButton
          onClick={handleExpandClick}
          aria-expanded={expanded}
          aria-label="show more"
          size="small"
        >
          {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
      </Box>
      <Collapse in={expanded} timeout="auto" unmountOnExit>
        <CardContent sx={{ pt: 1 }}>{children}</CardContent>
      </Collapse>
    </Card>
  );
};
@@FILE: src/ui/components/InfoDialog.tsx
// src/ui/components/InfoDialog.tsx

import React, { useState } from 'react';
import { Dialog, DialogTitle, DialogContent, DialogActions, Button, IconButton, Tooltip, Box } from '@mui/material';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';

interface InfoDialogProps {
  title: string;
  content: string | React.ReactNode; // Can be a string or JSX
  iconSize?: 'small' | 'medium' | 'large';
  tooltipText?: string; // Optional text for the initial hover tooltip
}

export const InfoDialog: React.FC<InfoDialogProps> = ({ title, content, iconSize = 'small', tooltipText = "Click for more information" }) => {
  const [open, setOpen] = useState(false);

  const handleClickOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <>
      <Tooltip title={tooltipText}>
        <IconButton size={iconSize} onClick={handleClickOpen} sx={{ ml: 0.5, p: 0 }}>
          <InfoOutlinedIcon fontSize="small" />
        </IconButton>
      </Tooltip>
      <Dialog
        open={open}
        onClose={handleClose}
        aria-labelledby="info-dialog-title"
        fullWidth
        maxWidth="sm"
      >
        <DialogTitle id="info-dialog-title">{title}</DialogTitle>
        <DialogContent dividers>
          {/* Use Box with pre-wrap to respect line breaks in string content */}
          {typeof content === 'string' ? <Box sx={{ whiteSpace: 'pre-wrap' }}>{content}</Box> : content}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Close</Button>
        </DialogActions>
      </Dialog>
    </>
  );
};
@@FILE: src/ui/components/LogEntryDisplay.tsx
// src/ui/components/LogEntryDisplay.tsx

import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
import type { LogEntry } from '../../models';
import { LogViewMode } from '../../utils/types';

interface LogEntryDisplayProps {
 mode: LogViewMode;
 entry: LogEntry;
 hideTurnInfo?: boolean; // New optional prop
}

export const LogEntryDisplay: React.FC<LogEntryDisplayProps> = ({ mode, entry, hideTurnInfo }) => {
 const renderContent = () => {
  switch (mode) {
   case LogViewMode.NARRATOR_OUTPUT:
    return entry.narratorOutput;
   case LogViewMode.USER_INPUT:
    return entry.userInput;
   case LogViewMode.DIGEST_LINES:
    // MODIFIED: Use `d.importance` which should now be correct
    return entry.digestLines.map(d => `${d.text} (Imp: ${d.importance})`).join('\n');
   case LogViewMode.DELTAS:
    return entry.deltas ? JSON.stringify(entry.deltas, null, 2) : 'No Deltas';
   case LogViewMode.CONTEXT_SNAPSHOT:
    return entry.contextSnapshot ? entry.contextSnapshot : 'No Context Snapshot';
   case LogViewMode.TOKEN_USAGE:
    return entry.tokenUsage ? `Input: ${entry.tokenUsage.inputTokens}, Output: ${entry.tokenUsage.outputTokens}, Total: ${entry.tokenUsage.totalTokens}` : 'No Token Usage Info';
   case LogViewMode.AI_SETTINGS:
    return entry.aiSettings ? JSON.stringify(entry.aiSettings, null, 2) : 'No AI Settings';
   case LogViewMode.API_DETAILS: {
      // MODIFIED: Build a more detailed API details string
     const details = [
      `URL: ${entry.apiUrl || 'N/A'}`,
      `Model: ${entry.modelSlugUsed || 'N/A'}`,
      `Latency: ${entry.latencyMs !== null ? `${entry.latencyMs}ms` : 'N/A'}`,
     ];
      if (entry.apiRequestBody) {
        details.push(`\n--- Request Body (without content) ---\n${entry.apiRequestBody}`);
      }
      if (entry.apiResponseBody) {
        details.push(`\n--- Response Body ---\n${entry.apiResponseBody}`);
      }
      return details.join('\n');
    }
   case LogViewMode.ERROR_FLAGS:
    return entry.errorFlags && entry.errorFlags.length > 0 ? entry.errorFlags.join(', ') : 'No Errors';
   case LogViewMode.MODEL_SLUG_USED:
     return entry.modelSlugUsed || 'N/A';
   default:
    return 'Select a view mode.';
  }
 };

  return (
    <Box sx={{ mb: 1.5 }}>
      {/* Conditionally render turn info based on new prop */}
      {!hideTurnInfo && (
        <Typography variant="caption" color="text.secondary">
          Turn {entry.turnNumber} - {new Date(entry.timestamp).toLocaleTimeString()}
        </Typography>
      )}
      <Typography variant="body2" component="pre" sx={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word', mt: 0.5 }}>
        {renderContent()}
      </Typography>
    </Box>
  );
};
@@FILE: src/ui/components/LogView.tsx
// src/ui/components/LogView.tsx

import React from 'react';
import { Box, Typography, Paper } from '@mui/material';
import type { Message } from '../../models';

interface LogViewProps {
  conversationHistory: Message[];
  currentStreamingNarration: string; // The partially typed/streamed narration
  isProcessingTurn: boolean; // Flag if AI is still generating a response
  fullLatestNarration: string; // The complete narration text for the current turn
  enableStreaming: boolean; // Is streaming enabled for the active prompt card?
}

export const LogView: React.FC<LogViewProps> = ({
  conversationHistory,
  currentStreamingNarration,
  isProcessingTurn,
  fullLatestNarration,
  enableStreaming
}) => {
  // Determine if the last message in conversationHistory *is* the one we're currently processing/typing.
  // This is true if conversationHistory's last message content matches the fullLatestNarration.
  const lastMessageInHistoryIsLatest = 
    conversationHistory.length > 0 &&
    conversationHistory[conversationHistory.length - 1].role === 'assistant' &&
    conversationHistory[conversationHistory.length - 1].content === fullLatestNarration;

  // Decide which messages from history to render.
  // If the last message in history is the *same* as the full latest narration (and we are streaming/processing),
  // we effectively "replace" that history entry with our live streaming output.
  const messagesToRenderFromHistory = (enableStreaming && isProcessingTurn) || (enableStreaming && !lastMessageInHistoryIsLatest && fullLatestNarration.length > 0 && currentStreamingNarration !== fullLatestNarration)
    ? conversationHistory.slice(0, -1) // Exclude the very last message from history, as we will render it live
    : conversationHistory; // Render all messages from history

  return (
    <Box sx={{ flexGrow: 1, overflowY: 'auto' }}>
      {/* Render all previous complete messages */}
      {messagesToRenderFromHistory.map((message, index) => (
        <Paper key={index} elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
          {message.role === 'user' ? (
            <>
              <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.primary.dark }}>
                You:
              </Typography>
              <Typography variant="body1" sx={{ mb: 1 }}>
                {message.content}
              </Typography>
            </>
          ) : message.role === 'assistant' ? (
            <>
              <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
                AI Narrator:
              </Typography>
              <Typography variant="body1">
                {message.content}
              </Typography>
            </>
          ) : null}
        </Paper>
      ))}

      {/* Conditionally render the latest assistant narration, potentially streaming */}
      {/* This block renders the current AI response, whether it's loading, streaming, or fully displayed */}
      {fullLatestNarration && ( // Only render if there's *any* latest narration content
        <Paper elevation={0} sx={{ p: 1.5, mb: 1.5, backgroundColor: 'transparent' }}>
          <Typography variant="body2" sx={{ fontWeight: 'bold', color: (theme) => theme.palette.secondary.dark }}>
            AI Narrator:
          </Typography>
          <Typography variant="body1">
            {isProcessingTurn || (enableStreaming && currentStreamingNarration !== fullLatestNarration)
              ? currentStreamingNarration // Show streaming text if processing or still typing
              : fullLatestNarration}      {/* Show full text if not streaming or streaming is complete */}
          </Typography>
        </Paper>
      )}

      {/* Display initial message if no content */}
      {conversationHistory.length === 0 && !fullLatestNarration && (
        <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mt: 4 }}>
          The story begins...
        </Typography>
      )}
    </Box>
  );
};
@@FILE: src/ui/components/MainLayout.tsx
// src/ui/components/MainLayout.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Drawer, List, ListItem, ListItemButton, ListItemIcon, ListItemText,
  CssBaseline, Box, Typography, Divider, IconButton
} from '@mui/material';
import LogoutIcon from '@mui/icons-material/Logout';
import MenuIcon from '@mui/icons-material/Menu';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { getNavItems } from '../../config/navigation';
import { LayoutProvider } from '../../contexts/LayoutContext';

const drawerWidth = 240;

const MainLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user, signOut } = useAuthStore();
  const { currentSnapshot } = useGameStateStore();
  const navigate = useNavigate();
  const [mobileOpen, setMobileOpen] = useState(false);

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleSignOut = async () => {
    await signOut();
    navigate('/login');
  };

  const navItems = getNavItems(currentSnapshot);

  const drawerContent = (
    <Box onClick={handleDrawerToggle} sx={{ textAlign: 'center' }}>
      <Typography variant="h6" sx={{ my: 2 }}>StoryForge</Typography>
      <Divider />
      <List>
        {navItems.filter(item => user ? true : !item.requiresAuth).map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton onClick={() => navigate(item.path)} disabled={item.disabled}>
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
        {user ? (
          <ListItem disablePadding>
            <ListItemButton onClick={handleSignOut}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Logout" />
            </ListItemButton>
          </ListItem>
        ) : (
          <ListItem disablePadding>
            <ListItemButton onClick={() => navigate('/login')}>
              <ListItemIcon><LogoutIcon /></ListItemIcon>
              <ListItemText primary="Login" />
            </ListItemButton>
          </ListItem>
        )}
      </List>
    </Box>
  );

  return (
    <LayoutProvider>
      <Box sx={{ display: 'flex', height: '100vh' }}>
        <CssBaseline />
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{ keepMounted: true }}
          sx={{ '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth } }}
        >
          {drawerContent}
        </Drawer>

        <Box component="main" sx={{ flexGrow: 1, height: '100%', display: 'flex', flexDirection: 'column' }}>
          {user && (
            <IconButton
              color="inherit"
              aria-label="open drawer"
              onClick={handleDrawerToggle}
              edge="start"
              sx={{
                position: 'fixed',
                top: 16,
                right: 16,
                zIndex: (theme) => theme.zIndex.drawer + 1,
                backgroundColor: (theme) => theme.palette.background.paper,
                boxShadow: 2,
                '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
              }}
            >
              <MenuIcon />
            </IconButton>
          )}
          {children}
        </Box>
      </Box>
    </LayoutProvider>
  );
};

export default MainLayout;
@@FILE: src/ui/components/PinnedAttributeChip.tsx
// src/ui/components/PinnedAttributeChip.tsx

import React from 'react';
import { Chip, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';

interface PinnedAttributeChipProps {
  fullKey: string;
  label: string;
  value: any;
  onUnpin: (key: string) => void;
}

export const PinnedAttributeChip: React.FC<PinnedAttributeChipProps> = React.memo(
  ({ fullKey, label, value, onUnpin }) => {
    const longPressProps = useLongPress((e) => {
      e.stopPropagation();
      onUnpin(fullKey);
    });

    return (
      <Tooltip title={`Long-press to unpin '${label}'`} key={fullKey}>
        <Chip
          label={`${label}: ${JSON.stringify(value)}`}
          size="small"
          deleteIcon={<PushPinIcon />}
          sx={{
            backgroundColor: (theme) => theme.palette.chipBackground.main, // CHIP_BG_LIGHT/DARK
            color: (theme) => theme.palette.text.primary,
            fontSize: '0.8rem',
            height: '22px',
            '& .MuiChip-label': {
              px: 1,
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
            },
            '& .MuiChip-deleteIcon': {
              opacity: 0.2,
            },
            '&:hover .MuiChip-deleteIcon': {
              opacity: 1,
            },
          }}
          {...longPressProps}
        />
      </Tooltip>
    );
  }
);

@@FILE: src/ui/components/PinnedEntityGroup.tsx
// src/ui/components/PinnedEntityGroup.tsx

import React from 'react';
import { Paper, Typography, Stack, Tooltip } from '@mui/material';
import PushPinIcon from '@mui/icons-material/PushPin';
import { useLongPress } from '../../utils/hooks/useLongPress';
import { PinnedAttributeChip } from './PinnedAttributeChip';

interface Attribute {
  label: string;
  value: any;
  fullKey: string;
}

interface PinnedEntityGroupProps {
  entityPath: string;
  attributes: Attribute[];
  onUnpinEntity: (path: string) => void;
  onUnpinVariable: (key: string) => void;
}

export const PinnedEntityGroup: React.FC<PinnedEntityGroupProps> = ({
  entityPath,
  attributes,
  onUnpinEntity,
  onUnpinVariable,
}) => {
  const longPressEntityProps = useLongPress(() => {
    onUnpinEntity(entityPath);
  });

  const entityDisplayName = entityPath.includes('.')
    ? entityPath.split('.').pop()?.replace(/^[#@$]/, '')
    : entityPath;

  return (
    <Paper
      elevation={3}
      sx={{
        p: 1,
        minWidth: 150,
        backgroundColor: (theme) =>
          theme.palette.mode === 'light'
            ? theme.palette.pinnedEntity.main // Uses PINNED_ENTITY_LIGHT
            : theme.palette.pinnedEntity.main, // Uses PINNED_ENTITY_DARK
        backdropFilter: 'blur(4px)',
        color: (theme) => theme.palette.text.primary,
        flexShrink: 0,
        cursor: 'pointer',
        borderRadius: 3,
        boxShadow: (theme) => theme.shadows[4],
        transition: 'transform 0.15s ease, box-shadow 0.15s ease',
        '&:hover': {
          transform: 'translateY(-2px)',
          boxShadow: (theme) => theme.shadows[6],
        },
      }}
      {...longPressEntityProps}
    >

      <Typography variant="subtitle2" sx={{ fontWeight: 'bold' }}>
        {entityDisplayName}
        <Tooltip title="Long-press to unpin all for this group">
          <PushPinIcon fontSize="small" sx={{ verticalAlign: 'middle', ml: 0.5 }} />
        </Tooltip>
      </Typography>
      <Stack direction="column" spacing={0.5} sx={{ mt: 1 }}>
        {attributes.map((attr) => (
          <PinnedAttributeChip
            key={attr.fullKey}
            fullKey={attr.fullKey}
            label={attr.label}
            value={attr.value}
            onUnpin={onUnpinVariable}
          />
        ))}
      </Stack>
    </Paper>
  );
};

@@FILE: src/ui/components/PinnedItemsView.tsx
import React, { useEffect, useCallback } from 'react';
import { Box, Typography, Paper, Stack } from '@mui/material';
import {
  useGameStateStore,
  selectCurrentGameState,
  selectWorldStatePinnedKeys
} from '../../state/useGameStateStore';
import { flattenJsonObject } from '../../utils/jsonUtils';
import { PinnedEntityGroup } from './PinnedEntityGroup';

export const PinnedItemsView: React.FC = React.memo(() => {
  const gameState = useGameStateStore(selectCurrentGameState);
  const worldStatePinnedKeys = useGameStateStore(selectWorldStatePinnedKeys);
  const toggleWorldStatePin = useGameStateStore(state => state.toggleWorldStatePin);

  const worldState = gameState?.worldState || {};

  const flattenedWorld = React.useMemo(() => {
    return flattenJsonObject(worldState);
  }, [worldState]);

  const pinnedItems = React.useMemo(() => {
    const items = worldStatePinnedKeys
      .map((key: string) => ({
        key,
        value: flattenedWorld[key],
      }))
      .filter(item => item.value !== undefined);

    return items;
  }, [worldStatePinnedKeys, flattenedWorld]);

  const groupedPinnedItems = React.useMemo(() => {
    const grouped: { [entityPath: string]: { label: string; value: any; fullKey: string }[] } = {};
    pinnedItems.forEach(item => {
      const parts = item.key.split('.');
      if (parts.length >= 2) {
        const secondPart = parts[1];
        const isTaggedEntity = secondPart.startsWith('#') || secondPart.startsWith('@') || secondPart.startsWith('$');
        let entityPath: string;
        let label: string;

        if (parts.length >= 3 && isTaggedEntity) {
          entityPath = parts.slice(0, 2).join('.');
          label = parts.slice(2).join('.');
        } else {
          entityPath = parts[0];
          label = parts.slice(1).join('.');
        }

        if (label === '') {
          label = parts[parts.length - 1];
        }

        grouped[entityPath] = grouped[entityPath] || [];
        grouped[entityPath].push({ label, value: item.value, fullKey: item.key });
      }
    });

    Object.keys(grouped).forEach(entityPath => {
      grouped[entityPath].sort((a, b) => a.label.localeCompare(b.label));
    });

    return grouped;
  }, [pinnedItems]);

  const handleUnpinEntity = useCallback((entityPath: string) => {
    toggleWorldStatePin(entityPath, 'entity');
  }, [toggleWorldStatePin]);

  const handleUnpinVariable = useCallback((key: string) => {
    toggleWorldStatePin(key, 'variable');
  }, [toggleWorldStatePin]);

  useEffect(() => {
    console.log("[PinnedItemsView] Re-rendered");
    console.log("Pinned keys:", worldStatePinnedKeys);
    console.log("Total grouped items:", Object.keys(groupedPinnedItems).length);
  }, [worldStatePinnedKeys, pinnedItems, groupedPinnedItems]);

  if (pinnedItems.length === 0) {
    return (
      <Paper
        elevation={0}
        sx={{ p: 1.5, mt: 1, backgroundColor: (theme) => theme.palette.background.default }}
      >
        <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center' }}>
          No items pinned. Right-click or long-press items in the World State screen to pin them here.
        </Typography>
      </Paper>
    );
  }

  return (
    <Stack
      direction="row"
      spacing={2}
      sx={{
        py: 1,
        overflowX: 'auto',
        backgroundColor: 'transparent',
      }}
    >
      {Object.entries(groupedPinnedItems).map(([entityPath, attributes]) => (
        <PinnedEntityGroup
          key={entityPath}
          entityPath={entityPath}
          attributes={attributes}
          onUnpinEntity={handleUnpinEntity}
          onUnpinVariable={handleUnpinVariable}
        />
      ))}
    </Stack>
  );
});

@@FILE: src/ui/components/ProtectedRoute.tsx
// src/ui/components/ProtectedRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../../state/useAuthStore';
import { Box, CircularProgress, Typography } from '@mui/material';

interface ProtectedRouteProps {
  children: JSX.Element;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { user, isLoading } = useAuthStore();
  const location = useLocation();

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Verifying Authentication...</Typography>
      </Box>
    );
  }

  if (!user) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to. This allows us to send them along to that page after they login.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default ProtectedRoute;
@@FILE: src/ui/components/StackInstructionsEditor.tsx
// src/ui/components/StackInstructionsEditor.tsx
import React from 'react';
import { Box, Typography, Divider, Checkbox, FormControlLabel, TextField } from '@mui/material';
import { CollapsibleSection } from './CollapsibleSection';
import { InfoDialog } from './InfoDialog';
import type { StackInstructions, ProsePolicy, DigestFilterPolicy, TokenPolicy, EmissionRule } from '../../models';

// Import the new, smaller components
import { PolicyEditor } from './stackInstructions/PolicyEditor';
import { DigestPolicyEditor } from './stackInstructions/DigestPolicyEditor';
import { TokenPolicyEditor } from './stackInstructions/TokenPolicyEditor';

interface StackInstructionsEditorProps {
  stackInstructions: StackInstructions;
  onStackInstructionsChange: (updatedInstructions: StackInstructions) => void;
}

const StackInstructionsEditor: React.FC<StackInstructionsEditorProps> = ({
  stackInstructions,
  onStackInstructionsChange,
}) => {
  // Generic handler to update a top-level policy object in the main state
  const handlePolicyChange = (
    policyKey: keyof StackInstructions,
    value: ProsePolicy | DigestFilterPolicy | TokenPolicy | Record<number, EmissionRule> | boolean | number
  ) => {
    onStackInstructionsChange({
      ...stackInstructions,
      [policyKey]: value,
    });
  };

  return (
    <CollapsibleSection title=" Stack Instructions" initiallyExpanded={false}>
      <Box sx={{ mb: 3 }}>
        <Typography variant="body2" color="text.secondary">
          These settings control how previous game information (the 'context stack') is assembled
          and presented to the AI for each new turn.
          <InfoDialog
            title="Understanding the Context Stack"
            content={`The AI's 'memory' for each turn is built from a 'context stack'. The order and content of this stack significantly impact AI responses. Each section below can be individually enabled/disabled.`}
          />
        </Typography>
      </Box>

      {/* -- Use the new PolicyEditor for repeating patterns -- */}
      <PolicyEditor
        title="Narrator Prose Emission"
        policy={stackInstructions.narratorProseEmission}
        onPolicyChange={(p) => handlePolicyChange('narratorProseEmission', p)}
        infoContent={{
          main: "Controls how past narrator output (the main story text) is included in the AI's context.",
          mode: "- ALWAYS: Include all past narrator prose.\n- FIRST_N: Include prose only from the first 'N' turns.\n- AFTER_N: Include prose only from turns after 'N'.\n- NEVER: Do not include any past narrator prose.",
          filtering: "- NONE: Include all prose based on the selected mode.\n- SCENE_ONLY: Only include prose relevant to the current scene.\n- TAGGED: Only include prose that contains any recognized tags."
        }}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Use the new DigestPolicyEditor -- */}
      <DigestPolicyEditor
        digestPolicy={stackInstructions.digestPolicy}
        digestEmission={stackInstructions.digestEmission}
        onPolicyChange={(p) => handlePolicyChange('digestPolicy', p)}
        onEmissionChange={(e) => handlePolicyChange('digestEmission', e)}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Expression Log is another ProsePolicy, so reuse PolicyEditor -- */}
      <PolicyEditor
        title="Expression Log Policy"
        policy={stackInstructions.expressionLogPolicy}
        onPolicyChange={(p) => handlePolicyChange('expressionLogPolicy', p)}
        infoContent={{
          main: "Controls how character 'expression' (portions of past narrator prose related to character actions/emotions) is included.",
          mode: "Controls when expression logs are included (Always, First N turns, etc.).",
          filtering: "Filters which expression logs are included based on tags."
        }}
      />
      {/* Specific fields for Expression Log that aren't in the generic policy */}
      <Box sx={{ ml: 2, mt: -2, mb: 2 }}>
        <TextField
          label="Expression Lines Per Character"
          type="number"
          value={stackInstructions.expressionLinesPerCharacter}
          onChange={(e) => handlePolicyChange('expressionLinesPerCharacter', parseInt(e.target.value))}
          sx={{ my: 2, width: '250px' }}
          inputProps={{ min: 0 }}
          InputProps={{
            endAdornment: <InfoDialog title="Expression Lines Per Character" content="The maximum number of lines of narrative prose to extract and summarize for character expressions." />
          }}
        />
        <FormControlLabel
          control={
            <Checkbox
              checked={stackInstructions.emotionWeighting}
              onChange={(e) => handlePolicyChange('emotionWeighting', e.target.checked)}
            />
          }
          label="Emotion Weighting"
        />
      </Box>

      <Divider sx={{ my: 3 }} />

      <PolicyEditor
        title="World State Policy"
        policy={stackInstructions.worldStatePolicy}
        onPolicyChange={(p) => handlePolicyChange('worldStatePolicy', p)}
        infoContent={{
          main: "Controls how the current world state JSON is included in the AI's context.",
          mode: "Controls when the world state is included.",
          filtering: "Filters which parts of the world state are included (e.g., scene-only)."
        }}
      />

      <Divider sx={{ my: 3 }} />

      <PolicyEditor
        title="Known Entities Policy"
        policy={stackInstructions.knownEntitiesPolicy}
        onPolicyChange={(p) => handlePolicyChange('knownEntitiesPolicy', p)}
        infoContent={{
          main: "Controls how a list of 'known entities' (tagged items, characters, locations) is included. This list reminds the AI of important things without sending the full world state.",
          mode: "Controls when the known entities list is included.",
          filtering: "Filters which known entities are listed."
        }}
      />

      <Divider sx={{ my: 3 }} />

      {/* -- Use the new TokenPolicyEditor -- */}
      <TokenPolicyEditor
        tokenPolicy={stackInstructions.tokenPolicy}
        onPolicyChange={(p) => handlePolicyChange('tokenPolicy', p)}
      />
    </CollapsibleSection>
  );
};

export { StackInstructionsEditor };
@@FILE: src/ui/components/WorldStateItemRow.tsx
// src/ui/components/WorldStateItemRow.tsx

import React, { useState } from 'react';
import {
  Box,
  Typography,
  IconButton,
  TextField,
  InputAdornment,
  Checkbox,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import PushPinIcon from '@mui/icons-material/PushPin';
import PushPinOutlinedIcon from '@mui/icons-material/PushPinOutlined';
import { parseJsonPrimitive } from '../../utils/jsonUtils';

interface WorldStateItemRowProps {
  itemKey: string; // Full key, e.g., "npcs.goblin_1.hp"
  value: any; // The raw value, JsonElement equivalent
  onDelete: (key: string) => Promise<void>; // Make it async as store actions might be async
  onEdit: (key: string, value: any) => Promise<void>; // Make it async
  isPinned: boolean;
  onTogglePin: (key: string) => void; // This will call the store's toggleWorldStatePin with 'variable' type
}

export const WorldStateItemRow: React.FC<WorldStateItemRowProps> = ({
  itemKey,
  value,
  onDelete,
  onEdit,
  isPinned,
  onTogglePin,
}) => {
  const [editMode, setEditMode] = useState(false);
  const [editText, setEditText] = useState(JSON.stringify(value)); // Use JSON.stringify for complex values

  // Extract the last part of the key for display name
  const displayName = itemKey.substring(itemKey.lastIndexOf('.') + 1);

  const handleEditConfirm = async () => {
    try {
      const parsedValue = parseJsonPrimitive(editText);
      await onEdit(itemKey, parsedValue); // Await the async edit operation
      setEditMode(false);
    } catch (e) {
      console.error("Failed to parse input for world state edit:", e);
      // TODO: Provide user feedback (e.g., Snackbar) for parsing errors
    }
  };

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        mb: 1,
        p: 1,
        borderRadius: 1,
        backgroundColor: (theme) => (editMode ? theme.palette.action.hover : 'transparent'),
      }}
    >
      <Typography variant="body2" sx={{ fontWeight: 'bold', flexShrink: 0 }}>
        {displayName}:
      </Typography>
      <Box sx={{ flexGrow: 1 }}>
        {editMode ? (
          <TextField
            fullWidth
            size="small"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onBlur={handleEditConfirm}
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleEditConfirm();
              }
            }}
            InputProps={{
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton size="small" onClick={handleEditConfirm}>
                    <EditIcon fontSize="small" />
                  </IconButton>
                </InputAdornment>
              ),
            }}
          />
        ) : (
          <Typography
            variant="body2"
            sx={{
              cursor: 'pointer',
              border: '1px solid',
              borderColor: (theme) => theme.palette.divider,
              borderRadius: 1,
              p: 0.8,
              '&:hover': { backgroundColor: (theme) => theme.palette.action.hover },
            }}
            onClick={() => setEditMode(true)}
          >
            {JSON.stringify(value)}
          </Typography>
        )}
      </Box>
      <Checkbox
        icon={<PushPinOutlinedIcon fontSize="small" />}
        checkedIcon={<PushPinIcon fontSize="small" />}
        checked={isPinned}
        onChange={() => onTogglePin(itemKey)} // Pass the full itemKey
        size="small"
        sx={{ p: 0.5 }}
      />
      <IconButton size="small" onClick={() => onDelete(itemKey)} sx={{ p: 0.5 }}>
        <DeleteIcon fontSize="small" color="error" />
      </IconButton>
    </Box>
  );
};
@@FOLDER: src/ui/components/promptCardEditorParts
@@FILE: src/ui/components/promptCardEditorParts/CorePromptEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  prompt: string;
  onPromptChange: (prompt: string) => void;
}

export const CorePromptEditor: React.FC<Props> = ({ prompt, onPromptChange }) => (
  <CollapsibleSection title="AI Prompt" initiallyExpanded={true}>
    <TextField
      fullWidth
      multiline
      minRows={5}
      label={
        <>
          Core Scenario / Persona Prompt
          <InfoDialog
            title="Core Scenario / Persona Prompt"
            content="This is the most important part of your prompt card. It defines the core scenario, the AI's persona, the setting, and any foundational rules. This text is ALWAYS sent to the AI."
          />
        </>
      }
      value={prompt}
      onChange={(e) => onPromptChange(e.target.value)}
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/EmitSkeletonEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';
import { DEFAULT_EMIT_SKELETON_STRING } from '../../../data/config/promptCardDefaults';

interface Props {
  emitSkeleton: string;
  onEmitSkeletonChange: (value: string) => void;
}

export const EmitSkeletonEditor: React.FC<Props> = ({ emitSkeleton, onEmitSkeletonChange }) => (
  <CollapsibleSection title="Emit & Tagging Skeleton" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={6}
      label={
        <>
          Emit/Tagging Rules (JSON/Text)
          <InfoDialog
            title="Emit & Tagging Skeleton"
            content={`This section provides the AI with strict rules on how to output structured data (@delta, @digest, @scene) as part of its response.`}
          />
        </>
      }
      value={emitSkeleton}
      onChange={(e) => onEmitSkeletonChange(e.target.value)}
      placeholder={DEFAULT_EMIT_SKELETON_STRING}
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/FirstTurnEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';
import { DEFAULT_FIRST_TURN_PROMPT_BLOCK } from '../../../data/config/promptCardDefaults';

interface Props {
  firstTurnOnlyBlock: string;
  onFirstTurnChange: (value: string) => void;
}

export const FirstTurnEditor: React.FC<Props> = ({ firstTurnOnlyBlock, onFirstTurnChange }) => (
  <CollapsibleSection title="First Turn Scene Setup" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={4}
      label={
        <>
          Intro scene shown only on turn 1
          <InfoDialog
            title="First Turn Only Block"
            content={`This text is added to the AI's prompt ONLY for the very first turn of a new game. It's ideal for setting an initial scene.`}
          />
        </>
      }
      value={firstTurnOnlyBlock}
      onChange={(e) => onFirstTurnChange(e.target.value)}
      placeholder={DEFAULT_FIRST_TURN_PROMPT_BLOCK}
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/FunctionDefsEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  functionDefs: string;
  onFunctionDefsChange: (value: string) => void;
}

export const FunctionDefsEditor: React.FC<Props> = ({ functionDefs, onFunctionDefsChange }) => (
  <CollapsibleSection title="Function Definitions" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={6}
      label={
        <>
          Function Definitions (JSON)
          <InfoDialog
            title="Function Definitions"
            content={`Provide JSON schemas for functions the AI can 'call'. This enables structured interaction with game systems.`}
          />
        </>
      }
      value={functionDefs}
      onChange={(e) => onFunctionDefsChange(e.target.value)}
      placeholder="e.g., { 'name': 'action', 'parameters': { ... } }"
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/GameRulesEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  gameRules: string;
  onGameRulesChange: (value: string) => void;
}

export const GameRulesEditor: React.FC<Props> = ({ gameRules, onGameRulesChange }) => (
  <CollapsibleSection title="Game Rules Skeleton" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={5}
      label={
        <>
          Game Rules
          <InfoDialog
            title="Game Rules"
            content="Textual rules or guidelines for the AI to follow throughout the game. This is always included in the AI prompt."
          />
        </>
      }
      value={gameRules}
      onChange={(e) => onGameRulesChange(e.target.value)}
      placeholder="Rules for the AI to follow during gameplay."
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/MetadataEditor.tsx
import React from 'react';
import { Box, Checkbox, FormControlLabel } from '@mui/material';
import { InfoDialog } from '../InfoDialog';

interface Props {
  isPublic: boolean;
  isExample: boolean;
  onCardChange: (updates: { isPublic: boolean; isExample: boolean }) => void;
}

export const MetadataEditor: React.FC<Props> = ({ isPublic, isExample, onCardChange }) => (
  <Box sx={{ mt: 3, display: 'flex', flexDirection: 'column', gap: 1 }}>
    <FormControlLabel
      control={
        <Checkbox
          checked={isPublic}
          onChange={(e) => onCardChange({ isPublic: e.target.checked, isExample })}
        />
      }
      label={
        <>
          Make Public (visible to others)
          <InfoDialog
            title="Public Card"
            content="If checked, this prompt card will be visible and potentially usable by other users."
          />
        </>
      }
    />
    <FormControlLabel
      control={
        <Checkbox
          checked={isExample}
          onChange={(e) => onCardChange({ isPublic, isExample: e.target.checked })}
        />
      }
      label={
        <>
          Is Example Card (for showcase)
          <InfoDialog
            title="Example Card"
            content="Mark this card as an official example. This is usually for built-in, curated content."
          />
        </>
      }
    />
  </Box>
);
@@FILE: src/ui/components/promptCardEditorParts/TitleAndDescriptionEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  title: string;
  description: string | null;
  onCardChange: (updates: { title: string; description: string | null }) => void;
}

export const TitleAndDescriptionEditor: React.FC<Props> = ({ title, description, onCardChange }) => (
  <CollapsibleSection title="Title & Description" initiallyExpanded={true}>
    <TextField
      fullWidth
      label={
        <>
          Title
          <InfoDialog
            title="Prompt Card Title"
            content="A short, descriptive name for this prompt card. Used for display in the game library and manager."
          />
        </>
      }
      value={title}
      onChange={(e) => onCardChange({ title: e.target.value, description })}
      sx={{ mb: 2 }}
    />
    <TextField
      fullWidth
      label={
        <>
          Description
          <InfoDialog
            title="Prompt Card Description"
            content="An optional, longer explanation of what this prompt card is about. It is NOT sent to the AI."
          />
        </>
      }
      multiline
      minRows={2}
      value={description || ''}
      onChange={(e) => onCardChange({ title, description: e.target.value || null })}
      placeholder="Optional: A short description for this prompt card."
    />
  </CollapsibleSection>
);
@@FILE: src/ui/components/promptCardEditorParts/WorldStateInitEditor.tsx
import React from 'react';
import { TextField } from '@mui/material';
import { CollapsibleSection } from '../CollapsibleSection';
import { InfoDialog } from '../InfoDialog';

interface Props {
  worldStateInit: string;
  onWorldStateInitChange: (value: string) => void;
}

export const WorldStateInitEditor: React.FC<Props> = ({ worldStateInit, onWorldStateInitChange }) => (
  <CollapsibleSection title="World State Initialization" initiallyExpanded={false}>
    <TextField
      fullWidth
      multiline
      minRows={5}
      label={
        <>
          Initial World State (JSON)
          <InfoDialog
            title="Initial World State (JSON)"
            content={`A JSON object defining the starting state of your game world. This is loaded once at the beginning of a new game session.`}
          />
        </>
      }
      value={worldStateInit}
      onChange={(e) => onWorldStateInitChange(e.target.value)}
      placeholder="{}"
    />
  </CollapsibleSection>
);
@@FOLDER: src/ui/components/stackInstructions
@@FILE: src/ui/components/stackInstructions/DigestPolicyEditor.tsx
// src/ui/components/stackInstructions/DigestPolicyEditor.tsx
import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  RadioGroup,
  FormControlLabel,
  Radio,
  Grid,
  Switch,
} from '@mui/material';
import type {
  DigestFilterPolicy,
  EmissionRule
} from '../../../models';

import  {
  StackMode,
  FilterMode,
} from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface DigestPolicyEditorProps {
  digestPolicy: DigestFilterPolicy;
  digestEmission: Record<number, EmissionRule>;
  onPolicyChange: (updatedPolicy: DigestFilterPolicy) => void;
  onEmissionChange: (updatedEmission: Record<number, EmissionRule>) => void;
}

export const DigestPolicyEditor: React.FC<DigestPolicyEditorProps> = ({
  digestPolicy,
  digestEmission,
  onPolicyChange,
  onEmissionChange,
}) => {
  const handleEmissionRuleChange = (score: number, field: keyof EmissionRule, value: any) => {
    const currentRule = digestEmission[score] || { mode: StackMode.NEVER, n: 0 };
    onEmissionChange({
      ...digestEmission,
      [score]: { ...currentRule, [field]: value },
    });
  };

  return (
    <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          Digest Lines Emission & Policy
        </Typography>
        <FormControlLabel
          control={
            <Switch
              checked={digestPolicy.enabled ?? false}
              onChange={(e) => onPolicyChange({ ...digestPolicy, enabled: e.target.checked })}
            />
          }
          label="Enable"
          labelPlacement="start"
        />
      </Box>
      <Box sx={{ opacity: digestPolicy.enabled ? 1 : 0.5, pointerEvents: digestPolicy.enabled ? 'auto' : 'none' }}>
        <Typography gutterBottom>
          Global Digest Filtering Policy
          <InfoDialog
            title="Global Digest Filtering Policy"
            content={`Applies a filter to ALL digest lines before their individual emission rules are checked.\n\n- NONE: No global filtering.\n- SCENE_ONLY: Only consider digests relevant to the current scene.\n- TAGGED: Only consider digests that have any tags.`}
          />
        </Typography>
        <FormControl component="fieldset" fullWidth margin="normal">
          <RadioGroup
            row
            value={digestPolicy.filtering}
            onChange={(e) => onPolicyChange({ ...digestPolicy, filtering: e.target.value as FilterMode })}
          >
            {Object.values(FilterMode).map((mode) => (
              <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
            ))}
          </RadioGroup>
        </FormControl>
        <Grid container spacing={2} sx={{ mt: 2 }}>
          {[5, 4, 3, 2, 1].map((score) => (
            // 1. Grid item is now ONLY responsible for layout.
            <Grid item xs={12} sm={6} md={4} key={score}>
              {/* 2. A nested Box handles ALL styling (border, padding). This resolves the error. */}
              <Box sx={{ border: '1px solid', borderColor: 'divider', p: 1.5, borderRadius: 1 }}>
                <Typography variant="subtitle2">
                  Importance {score} Digests
                  <InfoDialog
                    title={`Digest Importance Score ${score} Rule`}
                    content={`Determines how digest lines with an importance score of ${score} are included.`}
                  />
                </Typography>
                <FormControl component="fieldset" fullWidth size="small">
                  <RadioGroup
                    row
                    value={digestEmission[score]?.mode || StackMode.NEVER}
                    onChange={(e) => handleEmissionRuleChange(score, 'mode', e.target.value as StackMode)}
                  >
                    {Object.values(StackMode).filter(m => m !== StackMode.FILTERED).map((mode) => (
                      <FormControlLabel key={mode} value={mode} control={<Radio size="small" />} label={mode} sx={{ mb: -1 }}/>
                    ))}
                  </RadioGroup>
                  {(digestEmission[score]?.mode === StackMode.FIRST_N ||
                    digestEmission[score]?.mode === StackMode.AFTER_N) && (
                      <TextField
                        label="N"
                        type="number"
                        value={digestEmission[score]?.n || 0}
                        onChange={(e) => handleEmissionRuleChange(score, 'n', parseInt(e.target.value))}
                        size="small"
                        sx={{ mt: 1, width: '100px' }}
                        inputProps={{ min: 0 }}
                      />
                    )}
                </FormControl>
              </Box>
            </Grid>
          ))}
        </Grid>        
      </Box>
    </Box>
  );
};
@@FILE: src/ui/components/stackInstructions/PolicyEditor.tsx
// src/ui/components/stackInstructions/PolicyEditor.tsx
import React from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  RadioGroup,
  FormControlLabel,
  Radio,
  InputLabel,
  Select,
  MenuItem,
  Switch,
} from '@mui/material';
import type { ProsePolicy} from '../../../models';
import {StackMode, FilterMode } from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface PolicyEditorProps {
  title: string;
  policy: ProsePolicy;
  onPolicyChange: (updatedPolicy: ProsePolicy) => void;
  infoContent: {
    main: string;
    mode: string;
    filtering: string;
  };
}

export const PolicyEditor: React.FC<PolicyEditorProps> = ({
  title,
  policy,
  onPolicyChange,
  infoContent,
}) => {
  const handleFieldChange = (field: keyof ProsePolicy, value: any) => {
    onPolicyChange({ ...policy, [field]: value });
  };

  return (
    <Box sx={{ mb: 4, border: '1px solid', borderColor: 'divider', borderRadius: 1, p: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          {title}
          <InfoDialog title={title} content={infoContent.main} />
        </Typography>
        <FormControlLabel
          control={
            <Switch
              checked={policy.enabled ?? false}
              onChange={(e) => handleFieldChange('enabled', e.target.checked)}
            />
          }
          label="Enable"
          labelPlacement="start"
        />
      </Box>
      <Box sx={{ opacity: policy.enabled ? 1 : 0.5, pointerEvents: policy.enabled ? 'auto' : 'none' }}>
        <Typography gutterBottom>
          Mode
          <InfoDialog title={`${title} Mode`} content={infoContent.mode} />
        </Typography>
        <FormControl component="fieldset" fullWidth margin="normal">
          <RadioGroup
            row
            value={policy.mode}
            onChange={(e) => handleFieldChange('mode', e.target.value as StackMode)}
          >
            {Object.values(StackMode).filter(m => m !== StackMode.FILTERED).map((mode) => (
              <FormControlLabel key={mode} value={mode} control={<Radio />} label={mode} />
            ))}
          </RadioGroup>
          {(policy.mode === StackMode.FIRST_N || policy.mode === StackMode.AFTER_N) && (
            <TextField
              label="N (Turns)"
              type="number"
              value={policy.n}
              onChange={(e) => handleFieldChange('n', parseInt(e.target.value))}
              sx={{ mt: 1, width: '150px' }}
              inputProps={{ min: 0 }}
            />
          )}
        </FormControl>

        <Typography gutterBottom sx={{ mt: 2 }}>
          Filtering
          <InfoDialog title={`${title} Filtering`} content={infoContent.filtering} />
        </Typography>
        <FormControl fullWidth>
          <InputLabel id={`${title}-filtering-label`}>Filtering</InputLabel>
          <Select
            labelId={`${title}-filtering-label`}
            value={policy.filtering}
            label="Filtering"
            onChange={(e) => handleFieldChange('filtering', e.target.value as FilterMode)}
          >
            {Object.values(FilterMode).map((mode) => (
              <MenuItem key={mode} value={mode}>{mode}</MenuItem>
            ))}
          </Select>
        </FormControl>
      </Box>
    </Box>
  );
};
@@FILE: src/ui/components/stackInstructions/TokenPolicyEditor.tsx
// src/ui/components/stackInstructions/TokenPolicyEditor.tsx
import React from 'react';
import { Box, Typography, TextField } from '@mui/material';
import type { TokenPolicy } from '../../../models';
import { InfoDialog } from '../InfoDialog';

interface TokenPolicyEditorProps {
  tokenPolicy: TokenPolicy;
  onPolicyChange: (updatedPolicy: TokenPolicy) => void;
}

export const TokenPolicyEditor: React.FC<TokenPolicyEditorProps> = ({
  tokenPolicy,
  onPolicyChange,
}) => {
  const handleFieldChange = (field: keyof TokenPolicy, value: any) => {
    onPolicyChange({ ...tokenPolicy, [field]: value });
  };

  return (
    <Box>
      <Typography variant="h6" gutterBottom>
        Token Policy
      </Typography>
      <TextField
        fullWidth
        label="Min Tokens"
        type="number"
        value={tokenPolicy.minTokens}
        onChange={(e) => handleFieldChange('minTokens', parseInt(e.target.value))}
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
        InputProps={{
          endAdornment: <InfoDialog title="Min Tokens" content="The AI will attempt to generate a response of at least this many tokens." />
        }}
      />
      <TextField
        fullWidth
        label="Max Tokens"
        type="number"
        value={tokenPolicy.maxTokens}
        onChange={(e) => handleFieldChange('maxTokens', parseInt(e.target.value))}
        sx={{ mb: 2 }}
        inputProps={{ min: 0 }}
        InputProps={{
          endAdornment: <InfoDialog title="Max Tokens" content="The absolute maximum number of tokens the AI can generate." />
        }}
      />
      <TextField
        fullWidth
        label="Fallback Plan"
        value={tokenPolicy.fallbackPlan.join(', ')}
        onChange={(e) => handleFieldChange('fallbackPlan', e.target.value.split(',').map((s) => s.trim()))}
        sx={{ mb: 2 }}
        InputProps={{
          endAdornment: <InfoDialog title="Fallback Plan" content={`A prioritized, comma-separated list of strategies the system will use to reduce the *input prompt's* token count if it exceeds the AI model's context window.\n\nCommon Strategies:\ndrop_known_entities, drop_low_importance_digest, truncate_expression_logs, drop_narrator_prose, truncate_conversation_history`} />
        }}
      />
    </Box>
  );
};
@@FOLDER: src/ui/screens
@@FILE: src/ui/screens/CardLibraryScreen.tsx
// src/ui/screens/PromptCardLibraryScreen.tsx
// RENAMED from GameLibraryScreen.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  IconButton,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  TextField,
  InputAdornment,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import type { PromptCard } from '../../models';
import Snackbar from '@mui/material/Snackbar';
import { useNavigate } from 'react-router-dom';


interface PromptCardLibraryScreenProps { // RENAMED interface
  onNavToggle: () => void;
  // onNavigateToEditor: (cardId?: string) => void; // To navigate to editor with a specific card
}

const PromptCardLibraryScreen: React.FC<PromptCardLibraryScreenProps> = ({ onNavToggle }) => { // RENAMED component
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const {
    promptCards,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    deletePromptCard,
  } = usePromptCardStore();
  const { initializeGame } = useGameStateStore();

  const [searchTerm, setSearchTerm] = useState('');
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info'>('info');


  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
    }
  }, [user?.uid, fetchPromptCards]);

  const filteredCards = promptCards.filter(card =>
    card.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
    card.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  const handleEditCard = (card: PromptCard) => {
    setActivePromptCard(card);
    // Navigate to PromptCardManager/Editor screen
    navigate('/cards'); // Navigate to the PromptCardManager
    setSnackbarMessage(`Editing "${card.title}"`);
    setSnackbarSeverity('info');
    console.log(`Navigating to editor for card: ${card.id}`);
  };

  const handleDeleteCard = async (cardId: string) => {
    if (!user?.uid) return;
    try {
      await deletePromptCard(user.uid, cardId);
      setSnackbarMessage('Card deleted successfully!');
      setSnackbarSeverity('success');
    } catch (e) {
      setSnackbarMessage(`Failed to delete card: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };

  const handleStartGame = async (card: PromptCard) => {
    if (!user?.uid) {
      setSnackbarMessage('Must be logged in to start a game.');
      setSnackbarSeverity('error');
      return;
    }
    try {
      // First, set the active card, then initialize game
      setActivePromptCard(card);
      await initializeGame(user.uid, card.id);
      setSnackbarMessage(`Game "${card.title}" initialized! Navigating to game...`);
      setSnackbarSeverity('success');
      navigate('/game'); // Navigate to the GameScreen
      console.log(`Game "${card.title}" started! Navigating to GameScreen.`);
    } catch (e) {
      setSnackbarMessage(`Failed to start game: ${e instanceof Error ? e.message : 'Unknown error'}`);
      setSnackbarSeverity('error');
    }
  };


  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Card Library...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <AppBar position="static" elevation={1}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Prompt Card Library
          </Typography>
          <IconButton edge="end" color="inherit" aria-label="menu" onClick={onNavToggle}>
            <MenuIcon />
          </IconButton>
        </Toolbar>
      </AppBar>

      {error && (
        <Alert severity="error" sx={{ m: 2 }}>
          Error: {error}
        </Alert>
      )}

      <Box sx={{ p: 2 }}>
        <TextField
          fullWidth
          label="Search Cards"
          variant="outlined"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon />
              </InputAdornment>
            ),
          }}
          sx={{ mb: 2 }}
        />
      </Box>

      <Paper elevation={1} sx={{ flexGrow: 1, m: 2, overflowY: 'auto' }}>
        {filteredCards.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              {searchTerm ? "No cards match your search." : "No cards available. Go to Prompt Cards Manager to create one!"}
            </Typography>
            <Button variant="contained" startIcon={<AddIcon />} sx={{ mt: 2 }} onClick={() => navigate('/cards')}>
              Go to Prompt Card Manager
            </Button>
          </Box>
        ) : (
          <List>
            {filteredCards.map((card) => (
              <React.Fragment key={card.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="start-game" onClick={() => handleStartGame(card)}>
                        <PlayArrowIcon color="primary" />
                      </IconButton>
                      <IconButton edge="end" aria-label="edit-card" onClick={() => handleEditCard(card)}>
                        <EditIcon />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete-card" onClick={() => handleDeleteCard(card.id)}>
                        <DeleteIcon color="error" />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={card.title}
                    secondary={card.description || 'No description'}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>
      <Snackbar
        open={!!snackbarMessage}
        autoHideDuration={6000}
        onClose={() => setSnackbarMessage(null)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={() => setSnackbarMessage(null)} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardLibraryScreen;
@@FILE: src/ui/screens/GameLibraryScreen.tsx
import React, { useEffect, useState } from 'react';
import {
  Box,
  Typography,
  Button,
  AppBar,
  Toolbar,
  List,
  ListItem,
  ListItemText,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  IconButton,
  Snackbar,
} from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import DeleteIcon from '@mui/icons-material/Delete';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { gameRepository } from '../../data/repositories/gameRepository';
import { useNavigate } from 'react-router-dom';
import type { GameSnapshot } from '../../models';
import { formatIsoDateForDisplay } from '../../utils/formatDate';

const GameLibraryScreen: React.FC = () => {
  const { user } = useAuthStore();
  const navigate = useNavigate();
  const { loadGame, gameLoading } = useGameStateStore();

  const [savedGames, setSavedGames] = useState<GameSnapshot[]>([]);
  const [loadingSavedGames, setLoadingSavedGames] = useState(true);
  const [savedGamesError, setSavedGamesError] = useState<string | null>(null);
  const [snackbarMessage, setSnackbarMessage] = useState<string | null>(null);
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info' | 'warning'>('info');
  const [snackbarOpen, setSnackbarOpen] = useState(false);

  const fetchSavedGames = async (userId: string) => {
    setLoadingSavedGames(true);
    setSavedGamesError(null);
    try {
      const games = await gameRepository.getAllGameSnapshots(userId);
      setSavedGames(games);
    } catch (e: any) {
      setSavedGamesError(e.message || 'Failed to fetch saved games.');
    } finally {
      setLoadingSavedGames(false);
    }
  };

  useEffect(() => {
    if (user?.uid) {
      fetchSavedGames(user.uid);
    }
  }, [user?.uid]);

  const showSnackbar = (
    message: string,
    severity: 'success' | 'error' | 'info' | 'warning' = 'info'
  ) => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  };

  const handleSnackbarClose = (event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') return;
    setSnackbarOpen(false);
  };

  const handleLoadGame = async (snapshotId: string) => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to load a game.', 'error');
      return;
    }
    try {
      await loadGame(user.uid, snapshotId);
      showSnackbar('Game loaded successfully! Navigating to game...', 'success');
      navigate('/game');
    } catch (e) {
      showSnackbar(
        `Failed to load game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  const handleDeleteGame = async (snapshotId: string) => {
    if (!user?.uid) return;
    try {
      await gameRepository.deleteGameSnapshot(user.uid, snapshotId);
      fetchSavedGames(user.uid);
      showSnackbar('Game deleted successfully!', 'success');
    } catch (e) {
      showSnackbar(
        `Failed to delete game: ${e instanceof Error ? e.message : 'Unknown error'}`,
        'error'
      );
    }
  };

  if (loadingSavedGames || gameLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>
          Loading Games...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">
          Game Library (Saved Games)
        </Typography>
      </Box>

      {savedGamesError && (
        <Alert
          severity="error"
          sx={{
            m: 2,
            backgroundColor: (theme) => theme.palette.background.paper,
            color: (theme) => theme.palette.text.primary,
          }}
        >
          Error: {savedGamesError}
        </Alert>
      )}

      <Box sx={{ p: 2, display: 'flex', justifyContent: 'center' }}>
        <Button
          variant="contained"
          color="primary"
          sx={{ mt: 2 }}
          onClick={() => navigate('/cards')}
        >
          Start New Game (Select Prompt Card)
        </Button>
      </Box>

      <Paper
        elevation={1}
        sx={{
          flexGrow: 1,
          m: 2,
          overflowY: 'auto',
          backgroundColor: (theme) => theme.palette.background.paper,
        }}
      >
        {savedGames.length === 0 ? (
          <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
            <Typography variant="body1" color="text.secondary">
              No saved games found. Start a new one!
            </Typography>
          </Box>
        ) : (
          <List>
            {savedGames.map((game) => (
              <React.Fragment key={game.id}>
                <ListItem
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="load-game" onClick={() => handleLoadGame(game.id)}>
                        <PlayArrowIcon sx={{ color: (theme) => theme.palette.primary.main }} />
                      </IconButton>
                      <IconButton edge="end" aria-label="delete-game" onClick={() => handleDeleteGame(game.id)}>
                        <DeleteIcon sx={{ color: (theme) => theme.palette.error.main }} />
                      </IconButton>
                    </Box>
                  }
                >
                  <ListItemText
                    primary={game.title}
                    secondary={`Turn: ${game.currentTurn} | Last Saved: ${formatIsoDateForDisplay(game.updatedAt)}`}
                    primaryTypographyProps={{ fontWeight: 'medium' }}
                  />
                </ListItem>
                <Divider component="li" />
              </React.Fragment>
            ))}
          </List>
        )}
      </Paper>

      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbarSeverity} sx={{ width: '100%' }}>
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default GameLibraryScreen;

@@FILE: src/ui/screens/GameScreen.tsx
// src/ui/screens/GameScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, TextField, Paper, IconButton, CircularProgress,
  Dialog, DialogTitle, DialogContent, DialogActions, Snackbar, Alert, Tooltip,
  useTheme, useMediaQuery, InputAdornment,
} from '@mui/material';
import SendIcon from '@mui/icons-material/Send';
import CasinoIcon from '@mui/icons-material/Casino';
import { useGameScreenLogic } from '../../utils/hooks/useGameScreenLogic';
import { LogView } from '../components/LogView';
import { PinnedItemsView } from '../components/PinnedItemsView';

const GameScreen: React.FC<{ onNavToggle: () => void }> = () => {
  const {
    isReady,
    isLoading,
    isProcessingTurn,
    gameError,
    // gameState, // REMOVED: No longer directly used in JSX, handled in hook
    conversationHistory,
    narratorInputText,
    logContainerRef,
    snackbar,
    rollDialog,
    handleGoToLogin,
    handleSendAction,
    handleInputChange,
    handleKeyPress,
    handleRollDice,
    handleOpenRollDialog,
    handleCloseRollDialog,
    handleRollFormulaChange,
    closeSnackbar,
    displayedCurrentNarration,
    fullLatestNarration, // Renamed from latestNarrationFromHook in the hook's return
    enableStreaming,
  } = useGameScreenLogic();

  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm'));
  const pinnedHeight = isSmallScreen ? theme.spacing(14) : theme.spacing(16); // USED: Now it's used below

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Game...</Typography>
      </Box>
    );
  }

  if (!isReady) {
    return (
      <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
        <Typography variant="h6" color="error">Game Not Initialized</Typography>
        <Typography variant="body1" sx={{ my: 2 }}>
          There is no active game session. Please start a new game from the library.
        </Typography>
        <Button variant="contained" onClick={handleGoToLogin}>Go to Game Library</Button>
        {gameError && <Alert severity="error" sx={{ mt: 2 }}>{gameError}</Alert>}
      </Box>
    );
  }

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        height: '100vh',
        position: 'relative',
        overflow: 'hidden',
        px: isSmallScreen ? 1 : 2,
        pt: pinnedHeight, // FIXED: Now using pinnedHeight
      }}
    >
      {/* Floating pinned items */}
      <Box
        sx={{
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          zIndex: 10,
          backdropFilter: 'blur(8px)',
          backgroundColor: 'rgba(255,255,255,0.1)',
          borderBottom: `1px solid ${theme.palette.divider}`,
          boxShadow: '0 2px 6px rgba(0,0,0,0.1)',
          px: isSmallScreen ? 1 : 2,
          py: isSmallScreen ? 1 : 2,
          pointerEvents: 'none',
        }}
      >
        <PinnedItemsView />
      </Box>

      {/* Scrollable narration area */}
      <Paper
        ref={logContainerRef}
        elevation={1}
        sx={{
          flexGrow: 1,
          overflowY: 'auto',
          p: isSmallScreen ? 1 : 2,
          typography: isSmallScreen ? 'body2' : 'body1',
          backgroundColor: theme.palette.background.paper,
        }}
      >
        <LogView
          conversationHistory={conversationHistory}
          currentStreamingNarration={displayedCurrentNarration}
          isProcessingTurn={isProcessingTurn}
          fullLatestNarration={fullLatestNarration}
          enableStreaming={enableStreaming}
        />
      </Paper>

      {/* Input area */}
      <Box sx={{ position: 'relative', mt: 1 }}>
        <TextField
          fullWidth
          multiline
          maxRows={4}
          variant="outlined"
          placeholder="What do you do?"
          value={narratorInputText}
          onChange={(e) => handleInputChange(e.target.value)}
          onKeyPress={handleKeyPress}
          disabled={isProcessingTurn}
          size={isSmallScreen ? 'small' : 'medium'}
          InputProps={{
            endAdornment: (
              <InputAdornment position="end">
                <IconButton
                  color="primary"
                  onClick={handleSendAction}
                  disabled={isProcessingTurn || narratorInputText.trim() === ''}
                >
                  {isProcessingTurn ? <CircularProgress size={20} color="inherit" /> : <SendIcon />}
                </IconButton>
              </InputAdornment>
            ),
          }}
        />

        {/* Floating dice icon */}
        <Tooltip title="Roll Dice (Right-click to change formula)">
          <IconButton
            color="secondary"
            onClick={handleRollDice}
            onContextMenu={(e) => {
              e.preventDefault();
              handleOpenRollDialog();
            }}
            sx={{
              position: 'absolute',
              right: 60,
              top: -30,
              zIndex: 20,
              backgroundColor: theme.palette.background.paper,
              border: '1px solid',
              borderColor: 'divider',
              boxShadow: 2,
              '&:hover': { backgroundColor: theme.palette.action.hover },
            }}
          >
            <CasinoIcon />
          </IconButton>
        </Tooltip>
      </Box>

      {/* Dice Roll Dialog */}
      <Dialog open={rollDialog.open} onClose={handleCloseRollDialog}>
        <DialogTitle>Dice Roll</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Dice Formula"
            type="text"
            fullWidth
            variant="standard"
            value={rollDialog.formula}
            onChange={(e) => handleRollFormulaChange(e.target.value)}
            helperText="e.g., 2d6, 1d20+5, 3d8-2"
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseRollDialog}>Cancel</Button>
          <Button onClick={handleRollDice}>Roll & Send</Button>
        </DialogActions>
      </Dialog>

      {/* Snackbar */}
      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={closeSnackbar}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default GameScreen;
@@FILE: src/ui/screens/LogViewerScreen.tsx
// src/ui/screens/LogViewerScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, AppBar, Toolbar, IconButton, Menu, MenuItem,
  Checkbox, FormControlLabel, Paper, CircularProgress, Alert,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { useLogViewerLogic } from '../../utils/hooks/useLogViewerLogic';
import { LogViewMode } from '../../utils/types';
import { CollapsibleLogEntry } from '../components/CollapsibleLogEntry';

const LogViewerScreen: React.FC = () => {
  const {
    logEntries, selectedLogViewModes, isLoading, error,
    menuAnchorEl, isMenuOpen, handleMenuClick, handleMenuClose, handleCheckboxChange,
  } = useLogViewerLogic();

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress /> <Typography variant="h6" ml={2}>Loading Logs...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">Logs</Typography>
      </Box>
      <Menu anchorEl={menuAnchorEl} open={isMenuOpen} onClose={handleMenuClose}>
        {Object.values(LogViewMode).map((mode) => (
          <MenuItem key={mode} onClick={() => handleCheckboxChange(mode)}>
            <FormControlLabel
              control={<Checkbox checked={selectedLogViewModes.includes(mode)} />}
              label={mode}
              sx={{ pointerEvents: 'none' }} // Let the MenuItem handle the click
            />
          </MenuItem>
        ))}
      </Menu>

      {error && <Alert severity="error" sx={{ m: 2 }}>Error: {error}</Alert>}

      <Paper elevation={1} sx={{ flexGrow: 1, m: 2, overflowY: 'auto' }}>
        {logEntries.length === 0 ? (
          <Box sx={{ textAlign: 'center', p: 4 }}><Typography color="text.secondary">No log entries for this game yet.</Typography></Box>
        ) : (
          logEntries.map((entry) => (
            <CollapsibleLogEntry
              key={entry.turnNumber}
              entry={entry}
              selectedLogViewModes={selectedLogViewModes}
            />
          ))
        )}
      </Paper>
    </Box>
  );
};

export default LogViewerScreen;
@@FILE: src/ui/screens/LoginScreen.tsx
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom'; // Add this
import { useAuthStore } from '../../state/useAuthStore';

const styles: { [key: string]: React.CSSProperties } = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: '100vh',
    backgroundColor: '#f0f2f5',
    fontFamily: 'Arial, sans-serif',
    padding: '20px',
  },
  button: {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#4285F4',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    marginTop: '20px',
    transition: 'background-color 0.3s ease',
  },
  errorText: {
    color: 'red',
    marginTop: '10px',
  },
};


const LoginScreen: React.FC = () => {
  const { user, isLoading, error, signIn, signOut } = useAuthStore();
  const navigate = useNavigate(); // Add this

  //  Redirect out of login screen if user is authenticated
  useEffect(() => {
    if (user) {
      navigate('/library', { replace: true });
    }
  }, [user, navigate]);

  if (isLoading) {
    return (
      <div style={styles.container}>
        <h2>Loading Authentication Status...</h2>
      </div>
    );
  }

  if (user) {
    return (
      <div style={styles.container}>
        <h2>Welcome, {user.displayName || user.email}!</h2>
        <p>Your User ID: {user.uid}</p>
        <button onClick={signOut} style={styles.button}>
          Sign Out
        </button>
      </div>
    );
  } else {
    return (
      <div style={styles.container}>
        <h2>Please Log In to StoryForge</h2>
        {error && <p style={styles.errorText}>Error: {error}</p>}
        <button onClick={signIn} style={styles.button}>
          Sign in with Google
        </button>
      </div>
    );
  }
};
export default LoginScreen;
@@FILE: src/ui/screens/PromptCardEditor.tsx
// src/ui/screens/PromptCardEditor.tsx
import React from 'react';
import { Box, Divider, FormControlLabel, Switch } from '@mui/material';
import type{ PromptCard, AiConnection, StackInstructions, AiSettings } from '../../models';

// Import the existing modular editors
import { AiSettingsEditor } from '../components/AiSettingsEditor';
import { StackInstructionsEditor } from '../components/StackInstructionsEditor';
import { CollapsibleSection } from '../components/CollapsibleSection';
import { InfoDialog } from '../components/InfoDialog';

// Import the new decomposed parts
import { TitleAndDescriptionEditor } from '../components/promptCardEditorParts/TitleAndDescriptionEditor';
import { CorePromptEditor } from '../components/promptCardEditorParts/CorePromptEditor';
import { FirstTurnEditor } from '../components/promptCardEditorParts/FirstTurnEditor';
import { EmitSkeletonEditor } from '../components/promptCardEditorParts/EmitSkeletonEditor';
import { WorldStateInitEditor } from '../components/promptCardEditorParts/WorldStateInitEditor';
import { GameRulesEditor } from '../components/promptCardEditorParts/GameRulesEditor';
import { FunctionDefsEditor } from '../components/promptCardEditorParts/FunctionDefsEditor';
import { MetadataEditor } from '../components/promptCardEditorParts/MetadataEditor';


interface PromptCardEditorProps {
  card: PromptCard;
  onCardChange: (updatedCard: PromptCard) => void;
  availableConnections: AiConnection[];
}

const PromptCardEditor: React.FC<PromptCardEditorProps> = ({
  card,
  onCardChange,
  availableConnections,
}) => {
  // Create specific change handlers for children to call
  const handleFieldChange = (updates: Partial<PromptCard>) => {
    onCardChange({ ...card, ...updates });
  };

  return (
    <Box sx={{ p: 1, pb: 4 }}>
      <TitleAndDescriptionEditor
        title={card.title}
        description={card.description}
        onCardChange={(updates) => handleFieldChange(updates)}
      />

      <CorePromptEditor
        prompt={card.prompt}
        onPromptChange={(prompt) => handleFieldChange({ prompt })}
      />

      <FirstTurnEditor
        firstTurnOnlyBlock={card.firstTurnOnlyBlock}
        onFirstTurnChange={(firstTurnOnlyBlock) => handleFieldChange({ firstTurnOnlyBlock })}
      />

      <EmitSkeletonEditor
        emitSkeleton={card.emitSkeleton}
        onEmitSkeletonChange={(emitSkeleton) => handleFieldChange({ emitSkeleton })}
      />

      <WorldStateInitEditor
        worldStateInit={card.worldStateInit}
        onWorldStateInitChange={(worldStateInit) => handleFieldChange({ worldStateInit })}
      />

      <GameRulesEditor
        gameRules={card.gameRules}
        onGameRulesChange={(gameRules) => handleFieldChange({ gameRules })}
      />

      <AiSettingsEditor
        label="Primary AI Settings"
        settings={card.aiSettings}
        onSettingsChange={(aiSettings) => handleFieldChange({ aiSettings })}
        availableConnections={availableConnections}
      />

      <CollapsibleSection title="Helper AI Settings" initiallyExpanded={false}>
        <FormControlLabel
          control={
            <Switch
              checked={card.isHelperAiEnabled}
              onChange={(e) => handleFieldChange({ isHelperAiEnabled: e.target.checked })}
            />
          }
          label={<>Enable Helper AI <InfoDialog title="Enable Helper AI" content="Toggle to enable a secondary AI call for specific tasks."/></>}
          sx={{ mb: 2 }}
        />
        <Divider sx={{ mb: 2 }} />
        <Box sx={{ opacity: card.isHelperAiEnabled ? 1 : 0.5, pointerEvents: card.isHelperAiEnabled ? 'auto' : 'none' }}>
          <AiSettingsEditor
            label=""
            settings={card.helperAiSettings}
            onSettingsChange={(helperAiSettings) => handleFieldChange({ helperAiSettings })}
            availableConnections={availableConnections}
          />
        </Box>
      </CollapsibleSection>

      <FunctionDefsEditor
        functionDefs={card.functionDefs}
        onFunctionDefsChange={(functionDefs) => handleFieldChange({ functionDefs })}
      />

      <StackInstructionsEditor
        stackInstructions={card.stackInstructions}
        onStackInstructionsChange={(stackInstructions) => handleFieldChange({ stackInstructions })}
      />

      <MetadataEditor
        isPublic={card.isPublic}
        isExample={card.isExample}
        onCardChange={(updates) => handleFieldChange(updates)}
      />
    </Box>
  );
};

export default PromptCardEditor;
@@FILE: src/ui/screens/PromptCardManager.tsx
// src/ui/screens/PromptCardManager.tsx
import React from 'react';
import {
  Box,
  Typography,
  Button,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Paper,
  Divider,
  CircularProgress,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Snackbar,
  ListItemButton
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import FileUploadIcon from '@mui/icons-material/FileUpload';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import { useAuthStore } from '../../state/useAuthStore';
import { usePromptCardManagerLogic } from '../../utils/hooks/usePromptCardManagerLogic';
import PromptCardEditor from './PromptCardEditor';
import type { PromptCard } from '../../models';



const PromptCardManager: React.FC = () => {
  const { user } = useAuthStore();
  const {
    isLoading,
    error,
    promptCards,
    activePromptCard,
    localEditedCard,
    isCardDirty,
    aiConnections,
    saveDialog,
    snackbar,
    handleCardSelect,
    handleLocalCardChange,
    handleSaveCard,
    handleRevert,
    handleNewCard,
    handleDeleteCard,
    handleDuplicateCard,
    handleImport,
    handleExport,
    handleStartGame,
    setSaveDialog,
    setSaveAsNewTitle,
    closeSnackbar,
  } = usePromptCardManagerLogic(user);

  if (isLoading && !promptCards.length) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography variant="h6" ml={2}>Loading Prompt Cards...</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h5" component="h1">
          Prompt Cards
        </Typography>
      </Box>

      <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
        <Button variant="contained" onClick={handleNewCard} startIcon={<AddIcon />}>
          New Card
        </Button>
        <Button variant="outlined" component="label" startIcon={<FileUploadIcon />}>
          Import Cards
          <input type="file" hidden accept=".json" onChange={handleImport} multiple/>
        </Button>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          Error: {error}
        </Alert>
      )}

      <Box sx={{ display: 'flex', flex: 1, overflow: 'hidden', gap: 2 }}>
        <Paper elevation={1} sx={{ flex: 1, minWidth: 250, maxWidth: 350, overflowY: 'auto' }}>
          <Typography variant="h6" sx={{ p: 2, pb: 1 }}>Your Cards</Typography>
          <Divider />
          <List>
            {promptCards.length === 0 ? (
              <ListItem><ListItemText primary="No cards yet. Create one!" sx={{ textAlign: 'center' }} /></ListItem>
            ) : (
              promptCards.map((card: PromptCard) => (
                <ListItem key={card.id} disablePadding component="li">
                  <ListItemButton
                    selected={activePromptCard?.id === card.id}
                    onClick={() => handleCardSelect(card)}
                    sx={{
                      py: 1,
                      pr: 2,
                      cursor: 'pointer',
                      '&:hover': {
                        backgroundColor: (theme) => theme.palette.action.hover,
                      },
                    }}
                  >
                    <ListItemText primary={card.title || 'Untitled Card'} />
                  </ListItemButton>
                </ListItem>

              ))
            )}
          </List>
        </Paper>

        <Paper elevation={1} sx={{ flex: 2, minWidth: 400, overflowY: 'auto' }}>
          {!activePromptCard || !localEditedCard ? (
            <Box sx={{ textAlign: 'center', p: 4, mt: 4 }}>
              <Typography variant="h6" color="text.secondary">Select a card or create a new one to start editing.</Typography>
            </Box>
          ) : (
            <Box>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', p: 2, borderBottom: '1px solid', borderColor: 'divider', position: 'sticky', top: 0, backgroundColor: 'background.paper', zIndex: 1 }}>
                <Typography variant="h6" component="h2">{localEditedCard.title}</Typography>
                <Box sx={{ display: 'flex', gap: 1 }}>
                  {isCardDirty && (
                    <>
                      <Button variant="outlined" onClick={handleRevert}>Revert</Button>
                      <Button variant="contained" onClick={() => handleSaveCard(false)}>Save Changes</Button>
                    </>
                  )}
                  <Button variant="outlined" onClick={() => setSaveDialog(true)}>Save As...</Button>
                  <Button variant="contained" color="primary" onClick={handleStartGame} startIcon={<PlayArrowIcon />} disabled={isCardDirty}>
                    Start Game
                  </Button>
                </Box>
              </Box>
              <PromptCardEditor card={localEditedCard} onCardChange={handleLocalCardChange} availableConnections={aiConnections} />
            </Box>
          )}
        </Paper>
      </Box>

      <Dialog open={saveDialog.open} onClose={() => setSaveDialog(false)}>
        <DialogTitle>Save Prompt Card As New</DialogTitle>
        <DialogContent><TextField autoFocus margin="dense" label="New Card Title" type="text" fullWidth variant="outlined" value={saveDialog.title} onChange={(e) => setSaveAsNewTitle(e.target.value)} placeholder={`${localEditedCard?.title} (Copy)`} /></DialogContent>
        <DialogActions>
          <Button onClick={() => setSaveDialog(false)}>Cancel</Button>
          <Button onClick={() => handleSaveCard(true)}>Save</Button>
        </DialogActions>
      </Dialog>

      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={closeSnackbar} anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PromptCardManager;
@@FILE: src/ui/screens/SettingsScreen.tsx
// src/ui/screens/SettingsScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, Paper, Divider, CircularProgress, Alert, TextField, Switch, FormControlLabel,
  Snackbar, Dialog, DialogTitle, DialogContent, DialogActions, ListItemButton,
  Stack, Select, MenuItem, InputLabel, FormControl, Card, CardActionArea, Grid,
  ListSubheader, InputAdornment, ListItemText, Tooltip, List, ListItem, IconButton
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import SearchIcon from '@mui/icons-material/Search';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
import WifiTetheringIcon from '@mui/icons-material/WifiTethering';
import { useSettingsLogic } from '../../utils/hooks/useSettingsLogic';
import { CollapsibleSection } from '../components/CollapsibleSection';

const SettingsScreen: React.FC = () => {
  const {
    aiConnections, selectedConnectionId, isLoadingConnections, connectionsError,
    useDummyNarrator, themeMode, setUseDummyNarrator, setThemeMode,
    isDialogOpen, dialogStep, editingConnection, isFetchingModels, testStatus, snackbar, templates,
    setModelSearchTerm, filteredModels,
    handleOpenDialog, handleCloseDialog, handleLoadTemplate, handleUpdateEditingConnection, 
    handleFetchModels, handleSaveAndTest, handleDelete, closeSnackbar, setSelectedConnectionId, handleTest,
    modelInfo, openModelInfo, handleOpenModelInfo, handleCloseModelInfo,
  } = useSettingsLogic();

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">Settings</Typography>
      </Box>

      {connectionsError && <Alert severity="error" sx={{ m: 2 }}>Error: {connectionsError}</Alert>}
      
      {isLoadingConnections && aiConnections.length === 0 && <CircularProgress sx={{ m: 2 }} />}

      <Paper sx={{ mt: 2, p: 2 }}>
        <Typography variant="h6" gutterBottom>Global Settings</Typography>
        <FormControlLabel control={<Switch checked={useDummyNarrator} onChange={(e) => setUseDummyNarrator(e.target.checked)} />} label="Use Dummy Narrator (for offline testing)" />
        <Divider sx={{ my: 1 }} />
        <FormControlLabel control={<Switch checked={themeMode === 'dark'} onChange={(e) => setThemeMode(e.target.checked ? 'dark' : 'light')} />} label="Dark Mode" />
      </Paper>
      
      <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>AI Connections</Typography>
      <Paper elevation={1} sx={{ flexGrow: 1, overflowY: 'auto' }}>
        <List>
            {aiConnections.map((conn) => (
              <React.Fragment key={conn.id}>
                <ListItem
                  disablePadding
                  secondaryAction={
                    <Box>
                      <IconButton edge="end" aria-label="edit" onClick={() => handleOpenDialog(conn)}><EditIcon fontSize="small" /></IconButton>
                      <IconButton edge="end" aria-label="delete" onClick={() => handleDelete(conn.id)}><DeleteIcon fontSize="small" color="error" /></IconButton>
                    </Box>
                  }
                >
                  <ListItemButton selected={selectedConnectionId === conn.id} onClick={() => setSelectedConnectionId(conn.id)}>
                    <ListItemText primary={conn.displayName} secondary={`${conn.modelName} (${conn.apiUrl.substring(0, 30)}...)`} />
                  </ListItemButton>
                </ListItem>
                <Divider />
              </React.Fragment>
            ))}
          </List>
      </Paper>
      <Button variant="contained" startIcon={<AddIcon />} onClick={() => handleOpenDialog()} sx={{ mt: 2 }}>
        Add New Connection
      </Button>

      <Dialog open={isDialogOpen} onClose={handleCloseDialog} fullWidth maxWidth="md" transitionDuration={{ enter: 200, exit: 0 }}>
        <DialogTitle>
          {dialogStep === 'select' ? 'Add a New Connection' : (editingConnection?.displayName || 'Connection Details')}
        </DialogTitle>
        <DialogContent>
          {dialogStep === 'select' && (
            <Stack spacing={2} sx={{ mt: 1 }}>
              <Typography>Start with a template for a popular provider.</Typography>
              <Grid container spacing={2}>
                {Object.entries(templates).filter(([key]) => key !== 'custom').map(([key, template]) => (
                  <Grid item xs={12} sm={6} key={key}>
                    <Card variant="outlined">
                      <CardActionArea onClick={() => handleLoadTemplate(key)} sx={{ p: 2, textAlign: 'center' }}>
                        <Typography variant="h6">{template.displayName}</Typography>
                      </CardActionArea>
                    </Card>
                  </Grid>
                ))}
              </Grid>
              <Divider>OR</Divider>
              <Button variant="outlined" onClick={() => handleLoadTemplate('custom')}>Start with a Blank Custom Connection</Button>
            </Stack>
          )}

          {dialogStep === 'details' && editingConnection && (
            // ... (The rest of the dialog content is correct)
            <Stack spacing={2.5} sx={{ mt: 1 }}>
              <TextField label="Connection Name" value={editingConnection.displayName} onChange={(e) => handleUpdateEditingConnection({ displayName: e.target.value })} autoFocus fullWidth />
              <TextField label="API Token (Key)" value={editingConnection.apiToken} onChange={(e) => handleUpdateEditingConnection({ apiToken: e.target.value })} fullWidth type="password" />

              <FormControl fullWidth>
                <InputLabel id="model-select-label">Model</InputLabel>
                <Select
                  labelId="model-select-label"
                  value={editingConnection.modelSlug}
                  label="Model"
                  onChange={(e) => {
                    const selectedModel = filteredModels.find(m => m.id === e.target.value);
                    handleUpdateEditingConnection({ modelSlug: e.target.value, modelName: selectedModel?.name || e.target.value });
                  }}
                  MenuProps={{ autoFocus: false }}
                >
                  <ListSubheader>
                    <TextField size="small" autoFocus placeholder="Type to filter models..." fullWidth
                      InputProps={{startAdornment: (<InputAdornment position="start"><SearchIcon /></InputAdornment>)}}
                      onChange={(e) => setModelSearchTerm(e.target.value)} onKeyDown={(e) => e.stopPropagation()} />
                  </ListSubheader>
                  {filteredModels.map(model => (
                    <MenuItem key={model.id} value={model.id}>
                      <Tooltip title={model.description || 'No description available.'} placement="right" enterDelay={500}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' }}>
                          <ListItemText primary={model.name} secondary={model.id} />
                          <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleOpenModelInfo(model); }} sx={{ display: { xs: 'flex', md: 'none' } }}>
                            <InfoOutlinedIcon fontSize="small" />
                          </IconButton>
                        </Box>
                      </Tooltip>
                    </MenuItem>
                  ))}
                  {filteredModels.length === 0 && <MenuItem disabled>No models match your search.</MenuItem>}
                </Select>
              </FormControl>
              
              {templates[editingConnection.displayName.toLowerCase()]?.supportsModelDiscovery && (
                <Button onClick={handleFetchModels} disabled={isFetchingModels} variant="outlined">
                  {isFetchingModels ? <CircularProgress size={24} /> : `Fetch All ${editingConnection.displayName} Models`}
                </Button>
              )}
              
              <CollapsibleSection title="Advanced Options" initiallyExpanded={false}>
                 <Stack spacing={2.5} sx={{mt: 2}}>
                    <TextField label="API URL" value={editingConnection.apiUrl} onChange={(e) => handleUpdateEditingConnection({ apiUrl: e.target.value })} fullWidth />
                    <TextField label="User Agent" value={editingConnection.userAgent || ''} onChange={(e) => handleUpdateEditingConnection({ userAgent: e.target.value })} fullWidth />
                    <FormControlLabel control={<Switch checked={editingConnection.functionCallingEnabled} onChange={(e) => handleUpdateEditingConnection({ functionCallingEnabled: e.target.checked })} />}
                        label="Function Calling Enabled" />
                 </Stack>
              </CollapsibleSection>
              
              {testStatus && <Alert severity={testStatus.type} sx={{ mt: 1 }}>{testStatus.text}</Alert>}
            </Stack>
          )}
        </DialogContent>
        <DialogActions sx={{ p: '16px 24px' }}>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          {dialogStep === 'details' && (
            <Stack direction="row" spacing={1}>
              <Button onClick={handleTest} startIcon={<WifiTetheringIcon />}>Test</Button>
              <Button onClick={handleSaveAndTest} variant="contained">Save Connection</Button>
            </Stack>
          )}
        </DialogActions>
      </Dialog>
      
      <Dialog open={openModelInfo} onClose={handleCloseModelInfo}>
        <DialogTitle>{modelInfo?.name}</DialogTitle>
        <DialogContent>
            <Typography variant="body1">{modelInfo?.description || "No description available."}</Typography>
            <Typography variant="caption" color="text.secondary" sx={{mt: 2, display: 'block'}}>ID: {modelInfo?.id}</Typography>
        </DialogContent>
        <DialogActions>
            <Button onClick={handleCloseModelInfo}>Close</Button>
        </DialogActions>
      </Dialog>
      
      <Snackbar open={snackbar.open} autoHideDuration={6000} onClose={closeSnackbar}>
        <Alert onClose={closeSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>{snackbar.message}</Alert>
      </Snackbar>
    </Box>
  );
};

export default SettingsScreen;
@@FILE: src/ui/screens/SourceDump.tsx
import React, { useEffect, useState } from 'react';
import { debugLog, errorLog } from '../../utils/debug';

// Small reusable copy button
function CopyButton({ text }: { text: string }) {
  const [copied, setCopied] = useState(false);
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch (err) {
      errorLog('Copy failed', err);
    }
  };
  return (
    <button
      onClick={handleCopy}
      style={{
        marginLeft: '6px',
        fontSize: '0.8rem',
        cursor: 'pointer',
        background: 'none',
        border: '1px solid #ccc',
        borderRadius: '4px',
        padding: '2px 5px',
      }}
    >
      {copied ? '' : ''}
    </button>
  );
}

function FolderView({
  name,
  node,
  level = 0,
}: {
  name: string;
  node: any;
  level?: number;
}) {
  const [open, setOpen] = useState(true);

  const isFolder = typeof node === 'object';
  if (!isFolder) return null;

  const folderIndent = { paddingLeft: `${level * 1.2}rem` };

  // Gather folder text for copy
  const folderText = node.__files
    ? node.__files.map((f: any) => f.content).join('\n')
    : '';

  return (
    <div style={{ ...folderIndent }}>
      <div
        style={{
          cursor: 'pointer',
          userSelect: 'none',
          fontWeight: 'bold',
        }}
        onClick={() => setOpen(!open)}
      >
        {open ? '' : ''} {name}
        {folderText && <CopyButton text={folderText} />}
      </div>

      {open && (
        <>
          {node.__files &&
            node.__files.map((file: any) => (
              <div key={file.name} style={{ paddingLeft: '1.5rem' }}>
                 {file.name}
                <CopyButton text={file.content} />
              </div>
            ))}
          {Object.entries(node)
            .filter(([k]) => k !== '__files')
            .map(([childName, childNode]) => (
              <FolderView
                key={childName}
                name={childName}
                node={childNode}
                level={level + 1}
              />
            ))}
        </>
      )}
    </div>
  );
}

export default function SourceDump() {
  const [dumpText, setDumpText] = useState('');
  const [tree, setTree] = useState<any>(null);

  useEffect(() => {
    fetch(`/source-dump.txt?_=${Date.now()}`)
      .then((res) => res.text())
      .then((text) => {
        setDumpText(text);
        setTree(parseDumpToTree(text));
      });
  }, []);

  if (!dumpText) return <div>Loading...</div>;

  return (
    <div style={{ padding: '1rem', fontFamily: 'monospace' }}>
      <h2>
         Copy Entire Repo
        <CopyButton text={dumpText} />
      </h2>

      {tree && <FolderView name="src" node={tree.src || tree} />}

      <hr style={{ margin: '2rem 0' }} />
      <h3>Full Dump:</h3>
      <pre
        style={{
          whiteSpace: 'pre-wrap',
          fontSize: '0.85rem',
          maxHeight: '400px',
          overflow: 'auto',
        }}
      >
        {dumpText}
      </pre>
    </div>
  );
}

function parseDumpToTree(dump: string) {
  const lines = dump.split('\n');
  const root: any = { __files: [] };;
  let currentFolder: string[] = [];
  let currentFile: { name: string; content: string } | null = null;

  const ensureFolder = (pathParts: string[]) => {
    let node = root;
    for (const part of pathParts) {
      if (!node[part]) node[part] = { __files: [] };
      node = node[part];
    }
    return node;
  };

  for (let line of lines) {
    if (line.startsWith('@@FOLDER:')) {
      const folderPath = line.replace('@@FOLDER: ', '').trim();
      currentFolder = folderPath.split('/').slice(1); // remove 'src'
      ensureFolder(currentFolder);
    } else if (line.startsWith('@@FILE:')) {
      const filePath = line.replace('@@FILE: ', '').trim();
      const parts = filePath.split('/');
      const fileName = parts.pop()!;
      currentFolder = parts.slice(1);
      const folderNode = ensureFolder(currentFolder);
      currentFile = { name: fileName, content: '' };
      folderNode.__files.push(currentFile);
    } else {
      if (currentFile) currentFile.content += line + '\n';
    }
  }

  return root;
}

@@FILE: src/ui/screens/WorldStateScreen.tsx
// src/ui/screens/WorldStateScreen.tsx
import React from 'react';
import {
  Box, Typography, Button, IconButton, Paper, 
  Alert, List, Collapse, Checkbox, TextField, Dialog, DialogTitle, DialogContent,
  DialogActions, Divider,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import DeleteIcon from '@mui/icons-material/Delete';
import EditIcon from '@mui/icons-material/Edit';
import { useGameStateStore, selectWorldStatePinnedKeys } from '../../state/useGameStateStore'; // Selectors imported
import { useWorldStateViewLogic } from '../../utils/hooks/useWorldStateViewLogic';
import { WorldStateItemRow } from '../components/WorldStateItemRow';
import { debugLog, errorLog } from '../../utils/debug';

const WorldStateScreen: React.FC = () => {
  const worldStatePinnedKeys = useGameStateStore(selectWorldStatePinnedKeys); // Use selector
  const { gameError } = useGameStateStore(); // Top-level state is fine

  // --- Keep your existing DEBUG LINES here for verification ---
  debugLog('%c[WorldStateScreen.tsx] Component re-rendered.', 'color: #008080; font-weight: bold;');
  debugLog('[WorldStateScreen.tsx] Pinned Keys (from store selector):', worldStatePinnedKeys);
  // --- END DEBUG LINES ---

  const {
    groupedByCategory,
    // All other state variables (expandedCategories, editingCategory, etc.) are now correctly sourced from the hook:
    expandedCategories,
    expandedEntities,
    editingCategory,
    newCategoryName,
    editingEntity,
    newEntityName,
    isAnyChildPinned, // These methods come from the hook
    areAllChildrenPinned, // These methods come from the hook
    handleToggleCategoryExpand, // Local handlers returned by hook
    handleToggleEntityExpand,   // Local handlers returned by hook
    handleToggleCategoryPin,    // Local handlers returned by hook
    handleToggleEntityPin,      // Local handlers returned by hook
    handleStartRenameCategory,
    handleConfirmRenameCategory,
    setNewCategoryName,
    handleStartRenameEntity,
    handleConfirmRenameEntity,
    setNewEntityName,
    cancelEdit,
    // Actions passed directly from store (for clarity)
    deleteWorldCategory,
    deleteWorldEntity,
    editWorldKeyValue,
    deleteWorldKey,
    toggleWorldStatePin, // Ensure actions from store are correctly accessible
  } = useWorldStateViewLogic(); 

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', p: 2 }}>
      <Box sx={{ mb: 2 }}>
        <Typography variant="h5" component="h1">World State</Typography>
      </Box>

      {gameError && (<Alert severity="error" sx={{ m: 2 }}>Error: {gameError}</Alert>)}

      {Object.keys(groupedByCategory).length === 0 ? (
        <Box sx={{ p: 3, textAlign: 'center', mt: 4 }}>
          <Typography variant="body1" color="text.secondary">No world state data available.</Typography>
        </Box>
      ) : (
        <Paper elevation={1} sx={{ flexGrow: 1, m: 2, p: 2, overflowY: 'auto' }}>
          {Object.entries(groupedByCategory).map(([category, entities]) => (
            <Box key={category} sx={{ mb: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
              <Box sx={{ display: 'flex', alignItems: 'center', p: 1.5, cursor: 'pointer', backgroundColor: 'action.hover' }} onClick={() => handleToggleCategoryExpand(category)}>
                <IconButton size="small" sx={{ mr: 1 }}>{expandedCategories.has(category) ? <ExpandLessIcon /> : <ExpandMoreIcon />}</IconButton>
                <Typography variant="h6" sx={{ flexGrow: 1 }}>{category}</Typography>
                <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleStartRenameCategory(category); }}><EditIcon fontSize="small" /></IconButton>
                {/* Use the hook's own methods correctly */}
                <Checkbox checked={areAllChildrenPinned(category)} indeterminate={isAnyChildPinned(category) && !areAllChildrenPinned(category)} onClick={(e) => { e.stopPropagation(); handleToggleCategoryPin(category); }} />
                <IconButton size="small" onClick={(e) => { e.stopPropagation(); deleteWorldCategory(category); }}><DeleteIcon fontSize="small" color="error" /></IconButton>
              </Box>
              <Collapse in={expandedCategories.has(category)}>
                <Divider />
                <List component="div" disablePadding sx={{ pl: 2 }}>
                  {Object.entries(entities).map(([entity, variables]) => {
                    const entityPath = `${category}.${entity}`;
                    if (entity === '@@_direct') {
                      return Object.entries(variables).map(([varName, value]) => (
                        <WorldStateItemRow key={`${category}.${varName}`} itemKey={`${category}.${varName}`} value={value} onDelete={deleteWorldKey} onEdit={editWorldKeyValue} isPinned={worldStatePinnedKeys.includes(`${category}.${varName}`)} onTogglePin={(key) => toggleWorldStatePin(key, 'variable')} />
                      ));
                    }
                    return (
                      <Box key={entity} sx={{ mb: 1, border: '1px dashed', borderColor: 'divider', borderRadius: 1, mt: 1 }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', p: 1, cursor: 'pointer' }} onClick={() => handleToggleEntityExpand(category, entity)}>
                          <IconButton size="small" sx={{ mr: 1 }}>{expandedEntities.has(entityPath) ? <ExpandLessIcon /> : <ExpandMoreIcon />}</IconButton>
                          <Typography variant="subtitle1" sx={{ flexGrow: 1 }}>{entity}</Typography>
                          <IconButton size="small" onClick={(e) => { e.stopPropagation(); handleStartRenameEntity([category, entity]); }}><EditIcon fontSize="small" /></IconButton>
                           {/* Use the hook's own methods correctly */}
                          <Checkbox checked={areAllChildrenPinned(entityPath)} indeterminate={isAnyChildPinned(entityPath) && !areAllChildrenPinned(entityPath)} onClick={(e) => { e.stopPropagation(); handleToggleEntityPin(entityPath); }} />
                          <IconButton size="small" onClick={(e) => { e.stopPropagation(); deleteWorldEntity(category, entity); }}><DeleteIcon fontSize="small" color="error" /></IconButton>
                        </Box>
                        <Collapse in={expandedEntities.has(entityPath)}>
                          <Divider />
                          <Box sx={{ p: 1.5 }}>
                            {Object.entries(variables).map(([varName, value]) => (
                              <WorldStateItemRow key={varName} itemKey={`${entityPath}.${varName}`} value={value} onDelete={deleteWorldKey} onEdit={editWorldKeyValue} isPinned={worldStatePinnedKeys.includes(`${entityPath}.${varName}`)} onTogglePin={(key) => toggleWorldStatePin(key, 'variable')} />
                            ))}
                          </Box>
                        </Collapse>
                      </Box>
                    );
                  })}
                </List>
              </Collapse>
            </Box>
          ))}
        </Paper>
      )}

      <Dialog open={!!editingCategory} onClose={cancelEdit}>
        <DialogTitle>Rename Category</DialogTitle>
        <DialogContent><TextField autoFocus margin="dense" label="New Category Name" type="text" fullWidth variant="outlined" value={newCategoryName} onChange={(e) => setNewCategoryName(e.target.value)} /></DialogContent>
        <DialogActions><Button onClick={cancelEdit}>Cancel</Button><Button onClick={handleConfirmRenameCategory}>Rename</Button></DialogActions>
      </Dialog>

      <Dialog open={!!editingEntity} onClose={cancelEdit}>
        <DialogTitle>Rename Entity</DialogTitle>
        <DialogContent><TextField autoFocus margin="dense" label="New Entity Name" type="text" fullWidth variant="outlined" value={newEntityName} onChange={(e) => setNewEntityName(e.target.value)} /></DialogContent>
        <DialogActions><Button onClick={cancelEdit}>Cancel</Button><Button onClick={handleConfirmRenameEntity}>Rename</Button></DialogActions>
      </Dialog>
    </Box>
  );
};

export default WorldStateScreen;
@@FOLDER: src/utils
@@FILE: src/utils/debug.ts
// src/utils/debug.ts
import { useSettingsStore } from '../state/useSettingsStore';

/**
 * A centralized logging utility that conditionally logs messages based on a debug setting.
 * This function should be used in place of direct `console.log` for debug messages.
 * @param message The message to log.
 * @param optionalParams Any additional data to log.
 */
export const debugLog = (message?: any, ...optionalParams: any[]) => {
  const { enableDebugLogging } = useSettingsStore.getState();
  if (enableDebugLogging) {
    console.log(message, ...optionalParams);
  }
};

/**
 * A centralized error logging utility that always logs errors, regardless of debug setting.
 * @param message The error message to log.
 * @param optionalParams Any additional error data to log.
 */
export const errorLog = (message?: any, ...optionalParams: any[]) => {
  console.error(message, ...optionalParams);
};
@@FILE: src/utils/diceRoller.ts
// src/utils/diceRoller.ts

/**
 * Represents the result of a dice roll.
 */
interface DiceRollResult {
  rolls: number[];
  sum: number;
  modifier: number;
  formula: string;
}

export const DiceRoller = {
  /**
   * Rolls dice based on a formula (e.g., "1d20", "2d6+3").
   * Supports basic NdN and optional +M or -M.
   * @param formula The dice rolling formula string.
   * @returns A DiceRollResult object.
   */
  roll: (formula: string): DiceRollResult => {
    const parts = formula.match(/^(\d*)d(\d+)([\+\-]\d+)?$/i);
    if (!parts) {
      throw new Error(`Invalid dice formula: ${formula}. Expected format: NdN[+M|-M]`);
    }

    const numDice = parseInt(parts[1] || '1', 10);
    const numSides = parseInt(parts[2], 10);
    const modifier = parts[3] ? parseInt(parts[3], 10) : 0;

    const rolls: number[] = [];
    let sum = 0;

    for (let i = 0; i < numDice; i++) {
      const roll = Math.floor(Math.random() * numSides) + 1;
      rolls.push(roll);
      sum += roll;
    }

    return {
      rolls,
      sum: sum + modifier,
      modifier,
      formula,
    };
  },

  /**
   * Formats a DiceRollResult into a human-readable string.
   * @param result The DiceRollResult to format.
   * @returns A formatted string (e.g., "Roll: 2d6 -> [3, 5] = 8").
   */
  format: (result: DiceRollResult): string => {
    let summary = `Roll: ${result.formula} -> [${result.rolls.join(', ')}]`;
    if (result.modifier !== 0) {
      summary += `${result.modifier >= 0 ? '+' : ''}${result.modifier}`;
    }
    summary += ` = ${result.sum}`;
    return summary;
  },
};
@@FILE: src/utils/formatDate.ts
// src/utils/formatDate.ts

/**
 * Formats an ISO 8601 date string into a more human-readable local date and time.
 * @param isoString The date string in ISO 8601 format (e.g., "2023-10-27T10:00:00Z").
 * @returns A formatted date string (e.g., "October 27, 2023, 10:00 AM").
 */
export function formatIsoDateForDisplay(isoString: string): string {
  try {
    const date = new Date(isoString);
    if (isNaN(date.getTime())) {
      // Invalid date string
      return "Invalid Date";
    }
    // Options for a readable format. Adjust as needed.
    const options: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: true, // Use 12-hour clock with AM/PM
    };
    return new Intl.DateTimeFormat(undefined, options).format(date);
  } catch (error) {
    console.error("Error formatting date:", error);
    return "Error formatting date";
  }
}

/**
 * Converts a Firestore Timestamp-like object to an ISO string if applicable.
 * If not a Timestamp, returns the value unchanged.
 */
export function toIsoStringIfTimestamp(value: any): string {
  return value instanceof Object && 'toDate' in value
    ? value.toDate().toISOString()
    : value;
}


@@FILE: src/utils/hash.ts
// src/utils/hash.ts

import type { AiSettings, StackInstructions } from '../models';


/**
 * Generates a simple, non-cryptographic hash from a string.
 * This is suitable for content deduplication checks within the application.
 *
 * Based on the 'sdbm' hash algorithm.
 * @param str The input string to hash.
 * @returns A string representation of the hash.
 */
export function generateContentHash(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = char + (hash << 6) + (hash << 16) - hash; // sdbm hash algorithm
  }
  // Convert to unsigned 32-bit integer and then to hex string
  return (hash >>> 0).toString(16);
}

/**
 * Creates a normalized string representation of key PromptCard content for hashing.
 * This function defines which fields are considered for deduplication.
 * It's important that this function is deterministic: the same input should always
 * produce the same output string.
 * @param card The PromptCard object (or partial object containing relevant fields).
 * @returns A string representing the key content of the card.
 */
export function getPromptCardContentForHash(card: {
  title: string;
  description: string | null;
  prompt: string;
  firstTurnOnlyBlock: string;
  stackInstructions: StackInstructions | string; // Can be object or string, needs to be stringified
  emitSkeleton: string;
  worldStateInit: string;
  gameRules: string;
  tags: string[];
  functionDefs: string;
  aiSettings: AiSettings; // Include AI settings in hash as they affect "content"
  helperAiSettings: AiSettings; // Include helper AI settings
}): string {
  // Use a consistent order and join method to ensure same content yields same hash
  // Sort tags for consistent hashing regardless of input order
  const sortedTags = [...(card.tags || [])].sort().join(',');

  // Stringify complex objects for consistent hashing.
  // We need to handle both the structured StackInstructions object and a potential raw JSON string input.
  const stackInstructionsString = typeof card.stackInstructions === 'object'
    ? JSON.stringify(card.stackInstructions)
    : (card.stackInstructions || '');

  // Stringify AI settings objects consistently
  const aiSettingsString = JSON.stringify(card.aiSettings);
  const helperAiSettingsString = JSON.stringify(card.helperAiSettings);

  // Concatenate all relevant content fields.
  // Order matters here for deterministic hashing.
  return [
    card.title,
    card.description || '', // Treat null as empty string for hashing
    card.prompt,
    card.firstTurnOnlyBlock,
    stackInstructionsString,
    card.emitSkeleton,
    card.worldStateInit,
    card.gameRules,
    aiSettingsString,
    helperAiSettingsString,
    sortedTags,
    card.functionDefs,
  ].join('|||'); // Use a distinctive separator to avoid accidental matches
}
@@FOLDER: src/utils/hooks
@@FILE: src/utils/hooks/useGameScreenLogic.ts
// src/utils/hooks/useGameScreenLogic.ts

import { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuthStore } from '../../state/useAuthStore';
import { useGameStateStore, selectCurrentGameState, selectConversationHistory } from '../../state/useGameStateStore';
import { DiceRoller } from '../../utils/diceRoller';
import type { GameState } from '../../models';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useSettingsStore } from '../../state/useSettingsStore'; // <-- NEW
import { debugLog, errorLog } from '../../utils/debug'; // <-- NEW

export const useGameScreenLogic = () => {
  const navigate = useNavigate();
  const { user } = useAuthStore();

  const enableDebugLogging = useSettingsStore(state => state.enableDebugLogging); // <-- NEW
  const typingSpeedMs = useSettingsStore(state => state.textGenerationSpeedMs);   // <-- NEW

  const currentSnapshot = useGameStateStore(state => state.currentSnapshot);
  const currentGameState = useGameStateStore(selectCurrentGameState);
  const conversationHistory = useGameStateStore(selectConversationHistory);
  const narratorInputText = useGameStateStore(state => state.narratorInputText);
  const gameLoading = useGameStateStore(state => state.gameLoading);
  const isProcessingTurn = useGameStateStore(state => state.isProcessingTurn);
  const gameError = useGameStateStore(state => state.gameError);
  const activePromptCard = usePromptCardStore(state => state.activePromptCard);

  const processPlayerAction = useGameStateStore(state => state.processPlayerAction);
  const updateNarratorInputText = useGameStateStore(state => state.updateNarratorInputText);
  const processFirstNarratorTurn = useGameStateStore(state => state.processFirstNarratorTurn);

  const [showRollDialog, setShowRollDialog] = useState(false);
  const [rollFormula, setRollFormula] = useState("2d6");
  const [snackbar, setSnackbar] = useState<{
    open: boolean;
    message: string;
    severity: 'success' | 'error' | 'info' | 'warning';
  }>({
    open: false,
    message: '',
    severity: 'info',
  });
  
  const [displayedCurrentNarration, setDisplayedCurrentNarration] = useState('');

  const logContainerRef = useRef<HTMLDivElement>(null);
  const initialTurnTriggeredForSnapshot = useRef<string | null>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (enableDebugLogging) {
      debugLog(`[useGameScreenLogic.ts] useEffect (auto-scroll): conversationHistory changed. Count: ${conversationHistory.length}`);
    }
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [conversationHistory, enableDebugLogging]);

  useEffect(() => {
    if (enableDebugLogging) {
      debugLog(`[useGameScreenLogic.ts] useEffect (first turn check). Snapshot ID: ${currentSnapshot?.id}, gameLoading: ${gameLoading}, currentTurn: ${currentSnapshot?.currentTurn}`);
    }

    if (!currentSnapshot || gameLoading) {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Skipping first turn (no snapshot or loading).');
      return;
    }

    const needsFirstTurn =
      currentSnapshot.currentTurn === 0 &&
      currentSnapshot.conversationHistory?.length === 1 &&
      initialTurnTriggeredForSnapshot.current !== currentSnapshot.id;

    if (needsFirstTurn) {
      initialTurnTriggeredForSnapshot.current = currentSnapshot.id;
      if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] Triggering first narrator turn for snapshot ${currentSnapshot.id}`);
      processFirstNarratorTurn();
    } else {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] First turn not needed or already triggered.');
    }
  }, [currentSnapshot, gameLoading, processFirstNarratorTurn, enableDebugLogging]);

  useEffect(() => {
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    const fullNarration = currentGameState?.narration || '';
    const enableStreaming = activePromptCard?.aiSettings?.streaming ?? true;

    if (enableStreaming && fullNarration.length > 0 && !isProcessingTurn) {
      setDisplayedCurrentNarration('');
      let i = 0;
      const typeCharacter = () => {
        if (i < fullNarration.length) {
          setDisplayedCurrentNarration((prev) => prev + fullNarration.charAt(i));
          i++;
          typingTimeoutRef.current = setTimeout(typeCharacter, typingSpeedMs);
        } else {
          typingTimeoutRef.current = null;
        }
      };
      typingTimeoutRef.current = setTimeout(typeCharacter, typingSpeedMs);
    } else if (!enableStreaming) {
      setDisplayedCurrentNarration(fullNarration);
    }

    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, [currentGameState?.narration, activePromptCard?.aiSettings?.streaming, isProcessingTurn, typingSpeedMs]);

  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] Snackbar: "${message}" (${severity})`);
    setSnackbar({
      open: true,
      message,
      severity: severity as 'success' | 'error' | 'info' | 'warning',
    });
    
  }, [enableDebugLogging]);

  const handleSendAction = useCallback(async () => {
    if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] handleSendAction: Input: "${narratorInputText}"`);
    if (narratorInputText.trim() === '' || isProcessingTurn) {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Skipping send  empty or already processing.');
      return;
    }
    try {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
      }
      setDisplayedCurrentNarration(currentGameState?.narration || '');
      await processPlayerAction(narratorInputText);
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] processPlayerAction completed.');
    } catch (e) {
      errorLog('[useGameScreenLogic.ts] Error in handleSendAction:', e);
      showSnackbar(`Failed to process action: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  }, [narratorInputText, isProcessingTurn, processPlayerAction, showSnackbar, currentGameState?.narration, enableDebugLogging]);

  const handleRollDice = useCallback(async () => {
    if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] Rolling formula: ${rollFormula}`);
    try {
      const result = DiceRoller.roll(rollFormula);
      const summary = DiceRoller.format(result);
      if (enableDebugLogging) debugLog(`[useGameScreenLogic.ts] Dice result: ${summary}`);

      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
      }
      setDisplayedCurrentNarration(currentGameState?.narration || '');

      await processPlayerAction(`I roll the dice (${rollFormula}) and get the following result:\n${summary}`);
      showSnackbar(`Rolled ${rollFormula}: ${summary}`, 'success');
      setShowRollDialog(false);
    } catch (e) {
      errorLog('[useGameScreenLogic.ts] Error in handleRollDice:', e);
      showSnackbar(`Failed to roll dice: ${e instanceof Error ? e.message : 'Invalid formula'}`, 'error');
    }
  }, [rollFormula, processPlayerAction, showSnackbar, currentGameState?.narration, enableDebugLogging]);

  const handleOpenRollDialog = useCallback(() => {
    if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Opening roll dialog.');
    setShowRollDialog(true);
  }, [enableDebugLogging]);

  const handleKeyPress = useCallback((event: React.KeyboardEvent) => {
    if (event.key === 'Enter' && !event.shiftKey) {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Enter pressed  sending action.');
      event.preventDefault();
      handleSendAction();
    }
  }, [handleSendAction, enableDebugLogging]);

  const closeSnackbar = useCallback(() => {
    if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Closing snackbar.');
    setSnackbar(prev => ({ ...prev, open: false }));
  }, [enableDebugLogging]);

  return {
    isReady: !!user && !!currentSnapshot && !!currentGameState,
    isLoading: gameLoading,
    isProcessingTurn,
    gameError,
    conversationHistory,
    narratorInputText,
    logContainerRef,
    snackbar,
    displayedCurrentNarration,
    fullLatestNarration: currentGameState?.narration || '',
    enableStreaming: activePromptCard?.aiSettings?.streaming ?? true,

    rollDialog: {
      open: showRollDialog,
      formula: rollFormula,
    },

    handleGoToLogin: () => {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Navigating to /login');
      navigate('/login');
    },
    handleSendAction,
    handleInputChange: updateNarratorInputText,
    handleKeyPress,
    handleRollDice,
    handleOpenRollDialog,
    handleCloseRollDialog: () => {
      if (enableDebugLogging) debugLog('[useGameScreenLogic.ts] Closing roll dialog.');
      setShowRollDialog(false);
    },
    handleRollFormulaChange: setRollFormula,
    closeSnackbar,
  };
};

@@FILE: src/utils/hooks/useLogViewerLogic.ts
// src/utils/hooks/useLogViewerLogic.ts
import { useState, useEffect, useCallback } from 'react';
import { useLogStore } from '../../state/useLogStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { LogViewMode } from '../../utils/types';

export const useLogViewerLogic = () => {
  // 1. Consume global stores
  const { logEntries, selectedLogViewModes, isLoading, error, setLogEntries, setSelectedLogViewModes } = useLogStore();
  const { currentSnapshot } = useGameStateStore();

  // 2. Local UI state
  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
  const isMenuOpen = Boolean(menuAnchorEl);

  // 3. Data synchronization effect
  useEffect(() => {
    // When the game snapshot changes, update the logs in the log store
    setLogEntries(currentSnapshot?.logs || []);
  }, [currentSnapshot, setLogEntries]);

  // 4. Handlers
  const handleMenuClick = useCallback((event: React.MouseEvent<HTMLButtonElement>) => {
    setMenuAnchorEl(event.currentTarget);
  }, []);

  const handleMenuClose = useCallback(() => {
    setMenuAnchorEl(null);
  }, []);

  const handleCheckboxChange = useCallback((mode: LogViewMode) => {
    const newSelection = selectedLogViewModes.includes(mode)
      ? selectedLogViewModes.filter((m) => m !== mode)
      : [...selectedLogViewModes, mode];
    setSelectedLogViewModes(newSelection);
  }, [selectedLogViewModes, setSelectedLogViewModes]);

  // 5. Return Clean API
  return {
    logEntries,
    selectedLogViewModes,
    isLoading,
    error,
    menuAnchorEl,
    isMenuOpen,
    handleMenuClick,
    handleMenuClose,
    handleCheckboxChange,
  };
};
@@FILE: src/utils/hooks/useLongPress.ts
// src/utils/hooks/useLongPress.ts

import React, { useRef, useCallback } from 'react';

/**
 * Custom hook to detect long press events.
 * @param onLongPress The callback function to execute on long press.
 * @param onClick The callback function to execute on a regular click (optional).
 * @param options Configuration options for long press.
 * @param options.delay The duration in milliseconds for a press to be considered a long press (default: 500).
 */
export function useLongPress<T extends HTMLElement>(
  onLongPress: (event: React.MouseEvent<T> | React.TouchEvent<T>) => void,
  onClick?: (event: React.MouseEvent<T> | React.TouchEvent<T>) => void,
  { delay = 500 } = {}
) {
  // Initialize useRef with null to satisfy the 'initialValue' requirement
  // and extend the type to allow null, as a timeout reference might be null initially
  const timeout = useRef<NodeJS.Timeout | null>(null);
  // Initialize useRef with null and extend the type to allow null,
  // as the target element might not be immediately available or might be cleared
  const target = useRef<T | null>(null);

  const start = useCallback(
    (event: React.MouseEvent<T> | React.TouchEvent<T>) => {
      // Stop the event from bubbling to parent elements
      event.stopPropagation();

      // Prevent context menu on long press on some browsers
      event.preventDefault();

      target.current = event.currentTarget as T;
      timeout.current = setTimeout(() => {
        onLongPress(event);
        // Assign null instead of undefined, as the type for target.current is T | null
        target.current = null; // Clear target after long press
      }, delay);
    },
    [onLongPress, delay]
  );

  const clear = useCallback(
    (event: React.MouseEvent<T> | React.TouchEvent<T>, shouldClick = true) => {
      // Clear the timeout if it exists
      if (timeout.current) {
        clearTimeout(timeout.current);
      }

      if (shouldClick && onClick && target.current === event.currentTarget) {
        onClick(event);
      }
      // Assign null instead of undefined
      target.current = null;
    },
    [onClick]
  );

  return {
    onMouseDown: start,
    onTouchStart: start,
    onMouseUp: (e: React.MouseEvent<T>) => clear(e),
    onMouseLeave: (e: React.MouseEvent<T>) => clear(e, false),
    onTouchEnd: (e: React.TouchEvent<T>) => clear(e),
    onTouchCancel: (e: React.TouchEvent<T>) => clear(e, false),
  };
}
@@FILE: src/utils/hooks/usePromptCardManagerLogic.ts
// src/utils/hooks/usePromptCardManagerLogic.ts
import { useState, useEffect, useCallback } from 'react';
import type { User } from 'firebase/auth';
import { usePromptCardStore } from '../../state/usePromptCardStore';
import { useGameStateStore } from '../../state/useGameStateStore';
import { useSettingsStore } from '../../state/useSettingsStore';
import type { PromptCard, NewPromptCardData } from '../../models';
import {
  defaultStackInstructions,
  defaultAiSettingsInCard,
  DEFAULT_FIRST_TURN_PROMPT_BLOCK,
  DEFAULT_EMIT_SKELETON_STRING,
} from '../../data/config/promptCardDefaults';
import { useNavigate } from 'react-router-dom';

export const usePromptCardManagerLogic = (user: User | null) => {
  const navigate = useNavigate();

  // 1. All state and store hooks are moved here
  const {
    promptCards,
    activePromptCard,
    isLoading,
    error,
    fetchPromptCards,
    setActivePromptCard,
    addPromptCard,
    updatePromptCard,
    duplicatePromptCard,
    deletePromptCard,
    importPromptCards,
    exportPromptCard,
  } = usePromptCardStore();

  const { initializeGame } = useGameStateStore();
  const { aiConnections, fetchAiConnections } = useSettingsStore();

  const [localEditedCard, setLocalEditedCard] = useState<PromptCard | null>(null);
  const [isCardDirty, setIsCardDirty] = useState(false);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [saveAsNewTitle, setSaveAsNewTitle] = useState('');
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' | 'info' | 'warning' }>({ open: false, message: '', severity: 'info' });

  // 2. All useEffects are moved here
  useEffect(() => {
    if (user?.uid) {
      fetchPromptCards(user.uid);
      fetchAiConnections(user.uid);
    }
  }, [user?.uid, fetchPromptCards, fetchAiConnections]);

  useEffect(() => {
    setLocalEditedCard(activePromptCard ? { ...activePromptCard } : null);
    setIsCardDirty(false);
  }, [activePromptCard]);

  // 3. All handler functions are moved here and wrapped in useCallback
  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbar({ open: true, message, severity });
  }, []);

  const handleCardSelect = useCallback((card: PromptCard) => {
    if (isCardDirty) {
      showSnackbar('Unsaved changes will be lost if you switch cards.', 'warning');
    }
    setActivePromptCard(card);
  }, [isCardDirty, setActivePromptCard, showSnackbar]);

  const handleLocalCardChange = useCallback((updatedCard: PromptCard) => {
    setLocalEditedCard(updatedCard);
    setIsCardDirty(JSON.stringify(updatedCard) !== JSON.stringify(activePromptCard));
  }, [activePromptCard]);

  const handleSaveCard = useCallback(async (saveAsNew: boolean = false) => {
    if (!user?.uid || !localEditedCard) return;

    try {
      let savedCard: PromptCard | null = null;
      if (saveAsNew) {
        const newCardData: NewPromptCardData = {
          ...localEditedCard,
          title: saveAsNewTitle || `${localEditedCard.title} (Copy)`,
        };
        savedCard = await addPromptCard(user.uid, newCardData);
      } else {
        savedCard = await updatePromptCard(user.uid, localEditedCard.id, localEditedCard);
      }

      if (savedCard) {
        setActivePromptCard(savedCard);
        showSnackbar('Card saved successfully!', 'success');
      }
    } catch (e) {
      showSnackbar(`Failed to save card: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    } finally {
      setShowSaveDialog(false);
      setSaveAsNewTitle('');
    }
  }, [user, localEditedCard, saveAsNewTitle, addPromptCard, updatePromptCard, setActivePromptCard, showSnackbar]);

  const handleRevert = useCallback(() => {
    if (activePromptCard) {
      setLocalEditedCard({ ...activePromptCard });
      setIsCardDirty(false);
      showSnackbar('Changes reverted.', 'info');
    }
  }, [activePromptCard, showSnackbar]);

  const handleNewCard = useCallback(async () => {
    if (!user?.uid) {
      showSnackbar('Must be logged in to create a new card.', 'error');
      return;
    }
    const defaultConnectionId = aiConnections.length > 0 ? aiConnections[0].id : "";
    const newCardData: NewPromptCardData = {
      title: "New Prompt Card",
      prompt: "This is a new prompt card. Describe the setting and your character's starting situation.",
      description: null,
      firstTurnOnlyBlock: DEFAULT_FIRST_TURN_PROMPT_BLOCK,
      stackInstructions: defaultStackInstructions,
      emitSkeleton: DEFAULT_EMIT_SKELETON_STRING,
      worldStateInit: '',
      gameRules: '',
      aiSettings: { ...defaultAiSettingsInCard, selectedConnectionId: defaultConnectionId },
      helperAiSettings: { ...defaultAiSettingsInCard, selectedConnectionId: defaultConnectionId },
      isHelperAiEnabled: false,
      tags: [],
      isExample: false,
      functionDefs: '',
      isPublic: false,
    };
    const createdCard = await addPromptCard(user.uid, newCardData);
    if (createdCard) {
      setActivePromptCard(createdCard);
      showSnackbar('New card created successfully!', 'success');
    }
  }, [user, aiConnections, addPromptCard, setActivePromptCard, showSnackbar]);

  const handleDeleteCard = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    await deletePromptCard(user.uid, cardId);
    showSnackbar('Card deleted successfully!', 'success');
  }, [user, deletePromptCard, showSnackbar]);

  const handleDuplicateCard = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    const duplicated = await duplicatePromptCard(user.uid, cardId);
    if (duplicated) {
      showSnackbar('Card duplicated successfully!', 'success');
    }
  }, [user, duplicatePromptCard, showSnackbar]);

  const handleImport = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !user?.uid) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const content = e.target?.result as string;
        const parsed = JSON.parse(content) as NewPromptCardData | NewPromptCardData[];
        const cardsToImport = Array.isArray(parsed) ? parsed : [parsed];
        await importPromptCards(user.uid, cardsToImport);
        showSnackbar(`Successfully imported ${cardsToImport.length} cards!`, 'success');
      } catch (err) {
        showSnackbar(`Failed to import cards: ${err instanceof Error ? err.message : 'Invalid JSON'}`, 'error');
      }
    };
    reader.readAsText(file);
    event.target.value = ''; // Reset file input
  }, [user, importPromptCards, showSnackbar]);

  const handleExport = useCallback(async (cardId: string) => {
    if (!user?.uid) return;
    const card = await exportPromptCard(user.uid, cardId);
    if (card) {
      const json = JSON.stringify(card, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `prompt_card_${card.title.replace(/\s/g, '_')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showSnackbar(`Card "${card.title}" exported.`, 'success');
    }
  }, [user, exportPromptCard, showSnackbar]);

  const handleStartGame = useCallback(async () => {
    if (!user?.uid || !activePromptCard) return;
    if (isCardDirty) {
      showSnackbar('Please save changes before starting a game.', 'warning');
      return;
    }
    await initializeGame(user.uid, activePromptCard.id);
    navigate('/game');
  }, [user, activePromptCard, isCardDirty, initializeGame, navigate, showSnackbar]);

  // 4. Return a clean API for the component
  return {
    // State for Rendering
    isLoading,
    error,
    promptCards,
    activePromptCard,
    localEditedCard,
    isCardDirty,
    aiConnections,
    saveDialog: {
      open: showSaveDialog,
      title: saveAsNewTitle
    },
    snackbar,

    // Functions for Event Handlers
    handleCardSelect,
    handleLocalCardChange,
    handleSaveCard,
    handleRevert,
    handleNewCard,
    handleDeleteCard,
    handleDuplicateCard,
    handleImport,
    handleExport,
    handleStartGame,
    setSaveDialog: setShowSaveDialog,
    setSaveAsNewTitle,
    closeSnackbar: () => setSnackbar(prev => ({ ...prev, open: false })),
  };
};
@@FILE: src/utils/hooks/useSettingsLogic.ts
// src/utils/hooks/useSettingsLogic.ts
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useAuthStore } from '../../state/useAuthStore';
import { useSettingsStore } from '../../state/useSettingsStore';
import type { AiConnection } from '../../models';
import { aiClient } from '../../logic/aiClient';
import { aiConnectionTemplates } from '../../data/config/aiConnectionTemplates';
import type { ModelInfo } from '../../data/config/aiConnectionTemplates';

export const useSettingsLogic = () => {
  const { user } = useAuthStore();
  const settingsStore = useSettingsStore();

  const [dialogStep, setDialogStep] = useState<'select' | 'details'>('select');
  const [editingConnection, setEditingConnection] = useState<AiConnection | null>(null);
  const [availableModels, setAvailableModels] = useState<ModelInfo[]>([]);
  const [isFetchingModels, setIsFetchingModels] = useState(false);
  const [modelSearchTerm, setModelSearchTerm] = useState('');
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [testStatus, setTestStatus] = useState<{ text: string, type: 'success' | 'error' | 'info' } | null>(null);
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' | 'info' | 'warning' }>({ open: false, message: '', severity: 'info' });

  // --- START: ADDED STATE AND HANDLERS FOR MODEL INFO DIALOG ---
  const [modelInfo, setModelInfo] = useState<ModelInfo | null>(null);
  const [openModelInfo, setOpenModelInfo] = useState(false);

  const handleOpenModelInfo = useCallback((model: ModelInfo) => {
    setModelInfo(model);
    setOpenModelInfo(true);
  }, []);

  const handleCloseModelInfo = useCallback(() => {
    setOpenModelInfo(false);
  }, []);
  // --- END: ADDED STATE AND HANDLERS ---

  useEffect(() => {
    if (user?.uid) {
      settingsStore.fetchAiConnections(user.uid);
    }
  }, [user?.uid, settingsStore.fetchAiConnections]);

  const showSnackbar = useCallback((message: string, severity: 'success' | 'error' | 'info' | 'warning' = 'info') => {
    setSnackbar({ open: true, message, severity });
  }, []);

  const handleOpenDialog = useCallback((connection?: AiConnection) => {
    setDialogStep(connection ? 'details' : 'select');
    setEditingConnection(connection ? { ...connection } : null);
    
    const templateKey = connection ? Object.keys(aiConnectionTemplates).find(k => aiConnectionTemplates[k].displayName === connection.displayName) : undefined;
    const initialModels = templateKey ? aiConnectionTemplates[templateKey].commonModels : (connection ? [{ id: connection.modelSlug, name: connection.modelName }] : []);
    
    setAvailableModels(initialModels);
    setModelSearchTerm('');
    setTestStatus(null);
    setIsDialogOpen(true);
  }, []);

  // ... (rest of the hook logic is correct and remains unchanged) ...
  const handleLoadTemplate = useCallback((templateKey: string) => {
    const template = aiConnectionTemplates[templateKey] || {
        displayName: 'Custom', modelName: '', modelSlug: '', apiUrl: '', apiToken: '', functionCallingEnabled: false,
        userAgent: 'StoryForge/1.0', supportsModelDiscovery: false, commonModels: [],
    };
    setEditingConnection({
      displayName: template.displayName,
      modelName: template.modelName,
      modelSlug: template.modelSlug,
      apiUrl: template.apiUrl,
      apiToken: template.apiToken,
      functionCallingEnabled: template.functionCallingEnabled,
      userAgent: template.userAgent || null,
      id: '',
      createdAt: '',
      lastUpdated: '',
    });
    
    setAvailableModels(template.commonModels);
    setModelSearchTerm('');
    setDialogStep('details');
  }, []);

  const handleFetchModels = useCallback(async () => {
    if (!editingConnection?.apiToken || editingConnection.apiToken.includes('PASTE')) {
      showSnackbar("Please enter a valid API key first.", "warning");
      return;
    }
    setIsFetchingModels(true);
    setTestStatus({ text: "Fetching models...", type: "info" });
    try {
      const models = await aiClient.listModels(editingConnection);
      setAvailableModels(models);
      setTestStatus({ text: `Success! Found ${models.length} models.`, type: "success" });
    } catch (error) {
      setTestStatus({ text: "Failed to fetch models. Check API Key and URL.", type: "error" });
    } finally {
      setIsFetchingModels(false);
    }
  }, [editingConnection, showSnackbar]);

  const filteredModels = useMemo(() => {
    if (!modelSearchTerm) {
      return availableModels;
    }
    const lowercasedFilter = modelSearchTerm.toLowerCase();
    return availableModels.filter(model =>
      model.name.toLowerCase().includes(lowercasedFilter) ||
      model.id.toLowerCase().includes(lowercasedFilter)
    );
  }, [availableModels, modelSearchTerm]);

  const handleCloseDialog = useCallback(() => {
    setIsDialogOpen(false);
  }, []);

  const handleUpdateEditingConnection = useCallback((updates: Partial<AiConnection>) => {
    setEditingConnection(prev => prev ? ({ ...prev, ...updates }) : null);
  }, []);

  const handleTest = useCallback(async () => {
    if (!editingConnection) return;
    setTestStatus({ text: 'Testing...', type: 'info' });
    const result = await aiClient.testConnection(editingConnection);
    if (result.success) {
      setTestStatus({ text: ` ${result.message}`, type: 'success' });
    } else {
      setTestStatus({ text: result.message, type: 'error' });
    }
  }, [editingConnection]);

  const handleSaveAndTest = useCallback(async () => {
    if (!user?.uid || !editingConnection) return;
    try {
      let savedConn: AiConnection | null;
      if (editingConnection.id) {
        savedConn = await settingsStore.updateAiConnection(user.uid, editingConnection);
        showSnackbar('Connection updated.', 'success');
      } else {
        savedConn = await settingsStore.addAiConnection(user.uid, editingConnection);
        showSnackbar('Connection added.', 'success');
      }
      
      if (savedConn) {
        setEditingConnection(savedConn);
        await handleTest();
      }
    } catch (e) {
      showSnackbar(`Failed to save: ${e instanceof Error ? e.message : 'Unknown error'}`, 'error');
    }
  }, [user, editingConnection, settingsStore, showSnackbar, handleTest]);

  const handleDelete = useCallback(async (connectionId: string) => {
    if (!user?.uid || !window.confirm("Are you sure you want to delete this connection?")) return;
    await settingsStore.deleteAiConnection(user.uid, connectionId);
    showSnackbar('Connection deleted.', 'success');
  }, [user, settingsStore, showSnackbar]);

  const closeSnackbar = useCallback(() => setSnackbar(prev => ({ ...prev, open: false })), []);

  return {
    ...settingsStore,
    isDialogOpen,
    dialogStep,
    editingConnection,
    availableModels,
    isFetchingModels,
    testStatus,
    snackbar,
    templates: aiConnectionTemplates,
    modelSearchTerm,
    setModelSearchTerm,
    filteredModels,
    handleOpenDialog,
    handleCloseDialog,
    handleLoadTemplate,
    handleUpdateEditingConnection,
    handleFetchModels,
    handleSaveAndTest,
    handleDelete,
    closeSnackbar,
    handleTest,
    // --- START: ADDED PROPERTIES TO RETURN OBJECT ---
    modelInfo,
    openModelInfo,
    handleOpenModelInfo,
    handleCloseModelInfo,
    // --- END: ADDED PROPERTIES ---
  };
};
@@FILE: src/utils/hooks/useWorldStateViewLogic.ts
// src/utils/hooks/useWorldStateViewLogic.ts
import { useState, useMemo, useCallback } from 'react';
// IMPORT THE SELECTOR FOR PINNED KEYS
import {
    useGameStateStore,
    selectWorldStatePinnedKeys,
    selectCurrentGameState,
  } from '../../state/useGameStateStore';
import { flattenJsonObject, getNestedValue } from '../../utils/jsonUtils';
import { debugLog, errorLog } from '../../utils/debug';

interface GroupedWorldState {
    [category: string]: {
        [entity: string]: {
            [variable: string]: any;
        };
    };
}

export const useWorldStateViewLogic = () => {
    const gameState = useGameStateStore(selectCurrentGameState);
    // 1. Get necessary state and actions from the store
    const worldStatePinnedKeys = useGameStateStore(selectWorldStatePinnedKeys);
    const {
        toggleWorldStatePin, // Action to toggle pins
        renameWorldCategory, // Action to rename categories
        renameWorldEntity,   // Action to rename entities
        deleteWorldCategory, // Action to delete categories
        deleteWorldEntity,   // Action to delete entities
        editWorldKeyValue,   // Action to edit key-value pairs
        deleteWorldKey,      // Action to delete keys
    } = useGameStateStore(); // Destructure actions directly

    // 2. Declare and initialize all local UI state variables
    const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());
    const [expandedEntities, setExpandedEntities] = useState<Set<string>>(new Set());
    const [editingCategory, setEditingCategory] = useState<string | null>(null);
    const [newCategoryName, setNewCategoryName] = useState('');
    const [editingEntity, setEditingEntity] = useState<[string, string] | null>(null); // Stores [category, entity]
    const [newEntityName, setNewEntityName] = useState('');

    // --- KEEP EXISTING DEBUG LINES ---
    debugLog('%c[useWorldStateViewLogic.ts] Hook re-executed.', 'color: #B8860B; font-weight: bold;');
    debugLog('[useWorldStateViewLogic.ts] Received gameState prop from WorldStateScreen:', JSON.stringify(gameState, null, 2));
    debugLog('[useWorldStateViewLogic.ts] Extracted worldState from prop (gameState?.worldState):', JSON.stringify(gameState?.worldState, null, 2));
    debugLog('[useWorldStateViewLogic.ts] Extracted worldState keys length (gameState?.worldState):', Object.keys(gameState?.worldState || {}).length);
    debugLog('[useWorldStateViewLogic.ts] Pinned keys directly from store (in logic):', worldStatePinnedKeys);
    // --- END DEBUG LINES ---

    const worldState = gameState?.worldState || {};
    const flattenedWorld = useMemo(() => {
        const flat = flattenJsonObject(worldState);
        debugLog('[useWorldStateViewLogic.ts] Calculated flattenedWorld (inside useMemo):', JSON.stringify(flat, null, 2));
        debugLog('[useWorldStateViewLogic.ts] Flattened World keys length (inside useMemo):', Object.keys(flat).length);
        return flat;
    }, [worldState]);

    const groupedByCategory = useMemo(() => {
        const grouped: GroupedWorldState = {};
        for (const fullKey in flattenedWorld) {
            const value = flattenedWorld[fullKey];
            const parts = fullKey.split(".");
            if (parts.length < 1) continue;

            const category = parts[0];
            const entity = (parts.length > 1 && (parts[1].startsWith('#') || parts[1].startsWith('@') || parts[1].startsWith('$'))) ? parts[1] : '@@_direct';
            const variable = (entity === '@@_direct') ? parts.slice(1).join('.') : parts.slice(2).join('.');
            if (!variable) continue;

            grouped[category] = grouped[category] || {};
            grouped[category][entity] = grouped[category][entity] || {};
            grouped[category][entity][variable] = value;
        }
        for (const category in grouped) {
            if (Object.keys(grouped[category]['@@_direct'] || {}).length === 0) {
                delete grouped[category]['@@_direct'];
            }
        }
        debugLog('[useWorldStateViewLogic.ts] Grouped by Category (inside useMemo):', JSON.stringify(grouped, null, 2));
        debugLog('[useWorldStateViewLogic.ts] Grouped by Category keys length (inside useMemo):', Object.keys(grouped).length);
        return grouped;
    }, [flattenedWorld]);

    // Utility to get all variable keys under a given path (entity or category)
    const getAllChildVariableKeys = useCallback((basePath: string): string[] => {
        const nestedData = getNestedValue(worldState, basePath.split('.'));
        if (typeof nestedData !== 'object' || nestedData === null) return [];
        // Flatten the nested data starting from the basePath to get its direct children keys
        return Object.keys(flattenJsonObject(nestedData, basePath));
    }, [worldState]);

    // Memoized checks for pinning status
    const isAnyChildPinned = useCallback((parentPath: string) => {
        return getAllChildVariableKeys(parentPath).some(key => worldStatePinnedKeys.includes(key));
    }, [getAllChildVariableKeys, worldStatePinnedKeys]);

    const areAllChildrenPinned = useCallback((parentPath: string) => {
        const childKeys = getAllChildVariableKeys(parentPath);
        return childKeys.length > 0 && childKeys.every(key => worldStatePinnedKeys.includes(key));
    }, [getAllChildVariableKeys, worldStatePinnedKeys]);

    // Handlers for expanding/collapsing categories and entities
    const handleToggleCategoryExpand = useCallback((category: string) => {
        setExpandedCategories(prev => {
            const newSet = new Set(prev);
            newSet.has(category) ? newSet.delete(category) : newSet.add(category);
            return newSet;
        });
    }, []);

    const handleToggleEntityExpand = useCallback((category: string, entity: string) => {
        const key = `${category}.${entity}`;
        setExpandedEntities(prev => {
            const newSet = new Set(prev);
            newSet.has(key) ? newSet.delete(key) : newSet.add(key);
            return newSet;
        });
    }, []);

    // Handlers for pinning/unpinning
    const handleToggleCategoryPin = useCallback((category: string) => {
        toggleWorldStatePin(category, 'category');
    }, [toggleWorldStatePin]);

    const handleToggleEntityPin = useCallback((entityPath: string) => {
        toggleWorldStatePin(entityPath, 'entity');
    }, [toggleWorldStatePin]);

    // Handlers for renaming category
    const handleStartRenameCategory = useCallback((category: string) => {
        setEditingCategory(category);
        setNewCategoryName(category); // Initialize input with current name
    }, []);

    const handleConfirmRenameCategory = useCallback(async () => {
        if (editingCategory && newCategoryName.trim() && newCategoryName !== editingCategory) {
            await renameWorldCategory(editingCategory, newCategoryName.trim());
        }
        setEditingCategory(null); // Exit edit mode
        setNewCategoryName(''); // Clear input
    }, [editingCategory, newCategoryName, renameWorldCategory]);

    // Handlers for renaming entity
    const handleStartRenameEntity = useCallback((entityPathParts: [string, string]) => { // entityPathParts is [category, entity]
        setEditingEntity(entityPathParts);
        setNewEntityName(entityPathParts[1]); // Initialize input with current entity name
    }, []);

    const handleConfirmRenameEntity = useCallback(async () => {
        if (editingEntity && newEntityName.trim() && newEntityName !== editingEntity[1]) {
            await renameWorldEntity(editingEntity[0], editingEntity[1], newEntityName.trim());
        }
        setEditingEntity(null); // Exit edit mode
        setNewEntityName(''); // Clear input
    }, [editingEntity, newEntityName, renameWorldEntity]);

    // Handler to cancel any edit operation
    const cancelEdit = useCallback(() => {
        setEditingCategory(null);
        setEditingEntity(null);
        setNewCategoryName('');
        setNewEntityName('');
    }, []);

    // 5. Return the clean API
    return {
        // Derived Data
        groupedByCategory,
        worldStatePinnedKeys,
        isAnyChildPinned,
        areAllChildrenPinned,

        // Local UI State
        expandedCategories,
        expandedEntities,
        editingCategory,
        newCategoryName,
        editingEntity,
        newEntityName,

        // Handlers (from store and local)
        handleToggleCategoryExpand,
        handleToggleEntityExpand,
        handleToggleCategoryPin,
        handleToggleEntityPin,
        handleStartRenameCategory,
        handleConfirmRenameCategory,
        setNewCategoryName,
        handleStartRenameEntity,
        handleConfirmRenameEntity,
        setNewEntityName,
        cancelEdit,

        // Actions passed directly from store (for clarity)
        deleteWorldCategory,
        deleteWorldEntity,
        editWorldKeyValue,
        deleteWorldKey,
        toggleWorldStatePin, // Ensure this is correctly passed if needed elsewhere
    };
};
@@FILE: src/utils/jsonUtils.ts
// src/utils/jsonUtils.ts


/**
 * Flattens a nested JSON object into a single-level map with dot-separated keys.
 * @param obj The JSON object to flatten.
 * @param prefix The prefix for the current level (used in recursion).
 * @returns A map where keys are dot-separated paths and values are primitives or arrays/objects at the leaf.
 */
export function flattenJsonObject(obj: Record<string, any>, prefix: string = ""): Record<string, any> {
  const result: Record<string, any> = {};

  for (const k in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      const fullKey = prefix ? `${prefix}.${k}` : k;
      const value = obj[k];

      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        Object.assign(result, flattenJsonObject(value, fullKey));
      } else {
        result[fullKey] = value;
      }
    }
  }
  return result;
}

/**
 * Attempts to parse a string into a JSON primitive (string, number, boolean, null).
 * This is a simplified version of the Android `parseJsonPrimitive` and may need robustness.
 * @param text The string to parse.
 * @returns The parsed JSON primitive or the original string if no better match.
 */
export function parseJsonPrimitive(text: string): any {
  const trimmed = text.trim();

  if (trimmed.toLowerCase() === 'true') return true;
  if (trimmed.toLowerCase() === 'false') return false;
  if (trimmed === 'null') return null;

  const num = Number(trimmed);
  if (!isNaN(num) && isFinite(num)) {
    return num;
  }

  // If it's a string that looks like a string (quoted), remove quotes
  if (trimmed.startsWith('"') && trimmed.endsWith('"') && trimmed.length >= 2) {
    return trimmed.substring(1, trimmed.length - 1);
  }

  // Fallback: if string doesn't parse cleanly, treat as raw string
  return trimmed;
}

/**
 * Safely retrieves a nested value from an object using a dot-separated path.
 * @param obj The object to traverse.
 * @param pathParts An array of strings representing the path.
 * @returns The value at the specified path, or undefined if not found.
 */
export function getNestedValue(obj: Record<string, any>, pathParts: string[]): any {
  let current: any = obj;
  for (const part of pathParts) {
    if (typeof current !== 'object' || current === null || !(part in current)) {
      return undefined;
    }
    current = current[part];
  }
  return current;
}
@@FILE: src/utils/types.ts
// src/utils/types.ts

export enum LogViewMode {
  NARRATOR_OUTPUT = 'Narrator Output',
  USER_INPUT = 'User Input',
  DIGEST_LINES = 'Digest Lines',
  DELTAS = 'Deltas',
  CONTEXT_SNAPSHOT = 'Context Snapshot',
  TOKEN_USAGE = 'Token Usage',
  AI_SETTINGS = 'AI Settings',
  API_DETAILS = 'API Details',
  ERROR_FLAGS = 'Error Flags',
  MODEL_SLUG_USED = 'Model Slug Used'
}
@@FILE: src/utils/uuid.ts
// src/utils/uuid.ts

import { v4 as uuidv4 } from 'uuid';

/**
 * Generates a new unique UUID (Universally Unique Identifier).
 * @returns A string representation of a UUID v4.
 */
export function generateUuid(): string {
  return uuidv4();
}
@@FILE: src/vite-env.d.ts
/// <reference types="vite/client" />

